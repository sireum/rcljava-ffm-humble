// Generated by jextract

package org.sireum.ffm.ros.humble;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct rclc_parameter_options_t {
 *     bool notify_changed_over_dds;
 *     size_t max_params;
 *     bool allow_undeclared_parameters;
 *     bool low_mem_mode;
 * }
 * }
 */
public class rclc_parameter_options_t {

    rclc_parameter_options_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        gen_h.C_BOOL.withName("notify_changed_over_dds"),
        MemoryLayout.paddingLayout(7),
        gen_h.C_LONG.withName("max_params"),
        gen_h.C_BOOL.withName("allow_undeclared_parameters"),
        gen_h.C_BOOL.withName("low_mem_mode"),
        MemoryLayout.paddingLayout(6)
    ).withName("rclc_parameter_options_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfBoolean notify_changed_over_dds$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("notify_changed_over_dds"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool notify_changed_over_dds
     * }
     */
    public static final OfBoolean notify_changed_over_dds$layout() {
        return notify_changed_over_dds$LAYOUT;
    }

    private static final long notify_changed_over_dds$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool notify_changed_over_dds
     * }
     */
    public static final long notify_changed_over_dds$offset() {
        return notify_changed_over_dds$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool notify_changed_over_dds
     * }
     */
    public static boolean notify_changed_over_dds(MemorySegment struct) {
        return struct.get(notify_changed_over_dds$LAYOUT, notify_changed_over_dds$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool notify_changed_over_dds
     * }
     */
    public static void notify_changed_over_dds(MemorySegment struct, boolean fieldValue) {
        struct.set(notify_changed_over_dds$LAYOUT, notify_changed_over_dds$OFFSET, fieldValue);
    }

    private static final OfLong max_params$LAYOUT = (OfLong)$LAYOUT.select(groupElement("max_params"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t max_params
     * }
     */
    public static final OfLong max_params$layout() {
        return max_params$LAYOUT;
    }

    private static final long max_params$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t max_params
     * }
     */
    public static final long max_params$offset() {
        return max_params$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t max_params
     * }
     */
    public static long max_params(MemorySegment struct) {
        return struct.get(max_params$LAYOUT, max_params$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t max_params
     * }
     */
    public static void max_params(MemorySegment struct, long fieldValue) {
        struct.set(max_params$LAYOUT, max_params$OFFSET, fieldValue);
    }

    private static final OfBoolean allow_undeclared_parameters$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("allow_undeclared_parameters"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool allow_undeclared_parameters
     * }
     */
    public static final OfBoolean allow_undeclared_parameters$layout() {
        return allow_undeclared_parameters$LAYOUT;
    }

    private static final long allow_undeclared_parameters$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool allow_undeclared_parameters
     * }
     */
    public static final long allow_undeclared_parameters$offset() {
        return allow_undeclared_parameters$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool allow_undeclared_parameters
     * }
     */
    public static boolean allow_undeclared_parameters(MemorySegment struct) {
        return struct.get(allow_undeclared_parameters$LAYOUT, allow_undeclared_parameters$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool allow_undeclared_parameters
     * }
     */
    public static void allow_undeclared_parameters(MemorySegment struct, boolean fieldValue) {
        struct.set(allow_undeclared_parameters$LAYOUT, allow_undeclared_parameters$OFFSET, fieldValue);
    }

    private static final OfBoolean low_mem_mode$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("low_mem_mode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool low_mem_mode
     * }
     */
    public static final OfBoolean low_mem_mode$layout() {
        return low_mem_mode$LAYOUT;
    }

    private static final long low_mem_mode$OFFSET = 17;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool low_mem_mode
     * }
     */
    public static final long low_mem_mode$offset() {
        return low_mem_mode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool low_mem_mode
     * }
     */
    public static boolean low_mem_mode(MemorySegment struct) {
        return struct.get(low_mem_mode$LAYOUT, low_mem_mode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool low_mem_mode
     * }
     */
    public static void low_mem_mode(MemorySegment struct, boolean fieldValue) {
        struct.set(low_mem_mode$LAYOUT, low_mem_mode$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

