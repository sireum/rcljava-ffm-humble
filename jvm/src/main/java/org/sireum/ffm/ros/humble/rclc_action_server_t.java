// Generated by jextract

package org.sireum.ffm.ros.humble;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct rclc_action_server_t {
 *     rclc_action_goal_handle_t *goal_handles_memory;
 *     size_t goal_handles_memory_size;
 *     rclc_action_goal_handle_t *free_goal_handles;
 *     rclc_action_goal_handle_t *used_goal_handles;
 *     rcl_action_server_t rcl_handle;
 *     const rcl_allocator_t *allocator;
 *     rclc_action_server_handle_goal_callback_t goal_callback;
 *     rclc_action_server_handle_cancel_callback_t cancel_callback;
 *     bool goal_request_available;
 *     bool cancel_request_available;
 *     bool result_request_available;
 *     bool goal_expired_available;
 *     bool goal_ended;
 * }
 * }
 */
public class rclc_action_server_t {

    rclc_action_server_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        gen_h.C_POINTER.withName("goal_handles_memory"),
        gen_h.C_LONG.withName("goal_handles_memory_size"),
        gen_h.C_POINTER.withName("free_goal_handles"),
        gen_h.C_POINTER.withName("used_goal_handles"),
        rcl_action_server_s.layout().withName("rcl_handle"),
        gen_h.C_POINTER.withName("allocator"),
        gen_h.C_POINTER.withName("goal_callback"),
        gen_h.C_POINTER.withName("cancel_callback"),
        gen_h.C_BOOL.withName("goal_request_available"),
        gen_h.C_BOOL.withName("cancel_request_available"),
        gen_h.C_BOOL.withName("result_request_available"),
        gen_h.C_BOOL.withName("goal_expired_available"),
        gen_h.C_BOOL.withName("goal_ended"),
        MemoryLayout.paddingLayout(3)
    ).withName("rclc_action_server_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout goal_handles_memory$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("goal_handles_memory"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *goal_handles_memory
     * }
     */
    public static final AddressLayout goal_handles_memory$layout() {
        return goal_handles_memory$LAYOUT;
    }

    private static final long goal_handles_memory$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *goal_handles_memory
     * }
     */
    public static final long goal_handles_memory$offset() {
        return goal_handles_memory$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *goal_handles_memory
     * }
     */
    public static MemorySegment goal_handles_memory(MemorySegment struct) {
        return struct.get(goal_handles_memory$LAYOUT, goal_handles_memory$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *goal_handles_memory
     * }
     */
    public static void goal_handles_memory(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(goal_handles_memory$LAYOUT, goal_handles_memory$OFFSET, fieldValue);
    }

    private static final OfLong goal_handles_memory_size$LAYOUT = (OfLong)$LAYOUT.select(groupElement("goal_handles_memory_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t goal_handles_memory_size
     * }
     */
    public static final OfLong goal_handles_memory_size$layout() {
        return goal_handles_memory_size$LAYOUT;
    }

    private static final long goal_handles_memory_size$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t goal_handles_memory_size
     * }
     */
    public static final long goal_handles_memory_size$offset() {
        return goal_handles_memory_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t goal_handles_memory_size
     * }
     */
    public static long goal_handles_memory_size(MemorySegment struct) {
        return struct.get(goal_handles_memory_size$LAYOUT, goal_handles_memory_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t goal_handles_memory_size
     * }
     */
    public static void goal_handles_memory_size(MemorySegment struct, long fieldValue) {
        struct.set(goal_handles_memory_size$LAYOUT, goal_handles_memory_size$OFFSET, fieldValue);
    }

    private static final AddressLayout free_goal_handles$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("free_goal_handles"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *free_goal_handles
     * }
     */
    public static final AddressLayout free_goal_handles$layout() {
        return free_goal_handles$LAYOUT;
    }

    private static final long free_goal_handles$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *free_goal_handles
     * }
     */
    public static final long free_goal_handles$offset() {
        return free_goal_handles$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *free_goal_handles
     * }
     */
    public static MemorySegment free_goal_handles(MemorySegment struct) {
        return struct.get(free_goal_handles$LAYOUT, free_goal_handles$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *free_goal_handles
     * }
     */
    public static void free_goal_handles(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(free_goal_handles$LAYOUT, free_goal_handles$OFFSET, fieldValue);
    }

    private static final AddressLayout used_goal_handles$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("used_goal_handles"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *used_goal_handles
     * }
     */
    public static final AddressLayout used_goal_handles$layout() {
        return used_goal_handles$LAYOUT;
    }

    private static final long used_goal_handles$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *used_goal_handles
     * }
     */
    public static final long used_goal_handles$offset() {
        return used_goal_handles$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *used_goal_handles
     * }
     */
    public static MemorySegment used_goal_handles(MemorySegment struct) {
        return struct.get(used_goal_handles$LAYOUT, used_goal_handles$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *used_goal_handles
     * }
     */
    public static void used_goal_handles(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(used_goal_handles$LAYOUT, used_goal_handles$OFFSET, fieldValue);
    }

    private static final GroupLayout rcl_handle$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("rcl_handle"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rcl_action_server_t rcl_handle
     * }
     */
    public static final GroupLayout rcl_handle$layout() {
        return rcl_handle$LAYOUT;
    }

    private static final long rcl_handle$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rcl_action_server_t rcl_handle
     * }
     */
    public static final long rcl_handle$offset() {
        return rcl_handle$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rcl_action_server_t rcl_handle
     * }
     */
    public static MemorySegment rcl_handle(MemorySegment struct) {
        return struct.asSlice(rcl_handle$OFFSET, rcl_handle$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rcl_action_server_t rcl_handle
     * }
     */
    public static void rcl_handle(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, rcl_handle$OFFSET, rcl_handle$LAYOUT.byteSize());
    }

    private static final AddressLayout allocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("allocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static final AddressLayout allocator$layout() {
        return allocator$LAYOUT;
    }

    private static final long allocator$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static final long allocator$offset() {
        return allocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static MemorySegment allocator(MemorySegment struct) {
        return struct.get(allocator$LAYOUT, allocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static void allocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(allocator$LAYOUT, allocator$OFFSET, fieldValue);
    }

    private static final AddressLayout goal_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("goal_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_server_handle_goal_callback_t goal_callback
     * }
     */
    public static final AddressLayout goal_callback$layout() {
        return goal_callback$LAYOUT;
    }

    private static final long goal_callback$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_server_handle_goal_callback_t goal_callback
     * }
     */
    public static final long goal_callback$offset() {
        return goal_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_server_handle_goal_callback_t goal_callback
     * }
     */
    public static MemorySegment goal_callback(MemorySegment struct) {
        return struct.get(goal_callback$LAYOUT, goal_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_server_handle_goal_callback_t goal_callback
     * }
     */
    public static void goal_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(goal_callback$LAYOUT, goal_callback$OFFSET, fieldValue);
    }

    private static final AddressLayout cancel_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cancel_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_server_handle_cancel_callback_t cancel_callback
     * }
     */
    public static final AddressLayout cancel_callback$layout() {
        return cancel_callback$LAYOUT;
    }

    private static final long cancel_callback$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_server_handle_cancel_callback_t cancel_callback
     * }
     */
    public static final long cancel_callback$offset() {
        return cancel_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_server_handle_cancel_callback_t cancel_callback
     * }
     */
    public static MemorySegment cancel_callback(MemorySegment struct) {
        return struct.get(cancel_callback$LAYOUT, cancel_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_server_handle_cancel_callback_t cancel_callback
     * }
     */
    public static void cancel_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cancel_callback$LAYOUT, cancel_callback$OFFSET, fieldValue);
    }

    private static final OfBoolean goal_request_available$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("goal_request_available"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool goal_request_available
     * }
     */
    public static final OfBoolean goal_request_available$layout() {
        return goal_request_available$LAYOUT;
    }

    private static final long goal_request_available$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool goal_request_available
     * }
     */
    public static final long goal_request_available$offset() {
        return goal_request_available$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool goal_request_available
     * }
     */
    public static boolean goal_request_available(MemorySegment struct) {
        return struct.get(goal_request_available$LAYOUT, goal_request_available$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool goal_request_available
     * }
     */
    public static void goal_request_available(MemorySegment struct, boolean fieldValue) {
        struct.set(goal_request_available$LAYOUT, goal_request_available$OFFSET, fieldValue);
    }

    private static final OfBoolean cancel_request_available$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("cancel_request_available"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool cancel_request_available
     * }
     */
    public static final OfBoolean cancel_request_available$layout() {
        return cancel_request_available$LAYOUT;
    }

    private static final long cancel_request_available$OFFSET = 65;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool cancel_request_available
     * }
     */
    public static final long cancel_request_available$offset() {
        return cancel_request_available$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool cancel_request_available
     * }
     */
    public static boolean cancel_request_available(MemorySegment struct) {
        return struct.get(cancel_request_available$LAYOUT, cancel_request_available$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool cancel_request_available
     * }
     */
    public static void cancel_request_available(MemorySegment struct, boolean fieldValue) {
        struct.set(cancel_request_available$LAYOUT, cancel_request_available$OFFSET, fieldValue);
    }

    private static final OfBoolean result_request_available$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("result_request_available"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool result_request_available
     * }
     */
    public static final OfBoolean result_request_available$layout() {
        return result_request_available$LAYOUT;
    }

    private static final long result_request_available$OFFSET = 66;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool result_request_available
     * }
     */
    public static final long result_request_available$offset() {
        return result_request_available$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool result_request_available
     * }
     */
    public static boolean result_request_available(MemorySegment struct) {
        return struct.get(result_request_available$LAYOUT, result_request_available$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool result_request_available
     * }
     */
    public static void result_request_available(MemorySegment struct, boolean fieldValue) {
        struct.set(result_request_available$LAYOUT, result_request_available$OFFSET, fieldValue);
    }

    private static final OfBoolean goal_expired_available$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("goal_expired_available"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool goal_expired_available
     * }
     */
    public static final OfBoolean goal_expired_available$layout() {
        return goal_expired_available$LAYOUT;
    }

    private static final long goal_expired_available$OFFSET = 67;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool goal_expired_available
     * }
     */
    public static final long goal_expired_available$offset() {
        return goal_expired_available$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool goal_expired_available
     * }
     */
    public static boolean goal_expired_available(MemorySegment struct) {
        return struct.get(goal_expired_available$LAYOUT, goal_expired_available$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool goal_expired_available
     * }
     */
    public static void goal_expired_available(MemorySegment struct, boolean fieldValue) {
        struct.set(goal_expired_available$LAYOUT, goal_expired_available$OFFSET, fieldValue);
    }

    private static final OfBoolean goal_ended$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("goal_ended"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool goal_ended
     * }
     */
    public static final OfBoolean goal_ended$layout() {
        return goal_ended$LAYOUT;
    }

    private static final long goal_ended$OFFSET = 68;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool goal_ended
     * }
     */
    public static final long goal_ended$offset() {
        return goal_ended$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool goal_ended
     * }
     */
    public static boolean goal_ended(MemorySegment struct) {
        return struct.get(goal_ended$LAYOUT, goal_ended$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool goal_ended
     * }
     */
    public static void goal_ended(MemorySegment struct, boolean fieldValue) {
        struct.set(goal_ended$LAYOUT, goal_ended$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

