// Generated by jextract

package org.sireum.ffm.ros.humble;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct rclc_action_client_t {
 *     rclc_action_goal_handle_t *goal_handles_memory;
 *     size_t goal_handles_memory_size;
 *     rclc_action_goal_handle_t *free_goal_handles;
 *     rclc_action_goal_handle_t *used_goal_handles;
 *     rcl_action_client_t rcl_handle;
 *     const rcl_allocator_t *allocator;
 *     rclc_action_client_goal_callback_t goal_callback;
 *     rclc_action_client_feedback_callback_t feedback_callback;
 *     rclc_action_client_result_callback_t result_callback;
 *     rclc_action_client_cancel_callback_t cancel_callback;
 *     struct Generic_FeedbackMessage *ros_feedback;
 *     struct Generic_GetResult_Response *ros_result_response;
 *     action_msgs__srv__CancelGoal_Response ros_cancel_response;
 *     bool feedback_available;
 *     bool status_available;
 *     bool goal_response_available;
 *     bool result_response_available;
 *     bool cancel_response_available;
 * }
 * }
 */
public class rclc_action_client_t {

    rclc_action_client_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        gen_h.C_POINTER.withName("goal_handles_memory"),
        gen_h.C_LONG.withName("goal_handles_memory_size"),
        gen_h.C_POINTER.withName("free_goal_handles"),
        gen_h.C_POINTER.withName("used_goal_handles"),
        rcl_action_client_s.layout().withName("rcl_handle"),
        gen_h.C_POINTER.withName("allocator"),
        gen_h.C_POINTER.withName("goal_callback"),
        gen_h.C_POINTER.withName("feedback_callback"),
        gen_h.C_POINTER.withName("result_callback"),
        gen_h.C_POINTER.withName("cancel_callback"),
        gen_h.C_POINTER.withName("ros_feedback"),
        gen_h.C_POINTER.withName("ros_result_response"),
        action_msgs__srv__CancelGoal_Response.layout().withName("ros_cancel_response"),
        gen_h.C_BOOL.withName("feedback_available"),
        gen_h.C_BOOL.withName("status_available"),
        gen_h.C_BOOL.withName("goal_response_available"),
        gen_h.C_BOOL.withName("result_response_available"),
        gen_h.C_BOOL.withName("cancel_response_available"),
        MemoryLayout.paddingLayout(3)
    ).withName("rclc_action_client_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout goal_handles_memory$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("goal_handles_memory"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *goal_handles_memory
     * }
     */
    public static final AddressLayout goal_handles_memory$layout() {
        return goal_handles_memory$LAYOUT;
    }

    private static final long goal_handles_memory$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *goal_handles_memory
     * }
     */
    public static final long goal_handles_memory$offset() {
        return goal_handles_memory$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *goal_handles_memory
     * }
     */
    public static MemorySegment goal_handles_memory(MemorySegment struct) {
        return struct.get(goal_handles_memory$LAYOUT, goal_handles_memory$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *goal_handles_memory
     * }
     */
    public static void goal_handles_memory(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(goal_handles_memory$LAYOUT, goal_handles_memory$OFFSET, fieldValue);
    }

    private static final OfLong goal_handles_memory_size$LAYOUT = (OfLong)$LAYOUT.select(groupElement("goal_handles_memory_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t goal_handles_memory_size
     * }
     */
    public static final OfLong goal_handles_memory_size$layout() {
        return goal_handles_memory_size$LAYOUT;
    }

    private static final long goal_handles_memory_size$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t goal_handles_memory_size
     * }
     */
    public static final long goal_handles_memory_size$offset() {
        return goal_handles_memory_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t goal_handles_memory_size
     * }
     */
    public static long goal_handles_memory_size(MemorySegment struct) {
        return struct.get(goal_handles_memory_size$LAYOUT, goal_handles_memory_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t goal_handles_memory_size
     * }
     */
    public static void goal_handles_memory_size(MemorySegment struct, long fieldValue) {
        struct.set(goal_handles_memory_size$LAYOUT, goal_handles_memory_size$OFFSET, fieldValue);
    }

    private static final AddressLayout free_goal_handles$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("free_goal_handles"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *free_goal_handles
     * }
     */
    public static final AddressLayout free_goal_handles$layout() {
        return free_goal_handles$LAYOUT;
    }

    private static final long free_goal_handles$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *free_goal_handles
     * }
     */
    public static final long free_goal_handles$offset() {
        return free_goal_handles$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *free_goal_handles
     * }
     */
    public static MemorySegment free_goal_handles(MemorySegment struct) {
        return struct.get(free_goal_handles$LAYOUT, free_goal_handles$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *free_goal_handles
     * }
     */
    public static void free_goal_handles(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(free_goal_handles$LAYOUT, free_goal_handles$OFFSET, fieldValue);
    }

    private static final AddressLayout used_goal_handles$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("used_goal_handles"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *used_goal_handles
     * }
     */
    public static final AddressLayout used_goal_handles$layout() {
        return used_goal_handles$LAYOUT;
    }

    private static final long used_goal_handles$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *used_goal_handles
     * }
     */
    public static final long used_goal_handles$offset() {
        return used_goal_handles$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *used_goal_handles
     * }
     */
    public static MemorySegment used_goal_handles(MemorySegment struct) {
        return struct.get(used_goal_handles$LAYOUT, used_goal_handles$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_goal_handle_t *used_goal_handles
     * }
     */
    public static void used_goal_handles(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(used_goal_handles$LAYOUT, used_goal_handles$OFFSET, fieldValue);
    }

    private static final GroupLayout rcl_handle$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("rcl_handle"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rcl_action_client_t rcl_handle
     * }
     */
    public static final GroupLayout rcl_handle$layout() {
        return rcl_handle$LAYOUT;
    }

    private static final long rcl_handle$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rcl_action_client_t rcl_handle
     * }
     */
    public static final long rcl_handle$offset() {
        return rcl_handle$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rcl_action_client_t rcl_handle
     * }
     */
    public static MemorySegment rcl_handle(MemorySegment struct) {
        return struct.asSlice(rcl_handle$OFFSET, rcl_handle$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rcl_action_client_t rcl_handle
     * }
     */
    public static void rcl_handle(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, rcl_handle$OFFSET, rcl_handle$LAYOUT.byteSize());
    }

    private static final AddressLayout allocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("allocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static final AddressLayout allocator$layout() {
        return allocator$LAYOUT;
    }

    private static final long allocator$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static final long allocator$offset() {
        return allocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static MemorySegment allocator(MemorySegment struct) {
        return struct.get(allocator$LAYOUT, allocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static void allocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(allocator$LAYOUT, allocator$OFFSET, fieldValue);
    }

    private static final AddressLayout goal_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("goal_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_client_goal_callback_t goal_callback
     * }
     */
    public static final AddressLayout goal_callback$layout() {
        return goal_callback$LAYOUT;
    }

    private static final long goal_callback$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_client_goal_callback_t goal_callback
     * }
     */
    public static final long goal_callback$offset() {
        return goal_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_client_goal_callback_t goal_callback
     * }
     */
    public static MemorySegment goal_callback(MemorySegment struct) {
        return struct.get(goal_callback$LAYOUT, goal_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_client_goal_callback_t goal_callback
     * }
     */
    public static void goal_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(goal_callback$LAYOUT, goal_callback$OFFSET, fieldValue);
    }

    private static final AddressLayout feedback_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("feedback_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_client_feedback_callback_t feedback_callback
     * }
     */
    public static final AddressLayout feedback_callback$layout() {
        return feedback_callback$LAYOUT;
    }

    private static final long feedback_callback$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_client_feedback_callback_t feedback_callback
     * }
     */
    public static final long feedback_callback$offset() {
        return feedback_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_client_feedback_callback_t feedback_callback
     * }
     */
    public static MemorySegment feedback_callback(MemorySegment struct) {
        return struct.get(feedback_callback$LAYOUT, feedback_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_client_feedback_callback_t feedback_callback
     * }
     */
    public static void feedback_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(feedback_callback$LAYOUT, feedback_callback$OFFSET, fieldValue);
    }

    private static final AddressLayout result_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("result_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_client_result_callback_t result_callback
     * }
     */
    public static final AddressLayout result_callback$layout() {
        return result_callback$LAYOUT;
    }

    private static final long result_callback$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_client_result_callback_t result_callback
     * }
     */
    public static final long result_callback$offset() {
        return result_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_client_result_callback_t result_callback
     * }
     */
    public static MemorySegment result_callback(MemorySegment struct) {
        return struct.get(result_callback$LAYOUT, result_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_client_result_callback_t result_callback
     * }
     */
    public static void result_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(result_callback$LAYOUT, result_callback$OFFSET, fieldValue);
    }

    private static final AddressLayout cancel_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cancel_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_action_client_cancel_callback_t cancel_callback
     * }
     */
    public static final AddressLayout cancel_callback$layout() {
        return cancel_callback$LAYOUT;
    }

    private static final long cancel_callback$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_action_client_cancel_callback_t cancel_callback
     * }
     */
    public static final long cancel_callback$offset() {
        return cancel_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_action_client_cancel_callback_t cancel_callback
     * }
     */
    public static MemorySegment cancel_callback(MemorySegment struct) {
        return struct.get(cancel_callback$LAYOUT, cancel_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_action_client_cancel_callback_t cancel_callback
     * }
     */
    public static void cancel_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cancel_callback$LAYOUT, cancel_callback$OFFSET, fieldValue);
    }

    private static final AddressLayout ros_feedback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ros_feedback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct Generic_FeedbackMessage *ros_feedback
     * }
     */
    public static final AddressLayout ros_feedback$layout() {
        return ros_feedback$LAYOUT;
    }

    private static final long ros_feedback$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct Generic_FeedbackMessage *ros_feedback
     * }
     */
    public static final long ros_feedback$offset() {
        return ros_feedback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct Generic_FeedbackMessage *ros_feedback
     * }
     */
    public static MemorySegment ros_feedback(MemorySegment struct) {
        return struct.get(ros_feedback$LAYOUT, ros_feedback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct Generic_FeedbackMessage *ros_feedback
     * }
     */
    public static void ros_feedback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ros_feedback$LAYOUT, ros_feedback$OFFSET, fieldValue);
    }

    private static final AddressLayout ros_result_response$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ros_result_response"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct Generic_GetResult_Response *ros_result_response
     * }
     */
    public static final AddressLayout ros_result_response$layout() {
        return ros_result_response$LAYOUT;
    }

    private static final long ros_result_response$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct Generic_GetResult_Response *ros_result_response
     * }
     */
    public static final long ros_result_response$offset() {
        return ros_result_response$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct Generic_GetResult_Response *ros_result_response
     * }
     */
    public static MemorySegment ros_result_response(MemorySegment struct) {
        return struct.get(ros_result_response$LAYOUT, ros_result_response$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct Generic_GetResult_Response *ros_result_response
     * }
     */
    public static void ros_result_response(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ros_result_response$LAYOUT, ros_result_response$OFFSET, fieldValue);
    }

    private static final GroupLayout ros_cancel_response$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("ros_cancel_response"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * action_msgs__srv__CancelGoal_Response ros_cancel_response
     * }
     */
    public static final GroupLayout ros_cancel_response$layout() {
        return ros_cancel_response$LAYOUT;
    }

    private static final long ros_cancel_response$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * action_msgs__srv__CancelGoal_Response ros_cancel_response
     * }
     */
    public static final long ros_cancel_response$offset() {
        return ros_cancel_response$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * action_msgs__srv__CancelGoal_Response ros_cancel_response
     * }
     */
    public static MemorySegment ros_cancel_response(MemorySegment struct) {
        return struct.asSlice(ros_cancel_response$OFFSET, ros_cancel_response$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * action_msgs__srv__CancelGoal_Response ros_cancel_response
     * }
     */
    public static void ros_cancel_response(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, ros_cancel_response$OFFSET, ros_cancel_response$LAYOUT.byteSize());
    }

    private static final OfBoolean feedback_available$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("feedback_available"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool feedback_available
     * }
     */
    public static final OfBoolean feedback_available$layout() {
        return feedback_available$LAYOUT;
    }

    private static final long feedback_available$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool feedback_available
     * }
     */
    public static final long feedback_available$offset() {
        return feedback_available$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool feedback_available
     * }
     */
    public static boolean feedback_available(MemorySegment struct) {
        return struct.get(feedback_available$LAYOUT, feedback_available$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool feedback_available
     * }
     */
    public static void feedback_available(MemorySegment struct, boolean fieldValue) {
        struct.set(feedback_available$LAYOUT, feedback_available$OFFSET, fieldValue);
    }

    private static final OfBoolean status_available$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("status_available"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool status_available
     * }
     */
    public static final OfBoolean status_available$layout() {
        return status_available$LAYOUT;
    }

    private static final long status_available$OFFSET = 129;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool status_available
     * }
     */
    public static final long status_available$offset() {
        return status_available$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool status_available
     * }
     */
    public static boolean status_available(MemorySegment struct) {
        return struct.get(status_available$LAYOUT, status_available$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool status_available
     * }
     */
    public static void status_available(MemorySegment struct, boolean fieldValue) {
        struct.set(status_available$LAYOUT, status_available$OFFSET, fieldValue);
    }

    private static final OfBoolean goal_response_available$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("goal_response_available"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool goal_response_available
     * }
     */
    public static final OfBoolean goal_response_available$layout() {
        return goal_response_available$LAYOUT;
    }

    private static final long goal_response_available$OFFSET = 130;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool goal_response_available
     * }
     */
    public static final long goal_response_available$offset() {
        return goal_response_available$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool goal_response_available
     * }
     */
    public static boolean goal_response_available(MemorySegment struct) {
        return struct.get(goal_response_available$LAYOUT, goal_response_available$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool goal_response_available
     * }
     */
    public static void goal_response_available(MemorySegment struct, boolean fieldValue) {
        struct.set(goal_response_available$LAYOUT, goal_response_available$OFFSET, fieldValue);
    }

    private static final OfBoolean result_response_available$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("result_response_available"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool result_response_available
     * }
     */
    public static final OfBoolean result_response_available$layout() {
        return result_response_available$LAYOUT;
    }

    private static final long result_response_available$OFFSET = 131;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool result_response_available
     * }
     */
    public static final long result_response_available$offset() {
        return result_response_available$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool result_response_available
     * }
     */
    public static boolean result_response_available(MemorySegment struct) {
        return struct.get(result_response_available$LAYOUT, result_response_available$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool result_response_available
     * }
     */
    public static void result_response_available(MemorySegment struct, boolean fieldValue) {
        struct.set(result_response_available$LAYOUT, result_response_available$OFFSET, fieldValue);
    }

    private static final OfBoolean cancel_response_available$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("cancel_response_available"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool cancel_response_available
     * }
     */
    public static final OfBoolean cancel_response_available$layout() {
        return cancel_response_available$LAYOUT;
    }

    private static final long cancel_response_available$OFFSET = 132;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool cancel_response_available
     * }
     */
    public static final long cancel_response_available$offset() {
        return cancel_response_available$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool cancel_response_available
     * }
     */
    public static boolean cancel_response_available(MemorySegment struct) {
        return struct.get(cancel_response_available$LAYOUT, cancel_response_available$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool cancel_response_available
     * }
     */
    public static void cancel_response_available(MemorySegment struct, boolean fieldValue) {
        struct.set(cancel_response_available$LAYOUT, cancel_response_available$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

