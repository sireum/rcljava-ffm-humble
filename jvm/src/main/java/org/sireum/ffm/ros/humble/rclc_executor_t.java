// Generated by jextract

package org.sireum.ffm.ros.humble;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct {
 *     rcl_context_t *context;
 *     rclc_executor_handle_t *handles;
 *     size_t max_handles;
 *     size_t index;
 *     const rcl_allocator_t *allocator;
 *     rcl_wait_set_t wait_set;
 *     rclc_executor_handle_counters_t info;
 *     uint64_t timeout_ns;
 *     rcutils_time_point_value_t invocation_time;
 *     rclc_executor_trigger_t trigger_function;
 *     void *trigger_object;
 *     rclc_executor_semantics_t data_comm_semantics;
 * }
 * }
 */
public class rclc_executor_t {

    rclc_executor_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        gen_h.C_POINTER.withName("context"),
        gen_h.C_POINTER.withName("handles"),
        gen_h.C_LONG.withName("max_handles"),
        gen_h.C_LONG.withName("index"),
        gen_h.C_POINTER.withName("allocator"),
        rcl_wait_set_s.layout().withName("wait_set"),
        rclc_executor_handle_counters_t.layout().withName("info"),
        gen_h.C_LONG.withName("timeout_ns"),
        gen_h.C_LONG.withName("invocation_time"),
        gen_h.C_POINTER.withName("trigger_function"),
        gen_h.C_POINTER.withName("trigger_object"),
        gen_h.C_INT.withName("data_comm_semantics"),
        MemoryLayout.paddingLayout(4)
    ).withName("$anon$60:9");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout context$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("context"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rcl_context_t *context
     * }
     */
    public static final AddressLayout context$layout() {
        return context$LAYOUT;
    }

    private static final long context$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rcl_context_t *context
     * }
     */
    public static final long context$offset() {
        return context$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rcl_context_t *context
     * }
     */
    public static MemorySegment context(MemorySegment struct) {
        return struct.get(context$LAYOUT, context$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rcl_context_t *context
     * }
     */
    public static void context(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(context$LAYOUT, context$OFFSET, fieldValue);
    }

    private static final AddressLayout handles$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("handles"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_executor_handle_t *handles
     * }
     */
    public static final AddressLayout handles$layout() {
        return handles$LAYOUT;
    }

    private static final long handles$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_executor_handle_t *handles
     * }
     */
    public static final long handles$offset() {
        return handles$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_executor_handle_t *handles
     * }
     */
    public static MemorySegment handles(MemorySegment struct) {
        return struct.get(handles$LAYOUT, handles$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_executor_handle_t *handles
     * }
     */
    public static void handles(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(handles$LAYOUT, handles$OFFSET, fieldValue);
    }

    private static final OfLong max_handles$LAYOUT = (OfLong)$LAYOUT.select(groupElement("max_handles"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t max_handles
     * }
     */
    public static final OfLong max_handles$layout() {
        return max_handles$LAYOUT;
    }

    private static final long max_handles$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t max_handles
     * }
     */
    public static final long max_handles$offset() {
        return max_handles$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t max_handles
     * }
     */
    public static long max_handles(MemorySegment struct) {
        return struct.get(max_handles$LAYOUT, max_handles$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t max_handles
     * }
     */
    public static void max_handles(MemorySegment struct, long fieldValue) {
        struct.set(max_handles$LAYOUT, max_handles$OFFSET, fieldValue);
    }

    private static final OfLong index$LAYOUT = (OfLong)$LAYOUT.select(groupElement("index"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t index
     * }
     */
    public static final OfLong index$layout() {
        return index$LAYOUT;
    }

    private static final long index$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t index
     * }
     */
    public static final long index$offset() {
        return index$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t index
     * }
     */
    public static long index(MemorySegment struct) {
        return struct.get(index$LAYOUT, index$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t index
     * }
     */
    public static void index(MemorySegment struct, long fieldValue) {
        struct.set(index$LAYOUT, index$OFFSET, fieldValue);
    }

    private static final AddressLayout allocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("allocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static final AddressLayout allocator$layout() {
        return allocator$LAYOUT;
    }

    private static final long allocator$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static final long allocator$offset() {
        return allocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static MemorySegment allocator(MemorySegment struct) {
        return struct.get(allocator$LAYOUT, allocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const rcl_allocator_t *allocator
     * }
     */
    public static void allocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(allocator$LAYOUT, allocator$OFFSET, fieldValue);
    }

    private static final GroupLayout wait_set$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("wait_set"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rcl_wait_set_t wait_set
     * }
     */
    public static final GroupLayout wait_set$layout() {
        return wait_set$LAYOUT;
    }

    private static final long wait_set$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rcl_wait_set_t wait_set
     * }
     */
    public static final long wait_set$offset() {
        return wait_set$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rcl_wait_set_t wait_set
     * }
     */
    public static MemorySegment wait_set(MemorySegment struct) {
        return struct.asSlice(wait_set$OFFSET, wait_set$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rcl_wait_set_t wait_set
     * }
     */
    public static void wait_set(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, wait_set$OFFSET, wait_set$LAYOUT.byteSize());
    }

    private static final GroupLayout info$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("info"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_executor_handle_counters_t info
     * }
     */
    public static final GroupLayout info$layout() {
        return info$LAYOUT;
    }

    private static final long info$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_executor_handle_counters_t info
     * }
     */
    public static final long info$offset() {
        return info$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_executor_handle_counters_t info
     * }
     */
    public static MemorySegment info(MemorySegment struct) {
        return struct.asSlice(info$OFFSET, info$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_executor_handle_counters_t info
     * }
     */
    public static void info(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, info$OFFSET, info$LAYOUT.byteSize());
    }

    private static final OfLong timeout_ns$LAYOUT = (OfLong)$LAYOUT.select(groupElement("timeout_ns"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t timeout_ns
     * }
     */
    public static final OfLong timeout_ns$layout() {
        return timeout_ns$LAYOUT;
    }

    private static final long timeout_ns$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t timeout_ns
     * }
     */
    public static final long timeout_ns$offset() {
        return timeout_ns$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t timeout_ns
     * }
     */
    public static long timeout_ns(MemorySegment struct) {
        return struct.get(timeout_ns$LAYOUT, timeout_ns$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t timeout_ns
     * }
     */
    public static void timeout_ns(MemorySegment struct, long fieldValue) {
        struct.set(timeout_ns$LAYOUT, timeout_ns$OFFSET, fieldValue);
    }

    private static final OfLong invocation_time$LAYOUT = (OfLong)$LAYOUT.select(groupElement("invocation_time"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rcutils_time_point_value_t invocation_time
     * }
     */
    public static final OfLong invocation_time$layout() {
        return invocation_time$LAYOUT;
    }

    private static final long invocation_time$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rcutils_time_point_value_t invocation_time
     * }
     */
    public static final long invocation_time$offset() {
        return invocation_time$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rcutils_time_point_value_t invocation_time
     * }
     */
    public static long invocation_time(MemorySegment struct) {
        return struct.get(invocation_time$LAYOUT, invocation_time$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rcutils_time_point_value_t invocation_time
     * }
     */
    public static void invocation_time(MemorySegment struct, long fieldValue) {
        struct.set(invocation_time$LAYOUT, invocation_time$OFFSET, fieldValue);
    }

    private static final AddressLayout trigger_function$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("trigger_function"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_executor_trigger_t trigger_function
     * }
     */
    public static final AddressLayout trigger_function$layout() {
        return trigger_function$LAYOUT;
    }

    private static final long trigger_function$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_executor_trigger_t trigger_function
     * }
     */
    public static final long trigger_function$offset() {
        return trigger_function$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_executor_trigger_t trigger_function
     * }
     */
    public static MemorySegment trigger_function(MemorySegment struct) {
        return struct.get(trigger_function$LAYOUT, trigger_function$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_executor_trigger_t trigger_function
     * }
     */
    public static void trigger_function(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(trigger_function$LAYOUT, trigger_function$OFFSET, fieldValue);
    }

    private static final AddressLayout trigger_object$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("trigger_object"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *trigger_object
     * }
     */
    public static final AddressLayout trigger_object$layout() {
        return trigger_object$LAYOUT;
    }

    private static final long trigger_object$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *trigger_object
     * }
     */
    public static final long trigger_object$offset() {
        return trigger_object$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *trigger_object
     * }
     */
    public static MemorySegment trigger_object(MemorySegment struct) {
        return struct.get(trigger_object$LAYOUT, trigger_object$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *trigger_object
     * }
     */
    public static void trigger_object(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(trigger_object$LAYOUT, trigger_object$OFFSET, fieldValue);
    }

    private static final OfInt data_comm_semantics$LAYOUT = (OfInt)$LAYOUT.select(groupElement("data_comm_semantics"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * rclc_executor_semantics_t data_comm_semantics
     * }
     */
    public static final OfInt data_comm_semantics$layout() {
        return data_comm_semantics$LAYOUT;
    }

    private static final long data_comm_semantics$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * rclc_executor_semantics_t data_comm_semantics
     * }
     */
    public static final long data_comm_semantics$offset() {
        return data_comm_semantics$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * rclc_executor_semantics_t data_comm_semantics
     * }
     */
    public static int data_comm_semantics(MemorySegment struct) {
        return struct.get(data_comm_semantics$LAYOUT, data_comm_semantics$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * rclc_executor_semantics_t data_comm_semantics
     * }
     */
    public static void data_comm_semantics(MemorySegment struct, int fieldValue) {
        struct.set(data_comm_semantics$LAYOUT, data_comm_semantics$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

