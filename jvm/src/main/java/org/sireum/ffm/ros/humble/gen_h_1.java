// Generated by jextract

package org.sireum.ffm.ros.humble;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class gen_h_1 {

    gen_h_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int true_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define true 1
     * }
     */
    public static int true_() {
        return true_;
    }
    private static final int false_ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define false 0
     * }
     */
    public static int false_() {
        return false_;
    }
    private static final int __bool_true_false_are_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __bool_true_false_are_defined 1
     * }
     */
    public static int __bool_true_false_are_defined() {
        return __bool_true_false_are_defined;
    }
    private static final int RCUTILS_RET_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_OK 0
     * }
     */
    public static int RCUTILS_RET_OK() {
        return RCUTILS_RET_OK;
    }
    private static final int RCUTILS_RET_WARN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_WARN 1
     * }
     */
    public static int RCUTILS_RET_WARN() {
        return RCUTILS_RET_WARN;
    }
    private static final int RCUTILS_RET_ERROR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_ERROR 2
     * }
     */
    public static int RCUTILS_RET_ERROR() {
        return RCUTILS_RET_ERROR;
    }
    private static final int RCUTILS_RET_BAD_ALLOC = (int)10L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_BAD_ALLOC 10
     * }
     */
    public static int RCUTILS_RET_BAD_ALLOC() {
        return RCUTILS_RET_BAD_ALLOC;
    }
    private static final int RCUTILS_RET_INVALID_ARGUMENT = (int)11L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_INVALID_ARGUMENT 11
     * }
     */
    public static int RCUTILS_RET_INVALID_ARGUMENT() {
        return RCUTILS_RET_INVALID_ARGUMENT;
    }
    private static final int RCUTILS_RET_NOT_ENOUGH_SPACE = (int)12L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_NOT_ENOUGH_SPACE 12
     * }
     */
    public static int RCUTILS_RET_NOT_ENOUGH_SPACE() {
        return RCUTILS_RET_NOT_ENOUGH_SPACE;
    }
    private static final int RCUTILS_RET_NOT_INITIALIZED = (int)13L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_NOT_INITIALIZED 13
     * }
     */
    public static int RCUTILS_RET_NOT_INITIALIZED() {
        return RCUTILS_RET_NOT_INITIALIZED;
    }
    private static final int RCUTILS_RET_NOT_FOUND = (int)14L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_NOT_FOUND 14
     * }
     */
    public static int RCUTILS_RET_NOT_FOUND() {
        return RCUTILS_RET_NOT_FOUND;
    }
    private static final int RCUTILS_RET_STRING_MAP_ALREADY_INIT = (int)30L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_STRING_MAP_ALREADY_INIT 30
     * }
     */
    public static int RCUTILS_RET_STRING_MAP_ALREADY_INIT() {
        return RCUTILS_RET_STRING_MAP_ALREADY_INIT;
    }
    private static final int RCUTILS_RET_STRING_MAP_INVALID = (int)31L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_STRING_MAP_INVALID 31
     * }
     */
    public static int RCUTILS_RET_STRING_MAP_INVALID() {
        return RCUTILS_RET_STRING_MAP_INVALID;
    }
    private static final int RCUTILS_RET_STRING_KEY_NOT_FOUND = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_STRING_KEY_NOT_FOUND 32
     * }
     */
    public static int RCUTILS_RET_STRING_KEY_NOT_FOUND() {
        return RCUTILS_RET_STRING_KEY_NOT_FOUND;
    }
    private static final int RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID = (int)40L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID 40
     * }
     */
    public static int RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID() {
        return RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID;
    }
    private static final int RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID = (int)41L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID 41
     * }
     */
    public static int RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID() {
        return RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID;
    }
    private static final int RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES = (int)50L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES 50
     * }
     */
    public static int RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES() {
        return RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES;
    }
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 0
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)35L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 35
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int RMW_RET_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RMW_RET_OK 0
     * }
     */
    public static int RMW_RET_OK() {
        return RMW_RET_OK;
    }
    private static final int RMW_RET_ERROR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RMW_RET_ERROR 1
     * }
     */
    public static int RMW_RET_ERROR() {
        return RMW_RET_ERROR;
    }
    private static final int RMW_RET_TIMEOUT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RMW_RET_TIMEOUT 2
     * }
     */
    public static int RMW_RET_TIMEOUT() {
        return RMW_RET_TIMEOUT;
    }
    private static final int RMW_RET_UNSUPPORTED = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RMW_RET_UNSUPPORTED 3
     * }
     */
    public static int RMW_RET_UNSUPPORTED() {
        return RMW_RET_UNSUPPORTED;
    }
    private static final int RMW_RET_BAD_ALLOC = (int)10L;
    /**
     * {@snippet lang=c :
     * #define RMW_RET_BAD_ALLOC 10
     * }
     */
    public static int RMW_RET_BAD_ALLOC() {
        return RMW_RET_BAD_ALLOC;
    }
    private static final int RMW_RET_INVALID_ARGUMENT = (int)11L;
    /**
     * {@snippet lang=c :
     * #define RMW_RET_INVALID_ARGUMENT 11
     * }
     */
    public static int RMW_RET_INVALID_ARGUMENT() {
        return RMW_RET_INVALID_ARGUMENT;
    }
    private static final int RMW_RET_INCORRECT_RMW_IMPLEMENTATION = (int)12L;
    /**
     * {@snippet lang=c :
     * #define RMW_RET_INCORRECT_RMW_IMPLEMENTATION 12
     * }
     */
    public static int RMW_RET_INCORRECT_RMW_IMPLEMENTATION() {
        return RMW_RET_INCORRECT_RMW_IMPLEMENTATION;
    }
    private static final int RMW_RET_NODE_NAME_NON_EXISTENT = (int)203L;
    /**
     * {@snippet lang=c :
     * #define RMW_RET_NODE_NAME_NON_EXISTENT 203
     * }
     */
    public static int RMW_RET_NODE_NAME_NON_EXISTENT() {
        return RMW_RET_NODE_NAME_NON_EXISTENT;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int __HAVE_FLOAT128 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 1
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int __STDC_WANT_LIB_EXT1__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_LIB_EXT1__ 1
     * }
     */
    public static int __STDC_WANT_LIB_EXT1__() {
        return __STDC_WANT_LIB_EXT1__;
    }
    private static final int _ASSERT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ASSERT_H 1
     * }
     */
    public static int _ASSERT_H() {
        return _ASSERT_H;
    }
    private static final int _STDLIB_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDLIB_H 1
     * }
     */
    public static int _STDLIB_H() {
        return _STDLIB_H;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WSTOPPED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 2
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WCONTINUED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 8
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 16777216
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int __WNOTHREAD = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define __WNOTHREAD 536870912
     * }
     */
    public static int __WNOTHREAD() {
        return __WNOTHREAD;
    }
    private static final int __WALL = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define __WALL 1073741824
     * }
     */
    public static int __WALL() {
        return __WALL;
    }
    private static final int __W_CONTINUED = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define __W_CONTINUED 65535
     * }
     */
    public static int __W_CONTINUED() {
        return __W_CONTINUED;
    }
    private static final int __WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __WCOREFLAG 128
     * }
     */
    public static int __WCOREFLAG() {
        return __WCOREFLAG;
    }
    private static final int __ldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ldiv_t_defined 1
     * }
     */
    public static int __ldiv_t_defined() {
        return __ldiv_t_defined;
    }
    private static final int __lldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __lldiv_t_defined 1
     * }
     */
    public static int __lldiv_t_defined() {
        return __lldiv_t_defined;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 64
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _ALLOCA_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_H 1
     * }
     */
    public static int _ALLOCA_H() {
        return _ALLOCA_H;
    }
    private static final int _STRING_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRING_H 1
     * }
     */
    public static int _STRING_H() {
        return _STRING_H;
    }
    private static final int _BITS_TYPES_LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES_LOCALE_T_H() {
        return _BITS_TYPES_LOCALE_T_H;
    }
    private static final int _BITS_TYPES___LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES___LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES___LOCALE_T_H() {
        return _BITS_TYPES___LOCALE_T_H;
    }
    private static final int _STRINGS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRINGS_H 1
     * }
     */
    public static int _STRINGS_H() {
        return _STRINGS_H;
    }
    private static final int RCUTILS_FAULT_INJECTION_FAIL_NOW = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_FAULT_INJECTION_FAIL_NOW 0
     * }
     */
    public static int RCUTILS_FAULT_INJECTION_FAIL_NOW() {
        return RCUTILS_FAULT_INJECTION_FAIL_NOW;
    }
    private static final int RCUTILS_ERROR_STATE_LINE_NUMBER_STR_MAX_LENGTH = (int)20L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_ERROR_STATE_LINE_NUMBER_STR_MAX_LENGTH 20
     * }
     */
    public static int RCUTILS_ERROR_STATE_LINE_NUMBER_STR_MAX_LENGTH() {
        return RCUTILS_ERROR_STATE_LINE_NUMBER_STR_MAX_LENGTH;
    }
    private static final int RCUTILS_ERROR_FORMATTING_CHARACTERS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_ERROR_FORMATTING_CHARACTERS 6
     * }
     */
    public static int RCUTILS_ERROR_FORMATTING_CHARACTERS() {
        return RCUTILS_ERROR_FORMATTING_CHARACTERS;
    }
    private static final int RCUTILS_ERROR_MESSAGE_MAX_LENGTH = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_ERROR_MESSAGE_MAX_LENGTH 1024
     * }
     */
    public static int RCUTILS_ERROR_MESSAGE_MAX_LENGTH() {
        return RCUTILS_ERROR_MESSAGE_MAX_LENGTH;
    }
    private static final int RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH = (int)768L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH 768
     * }
     */
    public static int RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH() {
        return RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH;
    }
    private static final int RCL_RET_ALREADY_INIT = (int)100L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_ALREADY_INIT 100
     * }
     */
    public static int RCL_RET_ALREADY_INIT() {
        return RCL_RET_ALREADY_INIT;
    }
    private static final int RCL_RET_NOT_INIT = (int)101L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_NOT_INIT 101
     * }
     */
    public static int RCL_RET_NOT_INIT() {
        return RCL_RET_NOT_INIT;
    }
    private static final int RCL_RET_MISMATCHED_RMW_ID = (int)102L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_MISMATCHED_RMW_ID 102
     * }
     */
    public static int RCL_RET_MISMATCHED_RMW_ID() {
        return RCL_RET_MISMATCHED_RMW_ID;
    }
    private static final int RCL_RET_TOPIC_NAME_INVALID = (int)103L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_TOPIC_NAME_INVALID 103
     * }
     */
    public static int RCL_RET_TOPIC_NAME_INVALID() {
        return RCL_RET_TOPIC_NAME_INVALID;
    }
    private static final int RCL_RET_SERVICE_NAME_INVALID = (int)104L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_SERVICE_NAME_INVALID 104
     * }
     */
    public static int RCL_RET_SERVICE_NAME_INVALID() {
        return RCL_RET_SERVICE_NAME_INVALID;
    }
    private static final int RCL_RET_UNKNOWN_SUBSTITUTION = (int)105L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_UNKNOWN_SUBSTITUTION 105
     * }
     */
    public static int RCL_RET_UNKNOWN_SUBSTITUTION() {
        return RCL_RET_UNKNOWN_SUBSTITUTION;
    }
    private static final int RCL_RET_ALREADY_SHUTDOWN = (int)106L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_ALREADY_SHUTDOWN 106
     * }
     */
    public static int RCL_RET_ALREADY_SHUTDOWN() {
        return RCL_RET_ALREADY_SHUTDOWN;
    }
    private static final int RCL_RET_NODE_INVALID = (int)200L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_NODE_INVALID 200
     * }
     */
    public static int RCL_RET_NODE_INVALID() {
        return RCL_RET_NODE_INVALID;
    }
    private static final int RCL_RET_NODE_INVALID_NAME = (int)201L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_NODE_INVALID_NAME 201
     * }
     */
    public static int RCL_RET_NODE_INVALID_NAME() {
        return RCL_RET_NODE_INVALID_NAME;
    }
    private static final int RCL_RET_NODE_INVALID_NAMESPACE = (int)202L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_NODE_INVALID_NAMESPACE 202
     * }
     */
    public static int RCL_RET_NODE_INVALID_NAMESPACE() {
        return RCL_RET_NODE_INVALID_NAMESPACE;
    }
    private static final int RCL_RET_NODE_NAME_NON_EXISTENT = (int)203L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_NODE_NAME_NON_EXISTENT 203
     * }
     */
    public static int RCL_RET_NODE_NAME_NON_EXISTENT() {
        return RCL_RET_NODE_NAME_NON_EXISTENT;
    }
    private static final int RCL_RET_PUBLISHER_INVALID = (int)300L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_PUBLISHER_INVALID 300
     * }
     */
    public static int RCL_RET_PUBLISHER_INVALID() {
        return RCL_RET_PUBLISHER_INVALID;
    }
    private static final int RCL_RET_SUBSCRIPTION_INVALID = (int)400L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_SUBSCRIPTION_INVALID 400
     * }
     */
    public static int RCL_RET_SUBSCRIPTION_INVALID() {
        return RCL_RET_SUBSCRIPTION_INVALID;
    }
    private static final int RCL_RET_SUBSCRIPTION_TAKE_FAILED = (int)401L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_SUBSCRIPTION_TAKE_FAILED 401
     * }
     */
    public static int RCL_RET_SUBSCRIPTION_TAKE_FAILED() {
        return RCL_RET_SUBSCRIPTION_TAKE_FAILED;
    }
    private static final int RCL_RET_CLIENT_INVALID = (int)500L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_CLIENT_INVALID 500
     * }
     */
    public static int RCL_RET_CLIENT_INVALID() {
        return RCL_RET_CLIENT_INVALID;
    }
    private static final int RCL_RET_CLIENT_TAKE_FAILED = (int)501L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_CLIENT_TAKE_FAILED 501
     * }
     */
    public static int RCL_RET_CLIENT_TAKE_FAILED() {
        return RCL_RET_CLIENT_TAKE_FAILED;
    }
    private static final int RCL_RET_SERVICE_INVALID = (int)600L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_SERVICE_INVALID 600
     * }
     */
    public static int RCL_RET_SERVICE_INVALID() {
        return RCL_RET_SERVICE_INVALID;
    }
    private static final int RCL_RET_SERVICE_TAKE_FAILED = (int)601L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_SERVICE_TAKE_FAILED 601
     * }
     */
    public static int RCL_RET_SERVICE_TAKE_FAILED() {
        return RCL_RET_SERVICE_TAKE_FAILED;
    }
    private static final int RCL_RET_TIMER_INVALID = (int)800L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_TIMER_INVALID 800
     * }
     */
    public static int RCL_RET_TIMER_INVALID() {
        return RCL_RET_TIMER_INVALID;
    }
    private static final int RCL_RET_TIMER_CANCELED = (int)801L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_TIMER_CANCELED 801
     * }
     */
    public static int RCL_RET_TIMER_CANCELED() {
        return RCL_RET_TIMER_CANCELED;
    }
    private static final int RCL_RET_WAIT_SET_INVALID = (int)900L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_WAIT_SET_INVALID 900
     * }
     */
    public static int RCL_RET_WAIT_SET_INVALID() {
        return RCL_RET_WAIT_SET_INVALID;
    }
    private static final int RCL_RET_WAIT_SET_EMPTY = (int)901L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_WAIT_SET_EMPTY 901
     * }
     */
    public static int RCL_RET_WAIT_SET_EMPTY() {
        return RCL_RET_WAIT_SET_EMPTY;
    }
    private static final int RCL_RET_WAIT_SET_FULL = (int)902L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_WAIT_SET_FULL 902
     * }
     */
    public static int RCL_RET_WAIT_SET_FULL() {
        return RCL_RET_WAIT_SET_FULL;
    }
    private static final int RCL_RET_INVALID_REMAP_RULE = (int)1001L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_INVALID_REMAP_RULE 1001
     * }
     */
    public static int RCL_RET_INVALID_REMAP_RULE() {
        return RCL_RET_INVALID_REMAP_RULE;
    }
    private static final int RCL_RET_WRONG_LEXEME = (int)1002L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_WRONG_LEXEME 1002
     * }
     */
    public static int RCL_RET_WRONG_LEXEME() {
        return RCL_RET_WRONG_LEXEME;
    }
    private static final int RCL_RET_INVALID_ROS_ARGS = (int)1003L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_INVALID_ROS_ARGS 1003
     * }
     */
    public static int RCL_RET_INVALID_ROS_ARGS() {
        return RCL_RET_INVALID_ROS_ARGS;
    }
    private static final int RCL_RET_INVALID_PARAM_RULE = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_INVALID_PARAM_RULE 1010
     * }
     */
    public static int RCL_RET_INVALID_PARAM_RULE() {
        return RCL_RET_INVALID_PARAM_RULE;
    }
    private static final int RCL_RET_INVALID_LOG_LEVEL_RULE = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_INVALID_LOG_LEVEL_RULE 1020
     * }
     */
    public static int RCL_RET_INVALID_LOG_LEVEL_RULE() {
        return RCL_RET_INVALID_LOG_LEVEL_RULE;
    }
    private static final int RCL_RET_EVENT_INVALID = (int)2000L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_EVENT_INVALID 2000
     * }
     */
    public static int RCL_RET_EVENT_INVALID() {
        return RCL_RET_EVENT_INVALID;
    }
    private static final int RCL_RET_EVENT_TAKE_FAILED = (int)2001L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_EVENT_TAKE_FAILED 2001
     * }
     */
    public static int RCL_RET_EVENT_TAKE_FAILED() {
        return RCL_RET_EVENT_TAKE_FAILED;
    }
    private static final int RCL_RET_LIFECYCLE_STATE_REGISTERED = (int)3000L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_LIFECYCLE_STATE_REGISTERED 3000
     * }
     */
    public static int RCL_RET_LIFECYCLE_STATE_REGISTERED() {
        return RCL_RET_LIFECYCLE_STATE_REGISTERED;
    }
    private static final int RCL_RET_LIFECYCLE_STATE_NOT_REGISTERED = (int)3001L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_LIFECYCLE_STATE_NOT_REGISTERED 3001
     * }
     */
    public static int RCL_RET_LIFECYCLE_STATE_NOT_REGISTERED() {
        return RCL_RET_LIFECYCLE_STATE_NOT_REGISTERED;
    }
    private static final int __alignas_is_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __alignas_is_defined 1
     * }
     */
    public static int __alignas_is_defined() {
        return __alignas_is_defined;
    }
    private static final int __alignof_is_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __alignof_is_defined 1
     * }
     */
    public static int __alignof_is_defined() {
        return __alignof_is_defined;
    }
    private static final int RCL_RET_ACTION_NAME_INVALID = (int)2000L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_ACTION_NAME_INVALID 2000
     * }
     */
    public static int RCL_RET_ACTION_NAME_INVALID() {
        return RCL_RET_ACTION_NAME_INVALID;
    }
    private static final int RCL_RET_ACTION_GOAL_ACCEPTED = (int)2100L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_ACTION_GOAL_ACCEPTED 2100
     * }
     */
    public static int RCL_RET_ACTION_GOAL_ACCEPTED() {
        return RCL_RET_ACTION_GOAL_ACCEPTED;
    }
    private static final int RCL_RET_ACTION_GOAL_REJECTED = (int)2101L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_ACTION_GOAL_REJECTED 2101
     * }
     */
    public static int RCL_RET_ACTION_GOAL_REJECTED() {
        return RCL_RET_ACTION_GOAL_REJECTED;
    }
    private static final int RCL_RET_ACTION_CLIENT_INVALID = (int)2102L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_ACTION_CLIENT_INVALID 2102
     * }
     */
    public static int RCL_RET_ACTION_CLIENT_INVALID() {
        return RCL_RET_ACTION_CLIENT_INVALID;
    }
    private static final int RCL_RET_ACTION_CLIENT_TAKE_FAILED = (int)2103L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_ACTION_CLIENT_TAKE_FAILED 2103
     * }
     */
    public static int RCL_RET_ACTION_CLIENT_TAKE_FAILED() {
        return RCL_RET_ACTION_CLIENT_TAKE_FAILED;
    }
    private static final int RCL_RET_ACTION_SERVER_INVALID = (int)2200L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_ACTION_SERVER_INVALID 2200
     * }
     */
    public static int RCL_RET_ACTION_SERVER_INVALID() {
        return RCL_RET_ACTION_SERVER_INVALID;
    }
    private static final int RCL_RET_ACTION_SERVER_TAKE_FAILED = (int)2201L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_ACTION_SERVER_TAKE_FAILED 2201
     * }
     */
    public static int RCL_RET_ACTION_SERVER_TAKE_FAILED() {
        return RCL_RET_ACTION_SERVER_TAKE_FAILED;
    }
    private static final int RCL_RET_ACTION_GOAL_HANDLE_INVALID = (int)2300L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_ACTION_GOAL_HANDLE_INVALID 2300
     * }
     */
    public static int RCL_RET_ACTION_GOAL_HANDLE_INVALID() {
        return RCL_RET_ACTION_GOAL_HANDLE_INVALID;
    }
    private static final int RCL_RET_ACTION_GOAL_EVENT_INVALID = (int)2301L;
    /**
     * {@snippet lang=c :
     * #define RCL_RET_ACTION_GOAL_EVENT_INVALID 2301
     * }
     */
    public static int RCL_RET_ACTION_GOAL_EVENT_INVALID() {
        return RCL_RET_ACTION_GOAL_EVENT_INVALID;
    }
    private static final int UUID_SIZE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define UUID_SIZE 16
     * }
     */
    public static int UUID_SIZE() {
        return UUID_SIZE;
    }
    private static final int GOAL_STATE_NUM_STATES = (int)7L;
    /**
     * {@snippet lang=c :
     * #define GOAL_STATE_NUM_STATES 7
     * }
     */
    public static int GOAL_STATE_NUM_STATES() {
        return GOAL_STATE_NUM_STATES;
    }
    private static final int RCLC_RET_ACTION_WAIT_RESULT_REQUEST = (int)2104L;
    /**
     * {@snippet lang=c :
     * #define RCLC_RET_ACTION_WAIT_RESULT_REQUEST 2104
     * }
     */
    public static int RCLC_RET_ACTION_WAIT_RESULT_REQUEST() {
        return RCLC_RET_ACTION_WAIT_RESULT_REQUEST;
    }
    private static final int RCUTILS_LOG_MIN_SEVERITY_DEBUG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_LOG_MIN_SEVERITY_DEBUG 0
     * }
     */
    public static int RCUTILS_LOG_MIN_SEVERITY_DEBUG() {
        return RCUTILS_LOG_MIN_SEVERITY_DEBUG;
    }
    private static final int RCUTILS_LOG_MIN_SEVERITY_INFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_LOG_MIN_SEVERITY_INFO 1
     * }
     */
    public static int RCUTILS_LOG_MIN_SEVERITY_INFO() {
        return RCUTILS_LOG_MIN_SEVERITY_INFO;
    }
    private static final int RCUTILS_LOG_MIN_SEVERITY_WARN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_LOG_MIN_SEVERITY_WARN 2
     * }
     */
    public static int RCUTILS_LOG_MIN_SEVERITY_WARN() {
        return RCUTILS_LOG_MIN_SEVERITY_WARN;
    }
    private static final int RCUTILS_LOG_MIN_SEVERITY_ERROR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_LOG_MIN_SEVERITY_ERROR 3
     * }
     */
    public static int RCUTILS_LOG_MIN_SEVERITY_ERROR() {
        return RCUTILS_LOG_MIN_SEVERITY_ERROR;
    }
    private static final int RCUTILS_LOG_MIN_SEVERITY_FATAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_LOG_MIN_SEVERITY_FATAL 4
     * }
     */
    public static int RCUTILS_LOG_MIN_SEVERITY_FATAL() {
        return RCUTILS_LOG_MIN_SEVERITY_FATAL;
    }
    private static final int RCUTILS_LOG_MIN_SEVERITY_NONE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RCUTILS_LOG_MIN_SEVERITY_NONE 5
     * }
     */
    public static int RCUTILS_LOG_MIN_SEVERITY_NONE() {
        return RCUTILS_LOG_MIN_SEVERITY_NONE;
    }
    private static final int RCLC_EXECUTOR_PARAMETER_SERVER_HANDLES = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RCLC_EXECUTOR_PARAMETER_SERVER_HANDLES 5
     * }
     */
    public static int RCLC_EXECUTOR_PARAMETER_SERVER_HANDLES() {
        return RCLC_EXECUTOR_PARAMETER_SERVER_HANDLES;
    }
    private static final int RCLC_PARAMETER_MODIFICATION_REJECTED = (int)4001L;
    /**
     * {@snippet lang=c :
     * #define RCLC_PARAMETER_MODIFICATION_REJECTED 4001
     * }
     */
    public static int RCLC_PARAMETER_MODIFICATION_REJECTED() {
        return RCLC_PARAMETER_MODIFICATION_REJECTED;
    }
    private static final int RCLC_PARAMETER_TYPE_MISMATCH = (int)4002L;
    /**
     * {@snippet lang=c :
     * #define RCLC_PARAMETER_TYPE_MISMATCH 4002
     * }
     */
    public static int RCLC_PARAMETER_TYPE_MISMATCH() {
        return RCLC_PARAMETER_TYPE_MISMATCH;
    }
    private static final int RCLC_PARAMETER_UNSUPORTED_ON_LOW_MEM = (int)4003L;
    /**
     * {@snippet lang=c :
     * #define RCLC_PARAMETER_UNSUPORTED_ON_LOW_MEM 4003
     * }
     */
    public static int RCLC_PARAMETER_UNSUPORTED_ON_LOW_MEM() {
        return RCLC_PARAMETER_UNSUPORTED_ON_LOW_MEM;
    }
    private static final int RCLC_PARAMETER_DISABLED_ON_CALLBACK = (int)40004L;
    /**
     * {@snippet lang=c :
     * #define RCLC_PARAMETER_DISABLED_ON_CALLBACK 40004
     * }
     */
    public static int RCLC_PARAMETER_DISABLED_ON_CALLBACK() {
        return RCLC_PARAMETER_DISABLED_ON_CALLBACK;
    }
    private static final int RCLC_LIFECYCLE_MAX_NUMBER_OF_STATES = (int)100L;
    /**
     * {@snippet lang=c :
     * #define RCLC_LIFECYCLE_MAX_NUMBER_OF_STATES 100
     * }
     */
    public static int RCLC_LIFECYCLE_MAX_NUMBER_OF_STATES() {
        return RCLC_LIFECYCLE_MAX_NUMBER_OF_STATES;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int wchar_t
     * }
     */
    public static final OfInt wchar_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int rcutils_ret_t
     * }
     */
    public static final OfInt rcutils_ret_t = gen_h.C_INT;

    private static class rcutils_get_zero_initialized_allocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcutils_allocator_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_get_zero_initialized_allocator"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_allocator_t rcutils_get_zero_initialized_allocator()
     * }
     */
    public static FunctionDescriptor rcutils_get_zero_initialized_allocator$descriptor() {
        return rcutils_get_zero_initialized_allocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_allocator_t rcutils_get_zero_initialized_allocator()
     * }
     */
    public static MethodHandle rcutils_get_zero_initialized_allocator$handle() {
        return rcutils_get_zero_initialized_allocator.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_allocator_t rcutils_get_zero_initialized_allocator()
     * }
     */
    public static MemorySegment rcutils_get_zero_initialized_allocator(SegmentAllocator allocator) {
        var mh$ = rcutils_get_zero_initialized_allocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_get_zero_initialized_allocator", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_get_default_allocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcutils_allocator_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_get_default_allocator"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_allocator_t rcutils_get_default_allocator()
     * }
     */
    public static FunctionDescriptor rcutils_get_default_allocator$descriptor() {
        return rcutils_get_default_allocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_allocator_t rcutils_get_default_allocator()
     * }
     */
    public static MethodHandle rcutils_get_default_allocator$handle() {
        return rcutils_get_default_allocator.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_allocator_t rcutils_get_default_allocator()
     * }
     */
    public static MemorySegment rcutils_get_default_allocator(SegmentAllocator allocator) {
        var mh$ = rcutils_get_default_allocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_get_default_allocator", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_allocator_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_allocator_is_valid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcutils_allocator_is_valid(const rcutils_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rcutils_allocator_is_valid$descriptor() {
        return rcutils_allocator_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcutils_allocator_is_valid(const rcutils_allocator_t *allocator)
     * }
     */
    public static MethodHandle rcutils_allocator_is_valid$handle() {
        return rcutils_allocator_is_valid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcutils_allocator_is_valid(const rcutils_allocator_t *allocator)
     * }
     */
    public static boolean rcutils_allocator_is_valid(MemorySegment allocator) {
        var mh$ = rcutils_allocator_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_allocator_is_valid", allocator);
            }
            return (boolean)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_reallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_reallocf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *rcutils_reallocf(void *pointer, size_t size, rcutils_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rcutils_reallocf$descriptor() {
        return rcutils_reallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *rcutils_reallocf(void *pointer, size_t size, rcutils_allocator_t *allocator)
     * }
     */
    public static MethodHandle rcutils_reallocf$handle() {
        return rcutils_reallocf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *rcutils_reallocf(void *pointer, size_t size, rcutils_allocator_t *allocator)
     * }
     */
    public static MemorySegment rcutils_reallocf(MemorySegment pointer, long size, MemorySegment allocator) {
        var mh$ = rcutils_reallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_reallocf", pointer, size, allocator);
            }
            return (MemorySegment)mh$.invokeExact(pointer, size, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __nlink_t
     * }
     */
    public static final OfInt __nlink_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = gen_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __blksize_t
     * }
     */
    public static final OfInt __blksize_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = gen_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = gen_h.C_LONG;
    private static final int RMW_LOCALHOST_ONLY_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rmw_localhost_only_e.RMW_LOCALHOST_ONLY_DEFAULT = 0
     * }
     */
    public static int RMW_LOCALHOST_ONLY_DEFAULT() {
        return RMW_LOCALHOST_ONLY_DEFAULT;
    }
    private static final int RMW_LOCALHOST_ONLY_ENABLED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rmw_localhost_only_e.RMW_LOCALHOST_ONLY_ENABLED = 1
     * }
     */
    public static int RMW_LOCALHOST_ONLY_ENABLED() {
        return RMW_LOCALHOST_ONLY_ENABLED;
    }
    private static final int RMW_LOCALHOST_ONLY_DISABLED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rmw_localhost_only_e.RMW_LOCALHOST_ONLY_DISABLED = 2
     * }
     */
    public static int RMW_LOCALHOST_ONLY_DISABLED() {
        return RMW_LOCALHOST_ONLY_DISABLED;
    }
    /**
     * {@snippet lang=c :
     * typedef int32_t rmw_ret_t
     * }
     */
    public static final OfInt rmw_ret_t = gen_h.C_INT;
    private static final int RMW_SECURITY_ENFORCEMENT_PERMISSIVE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rmw_security_enforcement_policy_e.RMW_SECURITY_ENFORCEMENT_PERMISSIVE = 0
     * }
     */
    public static int RMW_SECURITY_ENFORCEMENT_PERMISSIVE() {
        return RMW_SECURITY_ENFORCEMENT_PERMISSIVE;
    }
    private static final int RMW_SECURITY_ENFORCEMENT_ENFORCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rmw_security_enforcement_policy_e.RMW_SECURITY_ENFORCEMENT_ENFORCE = 1
     * }
     */
    public static int RMW_SECURITY_ENFORCEMENT_ENFORCE() {
        return RMW_SECURITY_ENFORCEMENT_ENFORCE;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * rmw_security_options_t rmw_get_zero_initialized_security_options()
     * }
     */
    public static class rmw_get_zero_initialized_security_options {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                rmw_security_options_s.layout()        );
        private static final MemorySegment ADDR = gen_h.findOrThrow("rmw_get_zero_initialized_security_options");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private rmw_get_zero_initialized_security_options(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * rmw_security_options_t rmw_get_zero_initialized_security_options()
         * }
         */
        public static rmw_get_zero_initialized_security_options makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new rmw_get_zero_initialized_security_options(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("rmw_get_zero_initialized_security_options", allocator, x0);
                }
                return (MemorySegment)spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * rmw_security_options_t rmw_get_default_security_options()
     * }
     */
    public static class rmw_get_default_security_options {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                rmw_security_options_s.layout()        );
        private static final MemorySegment ADDR = gen_h.findOrThrow("rmw_get_default_security_options");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private rmw_get_default_security_options(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * rmw_security_options_t rmw_get_default_security_options()
         * }
         */
        public static rmw_get_default_security_options makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new rmw_get_default_security_options(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("rmw_get_default_security_options", allocator, x0);
                }
                return (MemorySegment)spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class rmw_security_options_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_security_options_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_security_options_copy(const rmw_security_options_t *src, const rcutils_allocator_t *allocator, rmw_security_options_t *dst)
     * }
     */
    public static FunctionDescriptor rmw_security_options_copy$descriptor() {
        return rmw_security_options_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_security_options_copy(const rmw_security_options_t *src, const rcutils_allocator_t *allocator, rmw_security_options_t *dst)
     * }
     */
    public static MethodHandle rmw_security_options_copy$handle() {
        return rmw_security_options_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_security_options_copy(const rmw_security_options_t *src, const rcutils_allocator_t *allocator, rmw_security_options_t *dst)
     * }
     */
    public static int rmw_security_options_copy(MemorySegment src, MemorySegment allocator, MemorySegment dst) {
        var mh$ = rmw_security_options_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_security_options_copy", src, allocator, dst);
            }
            return (int)mh$.invokeExact(src, allocator, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_security_options_set_root_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_security_options_set_root_path"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_security_options_set_root_path(const char *security_root_path, const rcutils_allocator_t *allocator, rmw_security_options_t *security_options)
     * }
     */
    public static FunctionDescriptor rmw_security_options_set_root_path$descriptor() {
        return rmw_security_options_set_root_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_security_options_set_root_path(const char *security_root_path, const rcutils_allocator_t *allocator, rmw_security_options_t *security_options)
     * }
     */
    public static MethodHandle rmw_security_options_set_root_path$handle() {
        return rmw_security_options_set_root_path.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_security_options_set_root_path(const char *security_root_path, const rcutils_allocator_t *allocator, rmw_security_options_t *security_options)
     * }
     */
    public static int rmw_security_options_set_root_path(MemorySegment security_root_path, MemorySegment allocator, MemorySegment security_options) {
        var mh$ = rmw_security_options_set_root_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_security_options_set_root_path", security_root_path, allocator, security_options);
            }
            return (int)mh$.invokeExact(security_root_path, allocator, security_options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_security_options_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_security_options_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_security_options_fini(rmw_security_options_t *security_options, const rcutils_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rmw_security_options_fini$descriptor() {
        return rmw_security_options_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_security_options_fini(rmw_security_options_t *security_options, const rcutils_allocator_t *allocator)
     * }
     */
    public static MethodHandle rmw_security_options_fini$handle() {
        return rmw_security_options_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_security_options_fini(rmw_security_options_t *security_options, const rcutils_allocator_t *allocator)
     * }
     */
    public static int rmw_security_options_fini(MemorySegment security_options, MemorySegment allocator) {
        var mh$ = rmw_security_options_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_security_options_fini", security_options, allocator);
            }
            return (int)mh$.invokeExact(security_options, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_get_zero_initialized_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rmw_init_options_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_get_zero_initialized_init_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_init_options_t rmw_get_zero_initialized_init_options()
     * }
     */
    public static FunctionDescriptor rmw_get_zero_initialized_init_options$descriptor() {
        return rmw_get_zero_initialized_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_init_options_t rmw_get_zero_initialized_init_options()
     * }
     */
    public static MethodHandle rmw_get_zero_initialized_init_options$handle() {
        return rmw_get_zero_initialized_init_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_init_options_t rmw_get_zero_initialized_init_options()
     * }
     */
    public static MemorySegment rmw_get_zero_initialized_init_options(SegmentAllocator allocator) {
        var mh$ = rmw_get_zero_initialized_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_get_zero_initialized_init_options", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_init_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            rcutils_allocator_s.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_init_options_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_options_init(rmw_init_options_t *init_options, rcutils_allocator_t allocator)
     * }
     */
    public static FunctionDescriptor rmw_init_options_init$descriptor() {
        return rmw_init_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_options_init(rmw_init_options_t *init_options, rcutils_allocator_t allocator)
     * }
     */
    public static MethodHandle rmw_init_options_init$handle() {
        return rmw_init_options_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_options_init(rmw_init_options_t *init_options, rcutils_allocator_t allocator)
     * }
     */
    public static int rmw_init_options_init(MemorySegment init_options, MemorySegment allocator) {
        var mh$ = rmw_init_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_init_options_init", init_options, allocator);
            }
            return (int)mh$.invokeExact(init_options, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_init_options_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_init_options_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_options_copy(const rmw_init_options_t *src, rmw_init_options_t *dst)
     * }
     */
    public static FunctionDescriptor rmw_init_options_copy$descriptor() {
        return rmw_init_options_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_options_copy(const rmw_init_options_t *src, rmw_init_options_t *dst)
     * }
     */
    public static MethodHandle rmw_init_options_copy$handle() {
        return rmw_init_options_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_options_copy(const rmw_init_options_t *src, rmw_init_options_t *dst)
     * }
     */
    public static int rmw_init_options_copy(MemorySegment src, MemorySegment dst) {
        var mh$ = rmw_init_options_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_init_options_copy", src, dst);
            }
            return (int)mh$.invokeExact(src, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_init_options_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_init_options_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_options_fini(rmw_init_options_t *init_options)
     * }
     */
    public static FunctionDescriptor rmw_init_options_fini$descriptor() {
        return rmw_init_options_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_options_fini(rmw_init_options_t *init_options)
     * }
     */
    public static MethodHandle rmw_init_options_fini$handle() {
        return rmw_init_options_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_options_fini(rmw_init_options_t *init_options)
     * }
     */
    public static int rmw_init_options_fini(MemorySegment init_options) {
        var mh$ = rmw_init_options_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_init_options_fini", init_options);
            }
            return (int)mh$.invokeExact(init_options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_get_zero_initialized_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rmw_context_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_get_zero_initialized_context"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_context_t rmw_get_zero_initialized_context()
     * }
     */
    public static FunctionDescriptor rmw_get_zero_initialized_context$descriptor() {
        return rmw_get_zero_initialized_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_context_t rmw_get_zero_initialized_context()
     * }
     */
    public static MethodHandle rmw_get_zero_initialized_context$handle() {
        return rmw_get_zero_initialized_context.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_context_t rmw_get_zero_initialized_context()
     * }
     */
    public static MemorySegment rmw_get_zero_initialized_context(SegmentAllocator allocator) {
        var mh$ = rmw_get_zero_initialized_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_get_zero_initialized_context", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_init(const rmw_init_options_t *options, rmw_context_t *context)
     * }
     */
    public static FunctionDescriptor rmw_init$descriptor() {
        return rmw_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_init(const rmw_init_options_t *options, rmw_context_t *context)
     * }
     */
    public static MethodHandle rmw_init$handle() {
        return rmw_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_init(const rmw_init_options_t *options, rmw_context_t *context)
     * }
     */
    public static int rmw_init(MemorySegment options, MemorySegment context) {
        var mh$ = rmw_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_init", options, context);
            }
            return (int)mh$.invokeExact(options, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_shutdown"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_shutdown(rmw_context_t *context)
     * }
     */
    public static FunctionDescriptor rmw_shutdown$descriptor() {
        return rmw_shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_shutdown(rmw_context_t *context)
     * }
     */
    public static MethodHandle rmw_shutdown$handle() {
        return rmw_shutdown.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_shutdown(rmw_context_t *context)
     * }
     */
    public static int rmw_shutdown(MemorySegment context) {
        var mh$ = rmw_shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_shutdown", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_context_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_context_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_context_fini(rmw_context_t *context)
     * }
     */
    public static FunctionDescriptor rmw_context_fini$descriptor() {
        return rmw_context_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_context_fini(rmw_context_t *context)
     * }
     */
    public static MethodHandle rmw_context_fini$handle() {
        return rmw_context_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_context_fini(rmw_context_t *context)
     * }
     */
    public static int rmw_context_fini(MemorySegment context) {
        var mh$ = rmw_context_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_context_fini", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = gen_h.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = gen_h.C_POINTER;
        public static final MemorySegment SEGMENT = gen_h.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = gen_h.C_POINTER;
        public static final MemorySegment SEGMENT = gen_h.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = gen_h.C_POINTER;
        public static final MemorySegment SEGMENT = gen_h.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("remove"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rename"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("renameat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fclose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("tmpfile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("tmpnam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("tmpnam_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("tempnam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fflush"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fflush_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("freopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fdopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fmemopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("open_memstream"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("setbuf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("setvbuf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("setbuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("setlinebuf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gen_h.C_INT,
                gen_h.C_POINTER,
                gen_h.C_POINTER
            );
        private static final MemorySegment ADDR = gen_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gen_h.C_INT,
                gen_h.C_POINTER
            );
        private static final MemorySegment ADDR = gen_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gen_h.C_INT,
                gen_h.C_POINTER,
                gen_h.C_POINTER
            );
        private static final MemorySegment ADDR = gen_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gen_h.C_INT,
                gen_h.C_POINTER,
                gen_h.C_LONG,
                gen_h.C_POINTER
            );
        private static final MemorySegment ADDR = gen_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int)spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gen_h.C_INT,
                gen_h.C_INT,
                gen_h.C_POINTER
            );
        private static final MemorySegment ADDR = gen_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int)spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gen_h.C_INT,
                gen_h.C_POINTER,
                gen_h.C_POINTER
            );
        private static final MemorySegment ADDR = gen_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gen_h.C_INT,
                gen_h.C_POINTER
            );
        private static final MemorySegment ADDR = gen_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gen_h.C_INT,
                gen_h.C_POINTER,
                gen_h.C_POINTER
            );
        private static final MemorySegment ADDR = gen_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = gen_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = gen_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = gen_h.C_DOUBLE;

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fgetc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("getc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("getchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("getc_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("getchar_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fgetc_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fputc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("putc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("putchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fputc_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("putc_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("putchar_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("getw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("putw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fgets"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("__getdelim"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("getdelim"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("getline"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fputs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("puts"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ungetc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fwrite"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fread_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fwrite_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fseek"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ftell"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rewind"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fseeko"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ftello"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fgetpos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fsetpos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("clearerr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("feof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ferror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("clearerr_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("feof_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ferror_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("perror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fileno"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fileno_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("pclose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("popen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ctermid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("flockfile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ftrylockfile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("funlockfile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("__uflow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("__overflow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __assert_fail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("__assert_fail"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static FunctionDescriptor __assert_fail$descriptor() {
        return __assert_fail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static MethodHandle __assert_fail$handle() {
        return __assert_fail.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static void __assert_fail(MemorySegment __assertion, MemorySegment __file, int __line, MemorySegment __function) {
        var mh$ = __assert_fail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert_fail", __assertion, __file, __line, __function);
            }
            mh$.invokeExact(__assertion, __file, __line, __function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __assert_perror_fail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("__assert_perror_fail"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static FunctionDescriptor __assert_perror_fail$descriptor() {
        return __assert_perror_fail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static MethodHandle __assert_perror_fail$handle() {
        return __assert_perror_fail.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static void __assert_perror_fail(int __errnum, MemorySegment __file, int __line, MemorySegment __function) {
        var mh$ = __assert_perror_fail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert_perror_fail", __errnum, __file, __line, __function);
            }
            mh$.invokeExact(__errnum, __file, __line, __function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __assert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("__assert"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __assert(const char *__assertion, const char *__file, int __line)
     * }
     */
    public static FunctionDescriptor __assert$descriptor() {
        return __assert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __assert(const char *__assertion, const char *__file, int __line)
     * }
     */
    public static MethodHandle __assert$handle() {
        return __assert.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void __assert(const char *__assertion, const char *__file, int __line)
     * }
     */
    public static void __assert(MemorySegment __assertion, MemorySegment __file, int __line) {
        var mh$ = __assert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert", __assertion, __file, __line);
            }
            mh$.invokeExact(__assertion, __file, __line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctype_get_mb_cur_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("__ctype_get_mb_cur_max"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static FunctionDescriptor __ctype_get_mb_cur_max$descriptor() {
        return __ctype_get_mb_cur_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MethodHandle __ctype_get_mb_cur_max$handle() {
        return __ctype_get_mb_cur_max.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static long __ctype_get_mb_cur_max() {
        var mh$ = __ctype_get_mb_cur_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_get_mb_cur_max");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_DOUBLE,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("atof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static double atof(MemorySegment __nptr) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", __nptr);
            }
            return (double)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("atoi"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static int atoi(MemorySegment __nptr) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", __nptr);
            }
            return (int)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("atol"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static long atol(MemorySegment __nptr) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("atoll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static long atoll(MemorySegment __nptr) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_DOUBLE,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strtod"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static double strtod(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", __nptr, __endptr);
            }
            return (double)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_FLOAT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strtof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static float strtof(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", __nptr, __endptr);
            }
            return (float)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strtol"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strtoul"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strtoq"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strtouq"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strtoll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strtoull"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("l64a"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a(long __n) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", __n);
            }
            return (MemorySegment)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("a64l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static long a64l(MemorySegment __s) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfInt nlink_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = gen_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = gen_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = gen_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = gen_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = gen_h.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("select"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("pselect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfInt blksize_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = gen_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = gen_h.C_INT;

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("random"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("srandom"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static void srandom(int __seed) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("initstate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate(int __seed, MemorySegment __statebuf, long __statelen) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", __seed, __statebuf, __statelen);
            }
            return (MemorySegment)mh$.invokeExact(__seed, __statebuf, __statelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("setstate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate(MemorySegment __statebuf) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", __statebuf);
            }
            return (MemorySegment)mh$.invokeExact(__statebuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("random_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static FunctionDescriptor random_r$descriptor() {
        return random_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MethodHandle random_r$handle() {
        return random_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static int random_r(MemorySegment __buf, MemorySegment __result) {
        var mh$ = random_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random_r", __buf, __result);
            }
            return (int)mh$.invokeExact(__buf, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("srandom_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static FunctionDescriptor srandom_r$descriptor() {
        return srandom_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MethodHandle srandom_r$handle() {
        return srandom_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static int srandom_r(int __seed, MemorySegment __buf) {
        var mh$ = srandom_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom_r", __seed, __buf);
            }
            return (int)mh$.invokeExact(__seed, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("initstate_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor initstate_r$descriptor() {
        return initstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle initstate_r$handle() {
        return initstate_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static int initstate_r(int __seed, MemorySegment __statebuf, long __statelen, MemorySegment __buf) {
        var mh$ = initstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate_r", __seed, __statebuf, __statelen, __buf);
            }
            return (int)mh$.invokeExact(__seed, __statebuf, __statelen, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("setstate_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor setstate_r$descriptor() {
        return setstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle setstate_r$handle() {
        return setstate_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static int setstate_r(MemorySegment __statebuf, MemorySegment __buf) {
        var mh$ = setstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate_r", __statebuf, __buf);
            }
            return (int)mh$.invokeExact(__statebuf, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rand"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("srand"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static void srand(int __seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rand_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static int rand_r(MemorySegment __seed) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", __seed);
            }
            return (int)mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_DOUBLE    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("drand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_DOUBLE,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("erand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static double erand48(MemorySegment __xsubi) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", __xsubi);
            }
            return (double)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("lrand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("nrand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static long nrand48(MemorySegment __xsubi) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("mrand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("jrand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static long jrand48(MemorySegment __xsubi) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("srand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static void srand48(long __seedval) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", __seedval);
            }
            mh$.invokeExact(__seedval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("seed48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment __seed16v) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", __seed16v);
            }
            return (MemorySegment)mh$.invokeExact(__seed16v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("lcong48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static void lcong48(MemorySegment __param) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", __param);
            }
            mh$.invokeExact(__param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("drand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor drand48_r$descriptor() {
        return drand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle drand48_r$handle() {
        return drand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int drand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = drand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("erand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor erand48_r$descriptor() {
        return erand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle erand48_r$handle() {
        return erand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int erand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = erand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("lrand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor lrand48_r$descriptor() {
        return lrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle lrand48_r$handle() {
        return lrand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int lrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = lrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("nrand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor nrand48_r$descriptor() {
        return nrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle nrand48_r$handle() {
        return nrand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int nrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = nrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("mrand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor mrand48_r$descriptor() {
        return mrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle mrand48_r$handle() {
        return mrand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int mrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = mrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("jrand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor jrand48_r$descriptor() {
        return jrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle jrand48_r$handle() {
        return jrand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int jrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = jrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("srand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor srand48_r$descriptor() {
        return srand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle srand48_r$handle() {
        return srand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static int srand48_r(long __seedval, MemorySegment __buffer) {
        var mh$ = srand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48_r", __seedval, __buffer);
            }
            return (int)mh$.invokeExact(__seedval, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("seed48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor seed48_r$descriptor() {
        return seed48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle seed48_r$handle() {
        return seed48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static int seed48_r(MemorySegment __seed16v, MemorySegment __buffer) {
        var mh$ = seed48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48_r", __seed16v, __buffer);
            }
            return (int)mh$.invokeExact(__seed16v, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("lcong48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor lcong48_r$descriptor() {
        return lcong48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle lcong48_r$handle() {
        return lcong48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static int lcong48_r(MemorySegment __param, MemorySegment __buffer) {
        var mh$ = lcong48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48_r", __param, __buffer);
            }
            return (int)mh$.invokeExact(__param, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("malloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("calloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __nmemb, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("realloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("free"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("reallocarray"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocarray$descriptor() {
        return reallocarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle reallocarray$handle() {
        return reallocarray.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray(MemorySegment __ptr, long __nmemb, long __size) {
        var mh$ = reallocarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocarray", __ptr, __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("alloca"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("valloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("posix_memalign"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("aligned_alloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("abort"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("atexit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("at_quick_exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("on_exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("quick_exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("_Exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("getenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("putenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("setenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("unsetenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("clearenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("mktemp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("mkstemp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("mkstemps"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("mkdtemp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("system"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("realpath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("bsearch"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("qsort"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("abs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("labs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG_LONG,
            gen_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("llabs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            gen_h.C_INT,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("div"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            gen_h.C_LONG,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ldiv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            gen_h.C_LONG_LONG,
            gen_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("lldiv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_DOUBLE,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ecvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_DOUBLE,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fcvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_DOUBLE,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("gcvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_DOUBLE,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ecvt_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_DOUBLE,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("fcvt_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("mblen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("mbtowc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("wctomb"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("mbstowcs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("wcstombs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rpmatch"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("getsubopt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("getloadavg"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("memcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("memmove"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("memccpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dest, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dest, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("memset"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset(MemorySegment __s, int __c, long __n) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("memcmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __memcmpeq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("__memcmpeq"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor __memcmpeq$descriptor() {
        return __memcmpeq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle __memcmpeq$handle() {
        return __memcmpeq.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int __memcmpeq(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = __memcmpeq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__memcmpeq", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("memchr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strncpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strcat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strncat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strcmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strncmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strcoll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strxfrm"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = gen_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = gen_h.C_POINTER;

    private static class strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strcoll_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static FunctionDescriptor strcoll_l$descriptor() {
        return strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MethodHandle strcoll_l$handle() {
        return strcoll_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static int strcoll_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __l) {
        var mh$ = strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll_l", __s1, __s2, __l);
            }
            return (int)mh$.invokeExact(__s1, __s2, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strxfrm_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static FunctionDescriptor strxfrm_l$descriptor() {
        return strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MethodHandle strxfrm_l$handle() {
        return strxfrm_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static long strxfrm_l(MemorySegment __dest, MemorySegment __src, long __n, MemorySegment __l) {
        var mh$ = strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm_l", __dest, __src, __n, __l);
            }
            return (long)mh$.invokeExact(__dest, __src, __n, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strdup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strndup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __string, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __string, __n);
            }
            return (MemorySegment)mh$.invokeExact(__string, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strchr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strrchr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strcspn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __reject) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __reject);
            }
            return (long)mh$.invokeExact(__s, __reject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strspn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __accept);
            }
            return (long)mh$.invokeExact(__s, __accept);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strpbrk"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __accept);
            }
            return (MemorySegment)mh$.invokeExact(__s, __accept);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strstr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strtok"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok(MemorySegment __s, MemorySegment __delim) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __s, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("__strtok_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor __strtok_r$descriptor() {
        return __strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle __strtok_r$handle() {
        return __strtok_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = __strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strtok_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strlen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strnlen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static long strnlen(MemorySegment __string, long __maxlen) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __string, __maxlen);
            }
            return (long)mh$.invokeExact(__string, __maxlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strerror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strerror_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __buf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __buf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __buf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strerror_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static FunctionDescriptor strerror_l$descriptor() {
        return strerror_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MethodHandle strerror_l$handle() {
        return strerror_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l(int __errnum, MemorySegment __l) {
        var mh$ = strerror_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_l", __errnum, __l);
            }
            return (MemorySegment)mh$.invokeExact(__errnum, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("bcmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int bcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("bcopy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static void bcopy(MemorySegment __src, MemorySegment __dest, long __n) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", __src, __dest, __n);
            }
            mh$.invokeExact(__src, __dest, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("bzero"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static void bzero(MemorySegment __s, long __n) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("index"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index(MemorySegment __s, int __c) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rindex"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex(MemorySegment __s, int __c) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ffs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static int ffs(int __i) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", __i);
            }
            return (int)mh$.invokeExact(__i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ffsl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static int ffsl(long __l) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", __l);
            }
            return (int)mh$.invokeExact(__l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("ffsll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static int ffsll(long __ll) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", __ll);
            }
            return (int)mh$.invokeExact(__ll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strcasecmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcasecmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strncasecmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncasecmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strcasecmp_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strcasecmp_l$descriptor() {
        return strcasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MethodHandle strcasecmp_l$handle() {
        return strcasecmp_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static int strcasecmp_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __loc) {
        var mh$ = strcasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp_l", __s1, __s2, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strncasecmp_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strncasecmp_l$descriptor() {
        return strncasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MethodHandle strncasecmp_l$handle() {
        return strncasecmp_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static int strncasecmp_l(MemorySegment __s1, MemorySegment __s2, long __n, MemorySegment __loc) {
        var mh$ = strncasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp_l", __s1, __s2, __n, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class explicit_bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("explicit_bzero"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor explicit_bzero$descriptor() {
        return explicit_bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle explicit_bzero$handle() {
        return explicit_bzero.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static void explicit_bzero(MemorySegment __s, long __n) {
        var mh$ = explicit_bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("explicit_bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strsep"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("strsignal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("__stpcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor __stpcpy$descriptor() {
        return __stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle __stpcpy$handle() {
        return __stpcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = __stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("stpcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("__stpncpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __stpncpy$descriptor() {
        return __stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __stpncpy$handle() {
        return __stpncpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("stpncpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int rcutils_snprintf(char *buffer, size_t buffer_size, const char *format, ...)
     * }
     */
    public static class rcutils_snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gen_h.C_INT,
                gen_h.C_POINTER,
                gen_h.C_LONG,
                gen_h.C_POINTER
            );
        private static final MemorySegment ADDR = gen_h.findOrThrow("rcutils_snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private rcutils_snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int rcutils_snprintf(char *buffer, size_t buffer_size, const char *format, ...)
         * }
         */
        public static rcutils_snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new rcutils_snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment buffer, long buffer_size, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("rcutils_snprintf", buffer, buffer_size, format, x3);
                }
                return (int)spreader.invokeExact(buffer, buffer_size, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class rcutils_fault_injection_is_test_complete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_fault_injection_is_test_complete"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcutils_fault_injection_is_test_complete()
     * }
     */
    public static FunctionDescriptor rcutils_fault_injection_is_test_complete$descriptor() {
        return rcutils_fault_injection_is_test_complete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcutils_fault_injection_is_test_complete()
     * }
     */
    public static MethodHandle rcutils_fault_injection_is_test_complete$handle() {
        return rcutils_fault_injection_is_test_complete.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcutils_fault_injection_is_test_complete()
     * }
     */
    public static boolean rcutils_fault_injection_is_test_complete() {
        var mh$ = rcutils_fault_injection_is_test_complete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_fault_injection_is_test_complete");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_fault_injection_set_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_fault_injection_set_count"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rcutils_fault_injection_set_count(int_least64_t count)
     * }
     */
    public static FunctionDescriptor rcutils_fault_injection_set_count$descriptor() {
        return rcutils_fault_injection_set_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rcutils_fault_injection_set_count(int_least64_t count)
     * }
     */
    public static MethodHandle rcutils_fault_injection_set_count$handle() {
        return rcutils_fault_injection_set_count.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void rcutils_fault_injection_set_count(int_least64_t count)
     * }
     */
    public static void rcutils_fault_injection_set_count(long count) {
        var mh$ = rcutils_fault_injection_set_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_fault_injection_set_count", count);
            }
            mh$.invokeExact(count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_fault_injection_get_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_fault_injection_get_count"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int_least64_t rcutils_fault_injection_get_count()
     * }
     */
    public static FunctionDescriptor rcutils_fault_injection_get_count$descriptor() {
        return rcutils_fault_injection_get_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int_least64_t rcutils_fault_injection_get_count()
     * }
     */
    public static MethodHandle rcutils_fault_injection_get_count$handle() {
        return rcutils_fault_injection_get_count.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int_least64_t rcutils_fault_injection_get_count()
     * }
     */
    public static long rcutils_fault_injection_get_count() {
        var mh$ = rcutils_fault_injection_get_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_fault_injection_get_count");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rcutils_fault_injection_maybe_fail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("_rcutils_fault_injection_maybe_fail"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int_least64_t _rcutils_fault_injection_maybe_fail()
     * }
     */
    public static FunctionDescriptor _rcutils_fault_injection_maybe_fail$descriptor() {
        return _rcutils_fault_injection_maybe_fail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int_least64_t _rcutils_fault_injection_maybe_fail()
     * }
     */
    public static MethodHandle _rcutils_fault_injection_maybe_fail$handle() {
        return _rcutils_fault_injection_maybe_fail.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int_least64_t _rcutils_fault_injection_maybe_fail()
     * }
     */
    public static long _rcutils_fault_injection_maybe_fail() {
        var mh$ = _rcutils_fault_injection_maybe_fail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rcutils_fault_injection_maybe_fail");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_initialize_error_handling_thread_local_storage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            rcutils_allocator_s.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_initialize_error_handling_thread_local_storage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_initialize_error_handling_thread_local_storage(rcutils_allocator_t allocator)
     * }
     */
    public static FunctionDescriptor rcutils_initialize_error_handling_thread_local_storage$descriptor() {
        return rcutils_initialize_error_handling_thread_local_storage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_initialize_error_handling_thread_local_storage(rcutils_allocator_t allocator)
     * }
     */
    public static MethodHandle rcutils_initialize_error_handling_thread_local_storage$handle() {
        return rcutils_initialize_error_handling_thread_local_storage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_initialize_error_handling_thread_local_storage(rcutils_allocator_t allocator)
     * }
     */
    public static int rcutils_initialize_error_handling_thread_local_storage(MemorySegment allocator) {
        var mh$ = rcutils_initialize_error_handling_thread_local_storage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_initialize_error_handling_thread_local_storage", allocator);
            }
            return (int)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_set_error_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_set_error_state"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rcutils_set_error_state(const char *error_string, const char *file, size_t line_number)
     * }
     */
    public static FunctionDescriptor rcutils_set_error_state$descriptor() {
        return rcutils_set_error_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rcutils_set_error_state(const char *error_string, const char *file, size_t line_number)
     * }
     */
    public static MethodHandle rcutils_set_error_state$handle() {
        return rcutils_set_error_state.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void rcutils_set_error_state(const char *error_string, const char *file, size_t line_number)
     * }
     */
    public static void rcutils_set_error_state(MemorySegment error_string, MemorySegment file, long line_number) {
        var mh$ = rcutils_set_error_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_set_error_state", error_string, file, line_number);
            }
            mh$.invokeExact(error_string, file, line_number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_error_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_error_is_set"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcutils_error_is_set()
     * }
     */
    public static FunctionDescriptor rcutils_error_is_set$descriptor() {
        return rcutils_error_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcutils_error_is_set()
     * }
     */
    public static MethodHandle rcutils_error_is_set$handle() {
        return rcutils_error_is_set.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcutils_error_is_set()
     * }
     */
    public static boolean rcutils_error_is_set() {
        var mh$ = rcutils_error_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_error_is_set");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_get_error_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_get_error_state"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rcutils_error_state_t *rcutils_get_error_state()
     * }
     */
    public static FunctionDescriptor rcutils_get_error_state$descriptor() {
        return rcutils_get_error_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rcutils_error_state_t *rcutils_get_error_state()
     * }
     */
    public static MethodHandle rcutils_get_error_state$handle() {
        return rcutils_get_error_state.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rcutils_error_state_t *rcutils_get_error_state()
     * }
     */
    public static MemorySegment rcutils_get_error_state() {
        var mh$ = rcutils_get_error_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_get_error_state");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_get_error_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcutils_error_string_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_get_error_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_error_string_t rcutils_get_error_string()
     * }
     */
    public static FunctionDescriptor rcutils_get_error_string$descriptor() {
        return rcutils_get_error_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_error_string_t rcutils_get_error_string()
     * }
     */
    public static MethodHandle rcutils_get_error_string$handle() {
        return rcutils_get_error_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_error_string_t rcutils_get_error_string()
     * }
     */
    public static MemorySegment rcutils_get_error_string(SegmentAllocator allocator) {
        var mh$ = rcutils_get_error_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_get_error_string", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_reset_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_reset_error"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rcutils_reset_error()
     * }
     */
    public static FunctionDescriptor rcutils_reset_error$descriptor() {
        return rcutils_reset_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rcutils_reset_error()
     * }
     */
    public static MethodHandle rcutils_reset_error$handle() {
        return rcutils_reset_error.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void rcutils_reset_error()
     * }
     */
    public static void rcutils_reset_error() {
        var mh$ = rcutils_reset_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_reset_error");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_get_zero_initialized_array_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcutils_array_list_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_get_zero_initialized_array_list"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_array_list_t rcutils_get_zero_initialized_array_list()
     * }
     */
    public static FunctionDescriptor rcutils_get_zero_initialized_array_list$descriptor() {
        return rcutils_get_zero_initialized_array_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_array_list_t rcutils_get_zero_initialized_array_list()
     * }
     */
    public static MethodHandle rcutils_get_zero_initialized_array_list$handle() {
        return rcutils_get_zero_initialized_array_list.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_array_list_t rcutils_get_zero_initialized_array_list()
     * }
     */
    public static MemorySegment rcutils_get_zero_initialized_array_list(SegmentAllocator allocator) {
        var mh$ = rcutils_get_zero_initialized_array_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_get_zero_initialized_array_list", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_array_list_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_array_list_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_init(rcutils_array_list_t *array_list, size_t initial_capacity, size_t data_size, const rcutils_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rcutils_array_list_init$descriptor() {
        return rcutils_array_list_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_init(rcutils_array_list_t *array_list, size_t initial_capacity, size_t data_size, const rcutils_allocator_t *allocator)
     * }
     */
    public static MethodHandle rcutils_array_list_init$handle() {
        return rcutils_array_list_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_init(rcutils_array_list_t *array_list, size_t initial_capacity, size_t data_size, const rcutils_allocator_t *allocator)
     * }
     */
    public static int rcutils_array_list_init(MemorySegment array_list, long initial_capacity, long data_size, MemorySegment allocator) {
        var mh$ = rcutils_array_list_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_array_list_init", array_list, initial_capacity, data_size, allocator);
            }
            return (int)mh$.invokeExact(array_list, initial_capacity, data_size, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_array_list_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_array_list_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_fini(rcutils_array_list_t *array_list)
     * }
     */
    public static FunctionDescriptor rcutils_array_list_fini$descriptor() {
        return rcutils_array_list_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_fini(rcutils_array_list_t *array_list)
     * }
     */
    public static MethodHandle rcutils_array_list_fini$handle() {
        return rcutils_array_list_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_fini(rcutils_array_list_t *array_list)
     * }
     */
    public static int rcutils_array_list_fini(MemorySegment array_list) {
        var mh$ = rcutils_array_list_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_array_list_fini", array_list);
            }
            return (int)mh$.invokeExact(array_list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_array_list_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_array_list_add"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_add(rcutils_array_list_t *array_list, const void *data)
     * }
     */
    public static FunctionDescriptor rcutils_array_list_add$descriptor() {
        return rcutils_array_list_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_add(rcutils_array_list_t *array_list, const void *data)
     * }
     */
    public static MethodHandle rcutils_array_list_add$handle() {
        return rcutils_array_list_add.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_add(rcutils_array_list_t *array_list, const void *data)
     * }
     */
    public static int rcutils_array_list_add(MemorySegment array_list, MemorySegment data) {
        var mh$ = rcutils_array_list_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_array_list_add", array_list, data);
            }
            return (int)mh$.invokeExact(array_list, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_array_list_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_array_list_set"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_set(rcutils_array_list_t *array_list, size_t index, const void *data)
     * }
     */
    public static FunctionDescriptor rcutils_array_list_set$descriptor() {
        return rcutils_array_list_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_set(rcutils_array_list_t *array_list, size_t index, const void *data)
     * }
     */
    public static MethodHandle rcutils_array_list_set$handle() {
        return rcutils_array_list_set.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_set(rcutils_array_list_t *array_list, size_t index, const void *data)
     * }
     */
    public static int rcutils_array_list_set(MemorySegment array_list, long index, MemorySegment data) {
        var mh$ = rcutils_array_list_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_array_list_set", array_list, index, data);
            }
            return (int)mh$.invokeExact(array_list, index, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_array_list_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_array_list_remove"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_remove(rcutils_array_list_t *array_list, size_t index)
     * }
     */
    public static FunctionDescriptor rcutils_array_list_remove$descriptor() {
        return rcutils_array_list_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_remove(rcutils_array_list_t *array_list, size_t index)
     * }
     */
    public static MethodHandle rcutils_array_list_remove$handle() {
        return rcutils_array_list_remove.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_remove(rcutils_array_list_t *array_list, size_t index)
     * }
     */
    public static int rcutils_array_list_remove(MemorySegment array_list, long index) {
        var mh$ = rcutils_array_list_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_array_list_remove", array_list, index);
            }
            return (int)mh$.invokeExact(array_list, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_array_list_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_array_list_get"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_get(const rcutils_array_list_t *array_list, size_t index, void *data)
     * }
     */
    public static FunctionDescriptor rcutils_array_list_get$descriptor() {
        return rcutils_array_list_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_get(const rcutils_array_list_t *array_list, size_t index, void *data)
     * }
     */
    public static MethodHandle rcutils_array_list_get$handle() {
        return rcutils_array_list_get.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_get(const rcutils_array_list_t *array_list, size_t index, void *data)
     * }
     */
    public static int rcutils_array_list_get(MemorySegment array_list, long index, MemorySegment data) {
        var mh$ = rcutils_array_list_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_array_list_get", array_list, index, data);
            }
            return (int)mh$.invokeExact(array_list, index, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_array_list_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_array_list_get_size"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_get_size(const rcutils_array_list_t *array_list, size_t *size)
     * }
     */
    public static FunctionDescriptor rcutils_array_list_get_size$descriptor() {
        return rcutils_array_list_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_get_size(const rcutils_array_list_t *array_list, size_t *size)
     * }
     */
    public static MethodHandle rcutils_array_list_get_size$handle() {
        return rcutils_array_list_get_size.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_array_list_get_size(const rcutils_array_list_t *array_list, size_t *size)
     * }
     */
    public static int rcutils_array_list_get_size(MemorySegment array_list, MemorySegment size) {
        var mh$ = rcutils_array_list_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_array_list_get_size", array_list, size);
            }
            return (int)mh$.invokeExact(array_list, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_get_zero_initialized_char_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcutils_char_array_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_get_zero_initialized_char_array"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_char_array_t rcutils_get_zero_initialized_char_array()
     * }
     */
    public static FunctionDescriptor rcutils_get_zero_initialized_char_array$descriptor() {
        return rcutils_get_zero_initialized_char_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_char_array_t rcutils_get_zero_initialized_char_array()
     * }
     */
    public static MethodHandle rcutils_get_zero_initialized_char_array$handle() {
        return rcutils_get_zero_initialized_char_array.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_char_array_t rcutils_get_zero_initialized_char_array()
     * }
     */
    public static MemorySegment rcutils_get_zero_initialized_char_array(SegmentAllocator allocator) {
        var mh$ = rcutils_get_zero_initialized_char_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_get_zero_initialized_char_array", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_char_array_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_char_array_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_init(rcutils_char_array_t *char_array, size_t buffer_capacity, const rcutils_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rcutils_char_array_init$descriptor() {
        return rcutils_char_array_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_init(rcutils_char_array_t *char_array, size_t buffer_capacity, const rcutils_allocator_t *allocator)
     * }
     */
    public static MethodHandle rcutils_char_array_init$handle() {
        return rcutils_char_array_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_init(rcutils_char_array_t *char_array, size_t buffer_capacity, const rcutils_allocator_t *allocator)
     * }
     */
    public static int rcutils_char_array_init(MemorySegment char_array, long buffer_capacity, MemorySegment allocator) {
        var mh$ = rcutils_char_array_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_char_array_init", char_array, buffer_capacity, allocator);
            }
            return (int)mh$.invokeExact(char_array, buffer_capacity, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_char_array_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_char_array_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_fini(rcutils_char_array_t *char_array)
     * }
     */
    public static FunctionDescriptor rcutils_char_array_fini$descriptor() {
        return rcutils_char_array_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_fini(rcutils_char_array_t *char_array)
     * }
     */
    public static MethodHandle rcutils_char_array_fini$handle() {
        return rcutils_char_array_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_fini(rcutils_char_array_t *char_array)
     * }
     */
    public static int rcutils_char_array_fini(MemorySegment char_array) {
        var mh$ = rcutils_char_array_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_char_array_fini", char_array);
            }
            return (int)mh$.invokeExact(char_array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_char_array_resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_char_array_resize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_resize(rcutils_char_array_t *char_array, size_t new_size)
     * }
     */
    public static FunctionDescriptor rcutils_char_array_resize$descriptor() {
        return rcutils_char_array_resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_resize(rcutils_char_array_t *char_array, size_t new_size)
     * }
     */
    public static MethodHandle rcutils_char_array_resize$handle() {
        return rcutils_char_array_resize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_resize(rcutils_char_array_t *char_array, size_t new_size)
     * }
     */
    public static int rcutils_char_array_resize(MemorySegment char_array, long new_size) {
        var mh$ = rcutils_char_array_resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_char_array_resize", char_array, new_size);
            }
            return (int)mh$.invokeExact(char_array, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_char_array_expand_as_needed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_char_array_expand_as_needed"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_expand_as_needed(rcutils_char_array_t *char_array, size_t new_size)
     * }
     */
    public static FunctionDescriptor rcutils_char_array_expand_as_needed$descriptor() {
        return rcutils_char_array_expand_as_needed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_expand_as_needed(rcutils_char_array_t *char_array, size_t new_size)
     * }
     */
    public static MethodHandle rcutils_char_array_expand_as_needed$handle() {
        return rcutils_char_array_expand_as_needed.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_expand_as_needed(rcutils_char_array_t *char_array, size_t new_size)
     * }
     */
    public static int rcutils_char_array_expand_as_needed(MemorySegment char_array, long new_size) {
        var mh$ = rcutils_char_array_expand_as_needed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_char_array_expand_as_needed", char_array, new_size);
            }
            return (int)mh$.invokeExact(char_array, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_char_array_strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_char_array_strncat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_strncat(rcutils_char_array_t *char_array, const char *src, size_t n)
     * }
     */
    public static FunctionDescriptor rcutils_char_array_strncat$descriptor() {
        return rcutils_char_array_strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_strncat(rcutils_char_array_t *char_array, const char *src, size_t n)
     * }
     */
    public static MethodHandle rcutils_char_array_strncat$handle() {
        return rcutils_char_array_strncat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_strncat(rcutils_char_array_t *char_array, const char *src, size_t n)
     * }
     */
    public static int rcutils_char_array_strncat(MemorySegment char_array, MemorySegment src, long n) {
        var mh$ = rcutils_char_array_strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_char_array_strncat", char_array, src, n);
            }
            return (int)mh$.invokeExact(char_array, src, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_char_array_strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_char_array_strcat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_strcat(rcutils_char_array_t *char_array, const char *src)
     * }
     */
    public static FunctionDescriptor rcutils_char_array_strcat$descriptor() {
        return rcutils_char_array_strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_strcat(rcutils_char_array_t *char_array, const char *src)
     * }
     */
    public static MethodHandle rcutils_char_array_strcat$handle() {
        return rcutils_char_array_strcat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_strcat(rcutils_char_array_t *char_array, const char *src)
     * }
     */
    public static int rcutils_char_array_strcat(MemorySegment char_array, MemorySegment src) {
        var mh$ = rcutils_char_array_strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_char_array_strcat", char_array, src);
            }
            return (int)mh$.invokeExact(char_array, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_char_array_memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_char_array_memcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_memcpy(rcutils_char_array_t *char_array, const char *src, size_t n)
     * }
     */
    public static FunctionDescriptor rcutils_char_array_memcpy$descriptor() {
        return rcutils_char_array_memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_memcpy(rcutils_char_array_t *char_array, const char *src, size_t n)
     * }
     */
    public static MethodHandle rcutils_char_array_memcpy$handle() {
        return rcutils_char_array_memcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_memcpy(rcutils_char_array_t *char_array, const char *src, size_t n)
     * }
     */
    public static int rcutils_char_array_memcpy(MemorySegment char_array, MemorySegment src, long n) {
        var mh$ = rcutils_char_array_memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_char_array_memcpy", char_array, src, n);
            }
            return (int)mh$.invokeExact(char_array, src, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_char_array_strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_char_array_strcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_strcpy(rcutils_char_array_t *char_array, const char *src)
     * }
     */
    public static FunctionDescriptor rcutils_char_array_strcpy$descriptor() {
        return rcutils_char_array_strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_strcpy(rcutils_char_array_t *char_array, const char *src)
     * }
     */
    public static MethodHandle rcutils_char_array_strcpy$handle() {
        return rcutils_char_array_strcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_char_array_strcpy(rcutils_char_array_t *char_array, const char *src)
     * }
     */
    public static int rcutils_char_array_strcpy(MemorySegment char_array, MemorySegment src) {
        var mh$ = rcutils_char_array_strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_char_array_strcpy", char_array, src);
            }
            return (int)mh$.invokeExact(char_array, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_hash_map_string_hash_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_hash_map_string_hash_func"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t rcutils_hash_map_string_hash_func(const void *key_str)
     * }
     */
    public static FunctionDescriptor rcutils_hash_map_string_hash_func$descriptor() {
        return rcutils_hash_map_string_hash_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t rcutils_hash_map_string_hash_func(const void *key_str)
     * }
     */
    public static MethodHandle rcutils_hash_map_string_hash_func$handle() {
        return rcutils_hash_map_string_hash_func.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t rcutils_hash_map_string_hash_func(const void *key_str)
     * }
     */
    public static long rcutils_hash_map_string_hash_func(MemorySegment key_str) {
        var mh$ = rcutils_hash_map_string_hash_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_hash_map_string_hash_func", key_str);
            }
            return (long)mh$.invokeExact(key_str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_hash_map_string_cmp_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_hash_map_string_cmp_func"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcutils_hash_map_string_cmp_func(const void *val1, const void *val2)
     * }
     */
    public static FunctionDescriptor rcutils_hash_map_string_cmp_func$descriptor() {
        return rcutils_hash_map_string_cmp_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcutils_hash_map_string_cmp_func(const void *val1, const void *val2)
     * }
     */
    public static MethodHandle rcutils_hash_map_string_cmp_func$handle() {
        return rcutils_hash_map_string_cmp_func.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int rcutils_hash_map_string_cmp_func(const void *val1, const void *val2)
     * }
     */
    public static int rcutils_hash_map_string_cmp_func(MemorySegment val1, MemorySegment val2) {
        var mh$ = rcutils_hash_map_string_cmp_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_hash_map_string_cmp_func", val1, val2);
            }
            return (int)mh$.invokeExact(val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * rcutils_hash_map_t rcutils_get_zero_initialized_hash_map()
     * }
     */
    public static class rcutils_get_zero_initialized_hash_map {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                rcutils_hash_map_s.layout()        );
        private static final MemorySegment ADDR = gen_h.findOrThrow("rcutils_get_zero_initialized_hash_map");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private rcutils_get_zero_initialized_hash_map(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * rcutils_hash_map_t rcutils_get_zero_initialized_hash_map()
         * }
         */
        public static rcutils_get_zero_initialized_hash_map makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new rcutils_get_zero_initialized_hash_map(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("rcutils_get_zero_initialized_hash_map", allocator, x0);
                }
                return (MemorySegment)spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class rcutils_hash_map_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG,
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_hash_map_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_init(rcutils_hash_map_t *hash_map, size_t initial_capacity, size_t key_size, size_t data_size, rcutils_hash_map_key_hasher_t key_hashing_func, rcutils_hash_map_key_cmp_t key_cmp_func, const rcutils_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rcutils_hash_map_init$descriptor() {
        return rcutils_hash_map_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_init(rcutils_hash_map_t *hash_map, size_t initial_capacity, size_t key_size, size_t data_size, rcutils_hash_map_key_hasher_t key_hashing_func, rcutils_hash_map_key_cmp_t key_cmp_func, const rcutils_allocator_t *allocator)
     * }
     */
    public static MethodHandle rcutils_hash_map_init$handle() {
        return rcutils_hash_map_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_init(rcutils_hash_map_t *hash_map, size_t initial_capacity, size_t key_size, size_t data_size, rcutils_hash_map_key_hasher_t key_hashing_func, rcutils_hash_map_key_cmp_t key_cmp_func, const rcutils_allocator_t *allocator)
     * }
     */
    public static int rcutils_hash_map_init(MemorySegment hash_map, long initial_capacity, long key_size, long data_size, MemorySegment key_hashing_func, MemorySegment key_cmp_func, MemorySegment allocator) {
        var mh$ = rcutils_hash_map_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_hash_map_init", hash_map, initial_capacity, key_size, data_size, key_hashing_func, key_cmp_func, allocator);
            }
            return (int)mh$.invokeExact(hash_map, initial_capacity, key_size, data_size, key_hashing_func, key_cmp_func, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_hash_map_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_hash_map_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_fini(rcutils_hash_map_t *hash_map)
     * }
     */
    public static FunctionDescriptor rcutils_hash_map_fini$descriptor() {
        return rcutils_hash_map_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_fini(rcutils_hash_map_t *hash_map)
     * }
     */
    public static MethodHandle rcutils_hash_map_fini$handle() {
        return rcutils_hash_map_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_fini(rcutils_hash_map_t *hash_map)
     * }
     */
    public static int rcutils_hash_map_fini(MemorySegment hash_map) {
        var mh$ = rcutils_hash_map_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_hash_map_fini", hash_map);
            }
            return (int)mh$.invokeExact(hash_map);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_hash_map_get_capacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_hash_map_get_capacity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get_capacity(const rcutils_hash_map_t *hash_map, size_t *capacity)
     * }
     */
    public static FunctionDescriptor rcutils_hash_map_get_capacity$descriptor() {
        return rcutils_hash_map_get_capacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get_capacity(const rcutils_hash_map_t *hash_map, size_t *capacity)
     * }
     */
    public static MethodHandle rcutils_hash_map_get_capacity$handle() {
        return rcutils_hash_map_get_capacity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get_capacity(const rcutils_hash_map_t *hash_map, size_t *capacity)
     * }
     */
    public static int rcutils_hash_map_get_capacity(MemorySegment hash_map, MemorySegment capacity) {
        var mh$ = rcutils_hash_map_get_capacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_hash_map_get_capacity", hash_map, capacity);
            }
            return (int)mh$.invokeExact(hash_map, capacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_hash_map_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_hash_map_get_size"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get_size(const rcutils_hash_map_t *hash_map, size_t *size)
     * }
     */
    public static FunctionDescriptor rcutils_hash_map_get_size$descriptor() {
        return rcutils_hash_map_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get_size(const rcutils_hash_map_t *hash_map, size_t *size)
     * }
     */
    public static MethodHandle rcutils_hash_map_get_size$handle() {
        return rcutils_hash_map_get_size.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get_size(const rcutils_hash_map_t *hash_map, size_t *size)
     * }
     */
    public static int rcutils_hash_map_get_size(MemorySegment hash_map, MemorySegment size) {
        var mh$ = rcutils_hash_map_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_hash_map_get_size", hash_map, size);
            }
            return (int)mh$.invokeExact(hash_map, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_hash_map_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_hash_map_set"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_set(rcutils_hash_map_t *hash_map, const void *key, const void *value)
     * }
     */
    public static FunctionDescriptor rcutils_hash_map_set$descriptor() {
        return rcutils_hash_map_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_set(rcutils_hash_map_t *hash_map, const void *key, const void *value)
     * }
     */
    public static MethodHandle rcutils_hash_map_set$handle() {
        return rcutils_hash_map_set.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_set(rcutils_hash_map_t *hash_map, const void *key, const void *value)
     * }
     */
    public static int rcutils_hash_map_set(MemorySegment hash_map, MemorySegment key, MemorySegment value) {
        var mh$ = rcutils_hash_map_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_hash_map_set", hash_map, key, value);
            }
            return (int)mh$.invokeExact(hash_map, key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_hash_map_unset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_hash_map_unset"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_unset(rcutils_hash_map_t *hash_map, const void *key)
     * }
     */
    public static FunctionDescriptor rcutils_hash_map_unset$descriptor() {
        return rcutils_hash_map_unset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_unset(rcutils_hash_map_t *hash_map, const void *key)
     * }
     */
    public static MethodHandle rcutils_hash_map_unset$handle() {
        return rcutils_hash_map_unset.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_unset(rcutils_hash_map_t *hash_map, const void *key)
     * }
     */
    public static int rcutils_hash_map_unset(MemorySegment hash_map, MemorySegment key) {
        var mh$ = rcutils_hash_map_unset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_hash_map_unset", hash_map, key);
            }
            return (int)mh$.invokeExact(hash_map, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_hash_map_key_exists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_hash_map_key_exists"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcutils_hash_map_key_exists(const rcutils_hash_map_t *hash_map, const void *key)
     * }
     */
    public static FunctionDescriptor rcutils_hash_map_key_exists$descriptor() {
        return rcutils_hash_map_key_exists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcutils_hash_map_key_exists(const rcutils_hash_map_t *hash_map, const void *key)
     * }
     */
    public static MethodHandle rcutils_hash_map_key_exists$handle() {
        return rcutils_hash_map_key_exists.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcutils_hash_map_key_exists(const rcutils_hash_map_t *hash_map, const void *key)
     * }
     */
    public static boolean rcutils_hash_map_key_exists(MemorySegment hash_map, MemorySegment key) {
        var mh$ = rcutils_hash_map_key_exists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_hash_map_key_exists", hash_map, key);
            }
            return (boolean)mh$.invokeExact(hash_map, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_hash_map_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_hash_map_get"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get(const rcutils_hash_map_t *hash_map, const void *key, void *data)
     * }
     */
    public static FunctionDescriptor rcutils_hash_map_get$descriptor() {
        return rcutils_hash_map_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get(const rcutils_hash_map_t *hash_map, const void *key, void *data)
     * }
     */
    public static MethodHandle rcutils_hash_map_get$handle() {
        return rcutils_hash_map_get.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get(const rcutils_hash_map_t *hash_map, const void *key, void *data)
     * }
     */
    public static int rcutils_hash_map_get(MemorySegment hash_map, MemorySegment key, MemorySegment data) {
        var mh$ = rcutils_hash_map_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_hash_map_get", hash_map, key, data);
            }
            return (int)mh$.invokeExact(hash_map, key, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_hash_map_get_next_key_and_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_hash_map_get_next_key_and_data"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get_next_key_and_data(const rcutils_hash_map_t *hash_map, const void *previous_key, void *key, void *data)
     * }
     */
    public static FunctionDescriptor rcutils_hash_map_get_next_key_and_data$descriptor() {
        return rcutils_hash_map_get_next_key_and_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get_next_key_and_data(const rcutils_hash_map_t *hash_map, const void *previous_key, void *key, void *data)
     * }
     */
    public static MethodHandle rcutils_hash_map_get_next_key_and_data$handle() {
        return rcutils_hash_map_get_next_key_and_data.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_hash_map_get_next_key_and_data(const rcutils_hash_map_t *hash_map, const void *previous_key, void *key, void *data)
     * }
     */
    public static int rcutils_hash_map_get_next_key_and_data(MemorySegment hash_map, MemorySegment previous_key, MemorySegment key, MemorySegment data) {
        var mh$ = rcutils_hash_map_get_next_key_and_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_hash_map_get_next_key_and_data", hash_map, previous_key, key, data);
            }
            return (int)mh$.invokeExact(hash_map, previous_key, key, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_qsort"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_qsort(void *ptr, size_t count, size_t size, int (*comp)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor rcutils_qsort$descriptor() {
        return rcutils_qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_qsort(void *ptr, size_t count, size_t size, int (*comp)(const void *, const void *))
     * }
     */
    public static MethodHandle rcutils_qsort$handle() {
        return rcutils_qsort.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_qsort(void *ptr, size_t count, size_t size, int (*comp)(const void *, const void *))
     * }
     */
    public static int rcutils_qsort(MemorySegment ptr, long count, long size, MemorySegment comp) {
        var mh$ = rcutils_qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_qsort", ptr, count, size, comp);
            }
            return (int)mh$.invokeExact(ptr, count, size, comp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_get_zero_initialized_string_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcutils_string_array_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_get_zero_initialized_string_array"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_string_array_t rcutils_get_zero_initialized_string_array()
     * }
     */
    public static FunctionDescriptor rcutils_get_zero_initialized_string_array$descriptor() {
        return rcutils_get_zero_initialized_string_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_string_array_t rcutils_get_zero_initialized_string_array()
     * }
     */
    public static MethodHandle rcutils_get_zero_initialized_string_array$handle() {
        return rcutils_get_zero_initialized_string_array.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_string_array_t rcutils_get_zero_initialized_string_array()
     * }
     */
    public static MemorySegment rcutils_get_zero_initialized_string_array(SegmentAllocator allocator) {
        var mh$ = rcutils_get_zero_initialized_string_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_get_zero_initialized_string_array", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_array_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_array_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_init(rcutils_string_array_t *string_array, size_t size, const rcutils_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rcutils_string_array_init$descriptor() {
        return rcutils_string_array_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_init(rcutils_string_array_t *string_array, size_t size, const rcutils_allocator_t *allocator)
     * }
     */
    public static MethodHandle rcutils_string_array_init$handle() {
        return rcutils_string_array_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_init(rcutils_string_array_t *string_array, size_t size, const rcutils_allocator_t *allocator)
     * }
     */
    public static int rcutils_string_array_init(MemorySegment string_array, long size, MemorySegment allocator) {
        var mh$ = rcutils_string_array_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_array_init", string_array, size, allocator);
            }
            return (int)mh$.invokeExact(string_array, size, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_array_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_array_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_fini(rcutils_string_array_t *string_array)
     * }
     */
    public static FunctionDescriptor rcutils_string_array_fini$descriptor() {
        return rcutils_string_array_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_fini(rcutils_string_array_t *string_array)
     * }
     */
    public static MethodHandle rcutils_string_array_fini$handle() {
        return rcutils_string_array_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_fini(rcutils_string_array_t *string_array)
     * }
     */
    public static int rcutils_string_array_fini(MemorySegment string_array) {
        var mh$ = rcutils_string_array_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_array_fini", string_array);
            }
            return (int)mh$.invokeExact(string_array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_array_cmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_array_cmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_cmp(const rcutils_string_array_t *lhs, const rcutils_string_array_t *rhs, int *res)
     * }
     */
    public static FunctionDescriptor rcutils_string_array_cmp$descriptor() {
        return rcutils_string_array_cmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_cmp(const rcutils_string_array_t *lhs, const rcutils_string_array_t *rhs, int *res)
     * }
     */
    public static MethodHandle rcutils_string_array_cmp$handle() {
        return rcutils_string_array_cmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_cmp(const rcutils_string_array_t *lhs, const rcutils_string_array_t *rhs, int *res)
     * }
     */
    public static int rcutils_string_array_cmp(MemorySegment lhs, MemorySegment rhs, MemorySegment res) {
        var mh$ = rcutils_string_array_cmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_array_cmp", lhs, rhs, res);
            }
            return (int)mh$.invokeExact(lhs, rhs, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_array_resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_array_resize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_resize(rcutils_string_array_t *string_array, size_t new_size)
     * }
     */
    public static FunctionDescriptor rcutils_string_array_resize$descriptor() {
        return rcutils_string_array_resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_resize(rcutils_string_array_t *string_array, size_t new_size)
     * }
     */
    public static MethodHandle rcutils_string_array_resize$handle() {
        return rcutils_string_array_resize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_array_resize(rcutils_string_array_t *string_array, size_t new_size)
     * }
     */
    public static int rcutils_string_array_resize(MemorySegment string_array, long new_size) {
        var mh$ = rcutils_string_array_resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_array_resize", string_array, new_size);
            }
            return (int)mh$.invokeExact(string_array, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_array_sort_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_array_sort_compare"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcutils_string_array_sort_compare(const void *lhs, const void *rhs)
     * }
     */
    public static FunctionDescriptor rcutils_string_array_sort_compare$descriptor() {
        return rcutils_string_array_sort_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcutils_string_array_sort_compare(const void *lhs, const void *rhs)
     * }
     */
    public static MethodHandle rcutils_string_array_sort_compare$handle() {
        return rcutils_string_array_sort_compare.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int rcutils_string_array_sort_compare(const void *lhs, const void *rhs)
     * }
     */
    public static int rcutils_string_array_sort_compare(MemorySegment lhs, MemorySegment rhs) {
        var mh$ = rcutils_string_array_sort_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_array_sort_compare", lhs, rhs);
            }
            return (int)mh$.invokeExact(lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * rcutils_string_map_t rcutils_get_zero_initialized_string_map()
     * }
     */
    public static class rcutils_get_zero_initialized_string_map {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                rcutils_string_map_s.layout()        );
        private static final MemorySegment ADDR = gen_h.findOrThrow("rcutils_get_zero_initialized_string_map");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private rcutils_get_zero_initialized_string_map(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * rcutils_string_map_t rcutils_get_zero_initialized_string_map()
         * }
         */
        public static rcutils_get_zero_initialized_string_map makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new rcutils_get_zero_initialized_string_map(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("rcutils_get_zero_initialized_string_map", allocator, x0);
                }
                return (MemorySegment)spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class rcutils_string_map_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            rcutils_allocator_s.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_init(rcutils_string_map_t *string_map, size_t initial_capacity, rcutils_allocator_t allocator)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_init$descriptor() {
        return rcutils_string_map_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_init(rcutils_string_map_t *string_map, size_t initial_capacity, rcutils_allocator_t allocator)
     * }
     */
    public static MethodHandle rcutils_string_map_init$handle() {
        return rcutils_string_map_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_init(rcutils_string_map_t *string_map, size_t initial_capacity, rcutils_allocator_t allocator)
     * }
     */
    public static int rcutils_string_map_init(MemorySegment string_map, long initial_capacity, MemorySegment allocator) {
        var mh$ = rcutils_string_map_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_init", string_map, initial_capacity, allocator);
            }
            return (int)mh$.invokeExact(string_map, initial_capacity, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_fini(rcutils_string_map_t *string_map)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_fini$descriptor() {
        return rcutils_string_map_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_fini(rcutils_string_map_t *string_map)
     * }
     */
    public static MethodHandle rcutils_string_map_fini$handle() {
        return rcutils_string_map_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_fini(rcutils_string_map_t *string_map)
     * }
     */
    public static int rcutils_string_map_fini(MemorySegment string_map) {
        var mh$ = rcutils_string_map_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_fini", string_map);
            }
            return (int)mh$.invokeExact(string_map);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_get_capacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_get_capacity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_get_capacity(const rcutils_string_map_t *string_map, size_t *capacity)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_get_capacity$descriptor() {
        return rcutils_string_map_get_capacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_get_capacity(const rcutils_string_map_t *string_map, size_t *capacity)
     * }
     */
    public static MethodHandle rcutils_string_map_get_capacity$handle() {
        return rcutils_string_map_get_capacity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_get_capacity(const rcutils_string_map_t *string_map, size_t *capacity)
     * }
     */
    public static int rcutils_string_map_get_capacity(MemorySegment string_map, MemorySegment capacity) {
        var mh$ = rcutils_string_map_get_capacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_get_capacity", string_map, capacity);
            }
            return (int)mh$.invokeExact(string_map, capacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_get_size"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_get_size(const rcutils_string_map_t *string_map, size_t *size)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_get_size$descriptor() {
        return rcutils_string_map_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_get_size(const rcutils_string_map_t *string_map, size_t *size)
     * }
     */
    public static MethodHandle rcutils_string_map_get_size$handle() {
        return rcutils_string_map_get_size.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_get_size(const rcutils_string_map_t *string_map, size_t *size)
     * }
     */
    public static int rcutils_string_map_get_size(MemorySegment string_map, MemorySegment size) {
        var mh$ = rcutils_string_map_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_get_size", string_map, size);
            }
            return (int)mh$.invokeExact(string_map, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_reserve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_reserve"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_reserve(rcutils_string_map_t *string_map, size_t capacity)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_reserve$descriptor() {
        return rcutils_string_map_reserve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_reserve(rcutils_string_map_t *string_map, size_t capacity)
     * }
     */
    public static MethodHandle rcutils_string_map_reserve$handle() {
        return rcutils_string_map_reserve.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_reserve(rcutils_string_map_t *string_map, size_t capacity)
     * }
     */
    public static int rcutils_string_map_reserve(MemorySegment string_map, long capacity) {
        var mh$ = rcutils_string_map_reserve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_reserve", string_map, capacity);
            }
            return (int)mh$.invokeExact(string_map, capacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_clear"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_clear(rcutils_string_map_t *string_map)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_clear$descriptor() {
        return rcutils_string_map_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_clear(rcutils_string_map_t *string_map)
     * }
     */
    public static MethodHandle rcutils_string_map_clear$handle() {
        return rcutils_string_map_clear.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_clear(rcutils_string_map_t *string_map)
     * }
     */
    public static int rcutils_string_map_clear(MemorySegment string_map) {
        var mh$ = rcutils_string_map_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_clear", string_map);
            }
            return (int)mh$.invokeExact(string_map);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_set"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_set(rcutils_string_map_t *string_map, const char *key, const char *value)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_set$descriptor() {
        return rcutils_string_map_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_set(rcutils_string_map_t *string_map, const char *key, const char *value)
     * }
     */
    public static MethodHandle rcutils_string_map_set$handle() {
        return rcutils_string_map_set.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_set(rcutils_string_map_t *string_map, const char *key, const char *value)
     * }
     */
    public static int rcutils_string_map_set(MemorySegment string_map, MemorySegment key, MemorySegment value) {
        var mh$ = rcutils_string_map_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_set", string_map, key, value);
            }
            return (int)mh$.invokeExact(string_map, key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_set_no_resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_set_no_resize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_set_no_resize(rcutils_string_map_t *string_map, const char *key, const char *value)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_set_no_resize$descriptor() {
        return rcutils_string_map_set_no_resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_set_no_resize(rcutils_string_map_t *string_map, const char *key, const char *value)
     * }
     */
    public static MethodHandle rcutils_string_map_set_no_resize$handle() {
        return rcutils_string_map_set_no_resize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_set_no_resize(rcutils_string_map_t *string_map, const char *key, const char *value)
     * }
     */
    public static int rcutils_string_map_set_no_resize(MemorySegment string_map, MemorySegment key, MemorySegment value) {
        var mh$ = rcutils_string_map_set_no_resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_set_no_resize", string_map, key, value);
            }
            return (int)mh$.invokeExact(string_map, key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_unset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_unset"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_unset(rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_unset$descriptor() {
        return rcutils_string_map_unset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_unset(rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static MethodHandle rcutils_string_map_unset$handle() {
        return rcutils_string_map_unset.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_unset(rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static int rcutils_string_map_unset(MemorySegment string_map, MemorySegment key) {
        var mh$ = rcutils_string_map_unset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_unset", string_map, key);
            }
            return (int)mh$.invokeExact(string_map, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_key_exists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_key_exists"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcutils_string_map_key_exists(const rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_key_exists$descriptor() {
        return rcutils_string_map_key_exists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcutils_string_map_key_exists(const rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static MethodHandle rcutils_string_map_key_exists$handle() {
        return rcutils_string_map_key_exists.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcutils_string_map_key_exists(const rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static boolean rcutils_string_map_key_exists(MemorySegment string_map, MemorySegment key) {
        var mh$ = rcutils_string_map_key_exists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_key_exists", string_map, key);
            }
            return (boolean)mh$.invokeExact(string_map, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_key_existsn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_key_existsn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcutils_string_map_key_existsn(const rcutils_string_map_t *string_map, const char *key, size_t key_length)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_key_existsn$descriptor() {
        return rcutils_string_map_key_existsn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcutils_string_map_key_existsn(const rcutils_string_map_t *string_map, const char *key, size_t key_length)
     * }
     */
    public static MethodHandle rcutils_string_map_key_existsn$handle() {
        return rcutils_string_map_key_existsn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcutils_string_map_key_existsn(const rcutils_string_map_t *string_map, const char *key, size_t key_length)
     * }
     */
    public static boolean rcutils_string_map_key_existsn(MemorySegment string_map, MemorySegment key, long key_length) {
        var mh$ = rcutils_string_map_key_existsn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_key_existsn", string_map, key, key_length);
            }
            return (boolean)mh$.invokeExact(string_map, key, key_length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_get"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rcutils_string_map_get(const rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_get$descriptor() {
        return rcutils_string_map_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rcutils_string_map_get(const rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static MethodHandle rcutils_string_map_get$handle() {
        return rcutils_string_map_get.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rcutils_string_map_get(const rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static MemorySegment rcutils_string_map_get(MemorySegment string_map, MemorySegment key) {
        var mh$ = rcutils_string_map_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_get", string_map, key);
            }
            return (MemorySegment)mh$.invokeExact(string_map, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_getn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_getn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rcutils_string_map_getn(const rcutils_string_map_t *string_map, const char *key, size_t key_length)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_getn$descriptor() {
        return rcutils_string_map_getn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rcutils_string_map_getn(const rcutils_string_map_t *string_map, const char *key, size_t key_length)
     * }
     */
    public static MethodHandle rcutils_string_map_getn$handle() {
        return rcutils_string_map_getn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rcutils_string_map_getn(const rcutils_string_map_t *string_map, const char *key, size_t key_length)
     * }
     */
    public static MemorySegment rcutils_string_map_getn(MemorySegment string_map, MemorySegment key, long key_length) {
        var mh$ = rcutils_string_map_getn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_getn", string_map, key, key_length);
            }
            return (MemorySegment)mh$.invokeExact(string_map, key, key_length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_get_next_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_get_next_key"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rcutils_string_map_get_next_key(const rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_get_next_key$descriptor() {
        return rcutils_string_map_get_next_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rcutils_string_map_get_next_key(const rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static MethodHandle rcutils_string_map_get_next_key$handle() {
        return rcutils_string_map_get_next_key.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rcutils_string_map_get_next_key(const rcutils_string_map_t *string_map, const char *key)
     * }
     */
    public static MemorySegment rcutils_string_map_get_next_key(MemorySegment string_map, MemorySegment key) {
        var mh$ = rcutils_string_map_get_next_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_get_next_key", string_map, key);
            }
            return (MemorySegment)mh$.invokeExact(string_map, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_string_map_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_string_map_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_copy(const rcutils_string_map_t *src_string_map, rcutils_string_map_t *dst_string_map)
     * }
     */
    public static FunctionDescriptor rcutils_string_map_copy$descriptor() {
        return rcutils_string_map_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_copy(const rcutils_string_map_t *src_string_map, rcutils_string_map_t *dst_string_map)
     * }
     */
    public static MethodHandle rcutils_string_map_copy$handle() {
        return rcutils_string_map_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_string_map_copy(const rcutils_string_map_t *src_string_map, rcutils_string_map_t *dst_string_map)
     * }
     */
    public static int rcutils_string_map_copy(MemorySegment src_string_map, MemorySegment dst_string_map) {
        var mh$ = rcutils_string_map_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_string_map_copy", src_string_map, dst_string_map);
            }
            return (int)mh$.invokeExact(src_string_map, dst_string_map);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_get_zero_initialized_uint8_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcutils_uint8_array_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_get_zero_initialized_uint8_array"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_uint8_array_t rcutils_get_zero_initialized_uint8_array()
     * }
     */
    public static FunctionDescriptor rcutils_get_zero_initialized_uint8_array$descriptor() {
        return rcutils_get_zero_initialized_uint8_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_uint8_array_t rcutils_get_zero_initialized_uint8_array()
     * }
     */
    public static MethodHandle rcutils_get_zero_initialized_uint8_array$handle() {
        return rcutils_get_zero_initialized_uint8_array.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_uint8_array_t rcutils_get_zero_initialized_uint8_array()
     * }
     */
    public static MemorySegment rcutils_get_zero_initialized_uint8_array(SegmentAllocator allocator) {
        var mh$ = rcutils_get_zero_initialized_uint8_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_get_zero_initialized_uint8_array", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_uint8_array_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_uint8_array_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_uint8_array_init(rcutils_uint8_array_t *uint8_array, size_t buffer_capacity, const rcutils_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rcutils_uint8_array_init$descriptor() {
        return rcutils_uint8_array_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_uint8_array_init(rcutils_uint8_array_t *uint8_array, size_t buffer_capacity, const rcutils_allocator_t *allocator)
     * }
     */
    public static MethodHandle rcutils_uint8_array_init$handle() {
        return rcutils_uint8_array_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_uint8_array_init(rcutils_uint8_array_t *uint8_array, size_t buffer_capacity, const rcutils_allocator_t *allocator)
     * }
     */
    public static int rcutils_uint8_array_init(MemorySegment uint8_array, long buffer_capacity, MemorySegment allocator) {
        var mh$ = rcutils_uint8_array_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_uint8_array_init", uint8_array, buffer_capacity, allocator);
            }
            return (int)mh$.invokeExact(uint8_array, buffer_capacity, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_uint8_array_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_uint8_array_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_uint8_array_fini(rcutils_uint8_array_t *uint8_array)
     * }
     */
    public static FunctionDescriptor rcutils_uint8_array_fini$descriptor() {
        return rcutils_uint8_array_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_uint8_array_fini(rcutils_uint8_array_t *uint8_array)
     * }
     */
    public static MethodHandle rcutils_uint8_array_fini$handle() {
        return rcutils_uint8_array_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_uint8_array_fini(rcutils_uint8_array_t *uint8_array)
     * }
     */
    public static int rcutils_uint8_array_fini(MemorySegment uint8_array) {
        var mh$ = rcutils_uint8_array_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_uint8_array_fini", uint8_array);
            }
            return (int)mh$.invokeExact(uint8_array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_uint8_array_resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_uint8_array_resize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_uint8_array_resize(rcutils_uint8_array_t *uint8_array, size_t new_size)
     * }
     */
    public static FunctionDescriptor rcutils_uint8_array_resize$descriptor() {
        return rcutils_uint8_array_resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_uint8_array_resize(rcutils_uint8_array_t *uint8_array, size_t new_size)
     * }
     */
    public static MethodHandle rcutils_uint8_array_resize$handle() {
        return rcutils_uint8_array_resize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_uint8_array_resize(rcutils_uint8_array_t *uint8_array, size_t new_size)
     * }
     */
    public static int rcutils_uint8_array_resize(MemorySegment uint8_array, long new_size) {
        var mh$ = rcutils_uint8_array_resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_uint8_array_resize", uint8_array, new_size);
            }
            return (int)mh$.invokeExact(uint8_array, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int64_t rcutils_time_point_value_t
     * }
     */
    public static final OfLong rcutils_time_point_value_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t rcutils_duration_value_t
     * }
     */
    public static final OfLong rcutils_duration_value_t = gen_h.C_LONG;

    private static class rcutils_system_time_now {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_system_time_now"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_system_time_now(rcutils_time_point_value_t *now)
     * }
     */
    public static FunctionDescriptor rcutils_system_time_now$descriptor() {
        return rcutils_system_time_now.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_system_time_now(rcutils_time_point_value_t *now)
     * }
     */
    public static MethodHandle rcutils_system_time_now$handle() {
        return rcutils_system_time_now.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_system_time_now(rcutils_time_point_value_t *now)
     * }
     */
    public static int rcutils_system_time_now(MemorySegment now) {
        var mh$ = rcutils_system_time_now.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_system_time_now", now);
            }
            return (int)mh$.invokeExact(now);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_steady_time_now {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_steady_time_now"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_steady_time_now(rcutils_time_point_value_t *now)
     * }
     */
    public static FunctionDescriptor rcutils_steady_time_now$descriptor() {
        return rcutils_steady_time_now.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_steady_time_now(rcutils_time_point_value_t *now)
     * }
     */
    public static MethodHandle rcutils_steady_time_now$handle() {
        return rcutils_steady_time_now.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_steady_time_now(rcutils_time_point_value_t *now)
     * }
     */
    public static int rcutils_steady_time_now(MemorySegment now) {
        var mh$ = rcutils_steady_time_now.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_steady_time_now", now);
            }
            return (int)mh$.invokeExact(now);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_time_point_value_as_nanoseconds_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_time_point_value_as_nanoseconds_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_time_point_value_as_nanoseconds_string(const rcutils_time_point_value_t *time_point, char *str, size_t str_size)
     * }
     */
    public static FunctionDescriptor rcutils_time_point_value_as_nanoseconds_string$descriptor() {
        return rcutils_time_point_value_as_nanoseconds_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_time_point_value_as_nanoseconds_string(const rcutils_time_point_value_t *time_point, char *str, size_t str_size)
     * }
     */
    public static MethodHandle rcutils_time_point_value_as_nanoseconds_string$handle() {
        return rcutils_time_point_value_as_nanoseconds_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_time_point_value_as_nanoseconds_string(const rcutils_time_point_value_t *time_point, char *str, size_t str_size)
     * }
     */
    public static int rcutils_time_point_value_as_nanoseconds_string(MemorySegment time_point, MemorySegment str, long str_size) {
        var mh$ = rcutils_time_point_value_as_nanoseconds_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_time_point_value_as_nanoseconds_string", time_point, str, str_size);
            }
            return (int)mh$.invokeExact(time_point, str, str_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_time_point_value_as_seconds_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_time_point_value_as_seconds_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_time_point_value_as_seconds_string(const rcutils_time_point_value_t *time_point, char *str, size_t str_size)
     * }
     */
    public static FunctionDescriptor rcutils_time_point_value_as_seconds_string$descriptor() {
        return rcutils_time_point_value_as_seconds_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_time_point_value_as_seconds_string(const rcutils_time_point_value_t *time_point, char *str, size_t str_size)
     * }
     */
    public static MethodHandle rcutils_time_point_value_as_seconds_string$handle() {
        return rcutils_time_point_value_as_seconds_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_time_point_value_as_seconds_string(const rcutils_time_point_value_t *time_point, char *str, size_t str_size)
     * }
     */
    public static int rcutils_time_point_value_as_seconds_string(MemorySegment time_point, MemorySegment str, long str_size) {
        var mh$ = rcutils_time_point_value_as_seconds_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_time_point_value_as_seconds_string", time_point, str, str_size);
            }
            return (int)mh$.invokeExact(time_point, str, str_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rcutils_logging_initialized$constants {
        public static final OfBoolean LAYOUT = gen_h.C_BOOL;
        public static final MemorySegment SEGMENT = gen_h.findOrThrow("g_rcutils_logging_initialized").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern bool g_rcutils_logging_initialized
     * }
     */
    public static OfBoolean g_rcutils_logging_initialized$layout() {
        return g_rcutils_logging_initialized$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern bool g_rcutils_logging_initialized
     * }
     */
    public static MemorySegment g_rcutils_logging_initialized$segment() {
        return g_rcutils_logging_initialized$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern bool g_rcutils_logging_initialized
     * }
     */
    public static boolean g_rcutils_logging_initialized() {
        return g_rcutils_logging_initialized$constants.SEGMENT.get(g_rcutils_logging_initialized$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern bool g_rcutils_logging_initialized
     * }
     */
    public static void g_rcutils_logging_initialized(boolean varValue) {
        g_rcutils_logging_initialized$constants.SEGMENT.set(g_rcutils_logging_initialized$constants.LAYOUT, 0L, varValue);
    }

    private static class rcutils_logging_initialize_with_allocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            rcutils_allocator_s.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_initialize_with_allocator"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_initialize_with_allocator(rcutils_allocator_t allocator)
     * }
     */
    public static FunctionDescriptor rcutils_logging_initialize_with_allocator$descriptor() {
        return rcutils_logging_initialize_with_allocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_initialize_with_allocator(rcutils_allocator_t allocator)
     * }
     */
    public static MethodHandle rcutils_logging_initialize_with_allocator$handle() {
        return rcutils_logging_initialize_with_allocator.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_initialize_with_allocator(rcutils_allocator_t allocator)
     * }
     */
    public static int rcutils_logging_initialize_with_allocator(MemorySegment allocator) {
        var mh$ = rcutils_logging_initialize_with_allocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_initialize_with_allocator", allocator);
            }
            return (int)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_logging_initialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_initialize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_initialize()
     * }
     */
    public static FunctionDescriptor rcutils_logging_initialize$descriptor() {
        return rcutils_logging_initialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_initialize()
     * }
     */
    public static MethodHandle rcutils_logging_initialize$handle() {
        return rcutils_logging_initialize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_initialize()
     * }
     */
    public static int rcutils_logging_initialize() {
        var mh$ = rcutils_logging_initialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_initialize");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_logging_shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_shutdown"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_shutdown()
     * }
     */
    public static FunctionDescriptor rcutils_logging_shutdown$descriptor() {
        return rcutils_logging_shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_shutdown()
     * }
     */
    public static MethodHandle rcutils_logging_shutdown$handle() {
        return rcutils_logging_shutdown.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_shutdown()
     * }
     */
    public static int rcutils_logging_shutdown() {
        var mh$ = rcutils_logging_shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_shutdown");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RCUTILS_LOG_SEVERITY_UNSET = (int)0L;
    /**
     * {@snippet lang=c :
     * enum RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_UNSET = 0
     * }
     */
    public static int RCUTILS_LOG_SEVERITY_UNSET() {
        return RCUTILS_LOG_SEVERITY_UNSET;
    }
    private static final int RCUTILS_LOG_SEVERITY_DEBUG = (int)10L;
    /**
     * {@snippet lang=c :
     * enum RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_DEBUG = 10
     * }
     */
    public static int RCUTILS_LOG_SEVERITY_DEBUG() {
        return RCUTILS_LOG_SEVERITY_DEBUG;
    }
    private static final int RCUTILS_LOG_SEVERITY_INFO = (int)20L;
    /**
     * {@snippet lang=c :
     * enum RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_INFO = 20
     * }
     */
    public static int RCUTILS_LOG_SEVERITY_INFO() {
        return RCUTILS_LOG_SEVERITY_INFO;
    }
    private static final int RCUTILS_LOG_SEVERITY_WARN = (int)30L;
    /**
     * {@snippet lang=c :
     * enum RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_WARN = 30
     * }
     */
    public static int RCUTILS_LOG_SEVERITY_WARN() {
        return RCUTILS_LOG_SEVERITY_WARN;
    }
    private static final int RCUTILS_LOG_SEVERITY_ERROR = (int)40L;
    /**
     * {@snippet lang=c :
     * enum RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_ERROR = 40
     * }
     */
    public static int RCUTILS_LOG_SEVERITY_ERROR() {
        return RCUTILS_LOG_SEVERITY_ERROR;
    }
    private static final int RCUTILS_LOG_SEVERITY_FATAL = (int)50L;
    /**
     * {@snippet lang=c :
     * enum RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_FATAL = 50
     * }
     */
    public static int RCUTILS_LOG_SEVERITY_FATAL() {
        return RCUTILS_LOG_SEVERITY_FATAL;
    }

    private static class g_rcutils_log_severity_names$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(51, gen_h.C_POINTER);
        public static final MemorySegment SEGMENT = gen_h.findOrThrow("g_rcutils_log_severity_names").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 51 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const g_rcutils_log_severity_names[51]
     * }
     */
    public static SequenceLayout g_rcutils_log_severity_names$layout() {
        return g_rcutils_log_severity_names$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *const g_rcutils_log_severity_names[51]
     * }
     */
    public static long[] g_rcutils_log_severity_names$dimensions() {
        return g_rcutils_log_severity_names$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const g_rcutils_log_severity_names[51]
     * }
     */
    public static MemorySegment g_rcutils_log_severity_names() {
        return g_rcutils_log_severity_names$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const g_rcutils_log_severity_names[51]
     * }
     */
    public static void g_rcutils_log_severity_names(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, g_rcutils_log_severity_names$constants.SEGMENT, 0L, g_rcutils_log_severity_names$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern const char *const g_rcutils_log_severity_names[51]
     * }
     */
    public static MemorySegment g_rcutils_log_severity_names(long index0) {
        return (MemorySegment)g_rcutils_log_severity_names$constants.HANDLE.get(g_rcutils_log_severity_names$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern const char *const g_rcutils_log_severity_names[51]
     * }
     */
    public static void g_rcutils_log_severity_names(long index0, MemorySegment varValue) {
        g_rcutils_log_severity_names$constants.HANDLE.set(g_rcutils_log_severity_names$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class rcutils_logging_severity_level_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            rcutils_allocator_s.layout(),
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_severity_level_from_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_severity_level_from_string(const char *severity_string, rcutils_allocator_t allocator, int *severity)
     * }
     */
    public static FunctionDescriptor rcutils_logging_severity_level_from_string$descriptor() {
        return rcutils_logging_severity_level_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_severity_level_from_string(const char *severity_string, rcutils_allocator_t allocator, int *severity)
     * }
     */
    public static MethodHandle rcutils_logging_severity_level_from_string$handle() {
        return rcutils_logging_severity_level_from_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_severity_level_from_string(const char *severity_string, rcutils_allocator_t allocator, int *severity)
     * }
     */
    public static int rcutils_logging_severity_level_from_string(MemorySegment severity_string, MemorySegment allocator, MemorySegment severity) {
        var mh$ = rcutils_logging_severity_level_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_severity_level_from_string", severity_string, allocator, severity);
            }
            return (int)mh$.invokeExact(severity_string, allocator, severity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rcutils_logging_output_handler$constants {
        public static final AddressLayout LAYOUT = gen_h.C_POINTER;
        public static final MemorySegment SEGMENT = gen_h.findOrThrow("g_rcutils_logging_output_handler").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern rcutils_logging_output_handler_t g_rcutils_logging_output_handler
     * }
     */
    public static AddressLayout g_rcutils_logging_output_handler$layout() {
        return g_rcutils_logging_output_handler$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern rcutils_logging_output_handler_t g_rcutils_logging_output_handler
     * }
     */
    public static MemorySegment g_rcutils_logging_output_handler$segment() {
        return g_rcutils_logging_output_handler$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern rcutils_logging_output_handler_t g_rcutils_logging_output_handler
     * }
     */
    public static MemorySegment g_rcutils_logging_output_handler() {
        return g_rcutils_logging_output_handler$constants.SEGMENT.get(g_rcutils_logging_output_handler$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern rcutils_logging_output_handler_t g_rcutils_logging_output_handler
     * }
     */
    public static void g_rcutils_logging_output_handler(MemorySegment varValue) {
        g_rcutils_logging_output_handler$constants.SEGMENT.set(g_rcutils_logging_output_handler$constants.LAYOUT, 0L, varValue);
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * rcutils_logging_output_handler_t rcutils_logging_get_output_handler()
     * }
     */
    public static class rcutils_logging_get_output_handler {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gen_h.C_POINTER        );
        private static final MemorySegment ADDR = gen_h.findOrThrow("rcutils_logging_get_output_handler");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private rcutils_logging_get_output_handler(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * rcutils_logging_output_handler_t rcutils_logging_get_output_handler()
         * }
         */
        public static rcutils_logging_get_output_handler makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new rcutils_logging_get_output_handler(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("rcutils_logging_get_output_handler", x0);
                }
                return (MemorySegment)spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class rcutils_logging_set_output_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_set_output_handler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rcutils_logging_set_output_handler(rcutils_logging_output_handler_t function)
     * }
     */
    public static FunctionDescriptor rcutils_logging_set_output_handler$descriptor() {
        return rcutils_logging_set_output_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rcutils_logging_set_output_handler(rcutils_logging_output_handler_t function)
     * }
     */
    public static MethodHandle rcutils_logging_set_output_handler$handle() {
        return rcutils_logging_set_output_handler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void rcutils_logging_set_output_handler(rcutils_logging_output_handler_t function)
     * }
     */
    public static void rcutils_logging_set_output_handler(MemorySegment function) {
        var mh$ = rcutils_logging_set_output_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_set_output_handler", function);
            }
            mh$.invokeExact(function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_logging_format_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_format_message"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_format_message(const rcutils_log_location_t *location, int severity, const char *name, rcutils_time_point_value_t timestamp, const char *msg, rcutils_char_array_t *logging_output)
     * }
     */
    public static FunctionDescriptor rcutils_logging_format_message$descriptor() {
        return rcutils_logging_format_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_format_message(const rcutils_log_location_t *location, int severity, const char *name, rcutils_time_point_value_t timestamp, const char *msg, rcutils_char_array_t *logging_output)
     * }
     */
    public static MethodHandle rcutils_logging_format_message$handle() {
        return rcutils_logging_format_message.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_format_message(const rcutils_log_location_t *location, int severity, const char *name, rcutils_time_point_value_t timestamp, const char *msg, rcutils_char_array_t *logging_output)
     * }
     */
    public static int rcutils_logging_format_message(MemorySegment location, int severity, MemorySegment name, long timestamp, MemorySegment msg, MemorySegment logging_output) {
        var mh$ = rcutils_logging_format_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_format_message", location, severity, name, timestamp, msg, logging_output);
            }
            return (int)mh$.invokeExact(location, severity, name, timestamp, msg, logging_output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rcutils_logging_default_logger_level$constants {
        public static final OfInt LAYOUT = gen_h.C_INT;
        public static final MemorySegment SEGMENT = gen_h.findOrThrow("g_rcutils_logging_default_logger_level").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int g_rcutils_logging_default_logger_level
     * }
     */
    public static OfInt g_rcutils_logging_default_logger_level$layout() {
        return g_rcutils_logging_default_logger_level$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int g_rcutils_logging_default_logger_level
     * }
     */
    public static MemorySegment g_rcutils_logging_default_logger_level$segment() {
        return g_rcutils_logging_default_logger_level$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int g_rcutils_logging_default_logger_level
     * }
     */
    public static int g_rcutils_logging_default_logger_level() {
        return g_rcutils_logging_default_logger_level$constants.SEGMENT.get(g_rcutils_logging_default_logger_level$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int g_rcutils_logging_default_logger_level
     * }
     */
    public static void g_rcutils_logging_default_logger_level(int varValue) {
        g_rcutils_logging_default_logger_level$constants.SEGMENT.set(g_rcutils_logging_default_logger_level$constants.LAYOUT, 0L, varValue);
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int rcutils_logging_get_default_logger_level()
     * }
     */
    public static class rcutils_logging_get_default_logger_level {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gen_h.C_INT        );
        private static final MemorySegment ADDR = gen_h.findOrThrow("rcutils_logging_get_default_logger_level");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private rcutils_logging_get_default_logger_level(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int rcutils_logging_get_default_logger_level()
         * }
         */
        public static rcutils_logging_get_default_logger_level makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new rcutils_logging_get_default_logger_level(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("rcutils_logging_get_default_logger_level", x0);
                }
                return (int)spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class rcutils_logging_set_default_logger_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_set_default_logger_level"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rcutils_logging_set_default_logger_level(int level)
     * }
     */
    public static FunctionDescriptor rcutils_logging_set_default_logger_level$descriptor() {
        return rcutils_logging_set_default_logger_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rcutils_logging_set_default_logger_level(int level)
     * }
     */
    public static MethodHandle rcutils_logging_set_default_logger_level$handle() {
        return rcutils_logging_set_default_logger_level.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void rcutils_logging_set_default_logger_level(int level)
     * }
     */
    public static void rcutils_logging_set_default_logger_level(int level) {
        var mh$ = rcutils_logging_set_default_logger_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_set_default_logger_level", level);
            }
            mh$.invokeExact(level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_logging_get_logger_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_get_logger_level"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcutils_logging_get_logger_level(const char *name)
     * }
     */
    public static FunctionDescriptor rcutils_logging_get_logger_level$descriptor() {
        return rcutils_logging_get_logger_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcutils_logging_get_logger_level(const char *name)
     * }
     */
    public static MethodHandle rcutils_logging_get_logger_level$handle() {
        return rcutils_logging_get_logger_level.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int rcutils_logging_get_logger_level(const char *name)
     * }
     */
    public static int rcutils_logging_get_logger_level(MemorySegment name) {
        var mh$ = rcutils_logging_get_logger_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_get_logger_level", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_logging_get_logger_leveln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_get_logger_leveln"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcutils_logging_get_logger_leveln(const char *name, size_t name_length)
     * }
     */
    public static FunctionDescriptor rcutils_logging_get_logger_leveln$descriptor() {
        return rcutils_logging_get_logger_leveln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcutils_logging_get_logger_leveln(const char *name, size_t name_length)
     * }
     */
    public static MethodHandle rcutils_logging_get_logger_leveln$handle() {
        return rcutils_logging_get_logger_leveln.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int rcutils_logging_get_logger_leveln(const char *name, size_t name_length)
     * }
     */
    public static int rcutils_logging_get_logger_leveln(MemorySegment name, long name_length) {
        var mh$ = rcutils_logging_get_logger_leveln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_get_logger_leveln", name, name_length);
            }
            return (int)mh$.invokeExact(name, name_length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_logging_set_logger_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_set_logger_level"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_set_logger_level(const char *name, int level)
     * }
     */
    public static FunctionDescriptor rcutils_logging_set_logger_level$descriptor() {
        return rcutils_logging_set_logger_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_set_logger_level(const char *name, int level)
     * }
     */
    public static MethodHandle rcutils_logging_set_logger_level$handle() {
        return rcutils_logging_set_logger_level.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcutils_ret_t rcutils_logging_set_logger_level(const char *name, int level)
     * }
     */
    public static int rcutils_logging_set_logger_level(MemorySegment name, int level) {
        var mh$ = rcutils_logging_set_logger_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_set_logger_level", name, level);
            }
            return (int)mh$.invokeExact(name, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_logging_logger_is_enabled_for {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_logger_is_enabled_for"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcutils_logging_logger_is_enabled_for(const char *name, int severity)
     * }
     */
    public static FunctionDescriptor rcutils_logging_logger_is_enabled_for$descriptor() {
        return rcutils_logging_logger_is_enabled_for.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcutils_logging_logger_is_enabled_for(const char *name, int severity)
     * }
     */
    public static MethodHandle rcutils_logging_logger_is_enabled_for$handle() {
        return rcutils_logging_logger_is_enabled_for.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcutils_logging_logger_is_enabled_for(const char *name, int severity)
     * }
     */
    public static boolean rcutils_logging_logger_is_enabled_for(MemorySegment name, int severity) {
        var mh$ = rcutils_logging_logger_is_enabled_for.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_logger_is_enabled_for", name, severity);
            }
            return (boolean)mh$.invokeExact(name, severity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcutils_logging_get_logger_effective_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_get_logger_effective_level"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcutils_logging_get_logger_effective_level(const char *name)
     * }
     */
    public static FunctionDescriptor rcutils_logging_get_logger_effective_level$descriptor() {
        return rcutils_logging_get_logger_effective_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcutils_logging_get_logger_effective_level(const char *name)
     * }
     */
    public static MethodHandle rcutils_logging_get_logger_effective_level$handle() {
        return rcutils_logging_get_logger_effective_level.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int rcutils_logging_get_logger_effective_level(const char *name)
     * }
     */
    public static int rcutils_logging_get_logger_effective_level(MemorySegment name) {
        var mh$ = rcutils_logging_get_logger_effective_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_get_logger_effective_level", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void rcutils_log(const rcutils_log_location_t *location, int severity, const char *name, const char *format, ...)
     * }
     */
    public static class rcutils_log {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gen_h.C_POINTER,
                gen_h.C_INT,
                gen_h.C_POINTER,
                gen_h.C_POINTER
            );
        private static final MemorySegment ADDR = gen_h.findOrThrow("rcutils_log");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private rcutils_log(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void rcutils_log(const rcutils_log_location_t *location, int severity, const char *name, const char *format, ...)
         * }
         */
        public static rcutils_log makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new rcutils_log(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment location, int severity, MemorySegment name, MemorySegment format, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("rcutils_log", location, severity, name, format, x4);
                }
                spreader.invokeExact(location, severity, name, format, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class rcutils_logging_console_output_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gen_h.C_POINTER,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcutils_logging_console_output_handler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rcutils_logging_console_output_handler(const rcutils_log_location_t *location, int severity, const char *name, rcutils_time_point_value_t timestamp, const char *format, va_list *args)
     * }
     */
    public static FunctionDescriptor rcutils_logging_console_output_handler$descriptor() {
        return rcutils_logging_console_output_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rcutils_logging_console_output_handler(const rcutils_log_location_t *location, int severity, const char *name, rcutils_time_point_value_t timestamp, const char *format, va_list *args)
     * }
     */
    public static MethodHandle rcutils_logging_console_output_handler$handle() {
        return rcutils_logging_console_output_handler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void rcutils_logging_console_output_handler(const rcutils_log_location_t *location, int severity, const char *name, rcutils_time_point_value_t timestamp, const char *format, va_list *args)
     * }
     */
    public static void rcutils_logging_console_output_handler(MemorySegment location, int severity, MemorySegment name, long timestamp, MemorySegment format, MemorySegment args) {
        var mh$ = rcutils_logging_console_output_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcutils_logging_console_output_handler", location, severity, name, timestamp, format, args);
            }
            mh$.invokeExact(location, severity, name, timestamp, format, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RMW_QOS_POLICY_INVALID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_policy_kind_e.RMW_QOS_POLICY_INVALID = 1
     * }
     */
    public static int RMW_QOS_POLICY_INVALID() {
        return RMW_QOS_POLICY_INVALID;
    }
    private static final int RMW_QOS_POLICY_DURABILITY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_policy_kind_e.RMW_QOS_POLICY_DURABILITY = 2
     * }
     */
    public static int RMW_QOS_POLICY_DURABILITY() {
        return RMW_QOS_POLICY_DURABILITY;
    }
    private static final int RMW_QOS_POLICY_DEADLINE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_policy_kind_e.RMW_QOS_POLICY_DEADLINE = 4
     * }
     */
    public static int RMW_QOS_POLICY_DEADLINE() {
        return RMW_QOS_POLICY_DEADLINE;
    }
    private static final int RMW_QOS_POLICY_LIVELINESS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_policy_kind_e.RMW_QOS_POLICY_LIVELINESS = 8
     * }
     */
    public static int RMW_QOS_POLICY_LIVELINESS() {
        return RMW_QOS_POLICY_LIVELINESS;
    }
    private static final int RMW_QOS_POLICY_RELIABILITY = (int)16L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_policy_kind_e.RMW_QOS_POLICY_RELIABILITY = 16
     * }
     */
    public static int RMW_QOS_POLICY_RELIABILITY() {
        return RMW_QOS_POLICY_RELIABILITY;
    }
    private static final int RMW_QOS_POLICY_HISTORY = (int)32L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_policy_kind_e.RMW_QOS_POLICY_HISTORY = 32
     * }
     */
    public static int RMW_QOS_POLICY_HISTORY() {
        return RMW_QOS_POLICY_HISTORY;
    }
    private static final int RMW_QOS_POLICY_LIFESPAN = (int)64L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_policy_kind_e.RMW_QOS_POLICY_LIFESPAN = 64
     * }
     */
    public static int RMW_QOS_POLICY_LIFESPAN() {
        return RMW_QOS_POLICY_LIFESPAN;
    }
    private static final int RMW_QOS_POLICY_DEPTH = (int)128L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_policy_kind_e.RMW_QOS_POLICY_DEPTH = 128
     * }
     */
    public static int RMW_QOS_POLICY_DEPTH() {
        return RMW_QOS_POLICY_DEPTH;
    }
    private static final int RMW_QOS_POLICY_LIVELINESS_LEASE_DURATION = (int)256L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_policy_kind_e.RMW_QOS_POLICY_LIVELINESS_LEASE_DURATION = 256
     * }
     */
    public static int RMW_QOS_POLICY_LIVELINESS_LEASE_DURATION() {
        return RMW_QOS_POLICY_LIVELINESS_LEASE_DURATION;
    }
    private static final int RMW_QOS_POLICY_AVOID_ROS_NAMESPACE_CONVENTIONS = (int)512L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_policy_kind_e.RMW_QOS_POLICY_AVOID_ROS_NAMESPACE_CONVENTIONS = 512
     * }
     */
    public static int RMW_QOS_POLICY_AVOID_ROS_NAMESPACE_CONVENTIONS() {
        return RMW_QOS_POLICY_AVOID_ROS_NAMESPACE_CONVENTIONS;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * rmw_subscription_content_filter_options_t rmw_get_zero_initialized_content_filter_options()
     * }
     */
    public static class rmw_get_zero_initialized_content_filter_options {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                rmw_subscription_content_filter_options_s.layout()        );
        private static final MemorySegment ADDR = gen_h.findOrThrow("rmw_get_zero_initialized_content_filter_options");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private rmw_get_zero_initialized_content_filter_options(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * rmw_subscription_content_filter_options_t rmw_get_zero_initialized_content_filter_options()
         * }
         */
        public static rmw_get_zero_initialized_content_filter_options makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new rmw_get_zero_initialized_content_filter_options(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("rmw_get_zero_initialized_content_filter_options", allocator, x0);
                }
                return (MemorySegment)spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class rmw_subscription_content_filter_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_subscription_content_filter_options_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_init(const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], const rcutils_allocator_t *allocator, rmw_subscription_content_filter_options_t *options)
     * }
     */
    public static FunctionDescriptor rmw_subscription_content_filter_options_init$descriptor() {
        return rmw_subscription_content_filter_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_init(const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], const rcutils_allocator_t *allocator, rmw_subscription_content_filter_options_t *options)
     * }
     */
    public static MethodHandle rmw_subscription_content_filter_options_init$handle() {
        return rmw_subscription_content_filter_options_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_init(const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], const rcutils_allocator_t *allocator, rmw_subscription_content_filter_options_t *options)
     * }
     */
    public static int rmw_subscription_content_filter_options_init(MemorySegment filter_expression, long expression_parameters_argc, MemorySegment expression_parameter_argv, MemorySegment allocator, MemorySegment options) {
        var mh$ = rmw_subscription_content_filter_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_subscription_content_filter_options_init", filter_expression, expression_parameters_argc, expression_parameter_argv, allocator, options);
            }
            return (int)mh$.invokeExact(filter_expression, expression_parameters_argc, expression_parameter_argv, allocator, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_subscription_content_filter_options_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_subscription_content_filter_options_set"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_set(const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], const rcutils_allocator_t *allocator, rmw_subscription_content_filter_options_t *options)
     * }
     */
    public static FunctionDescriptor rmw_subscription_content_filter_options_set$descriptor() {
        return rmw_subscription_content_filter_options_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_set(const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], const rcutils_allocator_t *allocator, rmw_subscription_content_filter_options_t *options)
     * }
     */
    public static MethodHandle rmw_subscription_content_filter_options_set$handle() {
        return rmw_subscription_content_filter_options_set.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_set(const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], const rcutils_allocator_t *allocator, rmw_subscription_content_filter_options_t *options)
     * }
     */
    public static int rmw_subscription_content_filter_options_set(MemorySegment filter_expression, long expression_parameters_argc, MemorySegment expression_parameter_argv, MemorySegment allocator, MemorySegment options) {
        var mh$ = rmw_subscription_content_filter_options_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_subscription_content_filter_options_set", filter_expression, expression_parameters_argc, expression_parameter_argv, allocator, options);
            }
            return (int)mh$.invokeExact(filter_expression, expression_parameters_argc, expression_parameter_argv, allocator, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_subscription_content_filter_options_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_subscription_content_filter_options_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_copy(const rmw_subscription_content_filter_options_t *src, const rcutils_allocator_t *allocator, rmw_subscription_content_filter_options_t *dst)
     * }
     */
    public static FunctionDescriptor rmw_subscription_content_filter_options_copy$descriptor() {
        return rmw_subscription_content_filter_options_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_copy(const rmw_subscription_content_filter_options_t *src, const rcutils_allocator_t *allocator, rmw_subscription_content_filter_options_t *dst)
     * }
     */
    public static MethodHandle rmw_subscription_content_filter_options_copy$handle() {
        return rmw_subscription_content_filter_options_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_copy(const rmw_subscription_content_filter_options_t *src, const rcutils_allocator_t *allocator, rmw_subscription_content_filter_options_t *dst)
     * }
     */
    public static int rmw_subscription_content_filter_options_copy(MemorySegment src, MemorySegment allocator, MemorySegment dst) {
        var mh$ = rmw_subscription_content_filter_options_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_subscription_content_filter_options_copy", src, allocator, dst);
            }
            return (int)mh$.invokeExact(src, allocator, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_subscription_content_filter_options_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_subscription_content_filter_options_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_fini(rmw_subscription_content_filter_options_t *options, const rcutils_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rmw_subscription_content_filter_options_fini$descriptor() {
        return rmw_subscription_content_filter_options_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_fini(rmw_subscription_content_filter_options_t *options, const rcutils_allocator_t *allocator)
     * }
     */
    public static MethodHandle rmw_subscription_content_filter_options_fini$handle() {
        return rmw_subscription_content_filter_options_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_content_filter_options_fini(rmw_subscription_content_filter_options_t *options, const rcutils_allocator_t *allocator)
     * }
     */
    public static int rmw_subscription_content_filter_options_fini(MemorySegment options, MemorySegment allocator) {
        var mh$ = rmw_subscription_content_filter_options_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_subscription_content_filter_options_fini", options, allocator);
            }
            return (int)mh$.invokeExact(options, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef rcutils_time_point_value_t rmw_time_point_value_t
     * }
     */
    public static final OfLong rmw_time_point_value_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef rcutils_duration_value_t rmw_duration_t
     * }
     */
    public static final OfLong rmw_duration_t = gen_h.C_LONG;

    private static class rmw_time_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            rmw_time_s.layout(),
            rmw_time_s.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_time_equal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rmw_time_equal(const rmw_time_t left, const rmw_time_t right)
     * }
     */
    public static FunctionDescriptor rmw_time_equal$descriptor() {
        return rmw_time_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rmw_time_equal(const rmw_time_t left, const rmw_time_t right)
     * }
     */
    public static MethodHandle rmw_time_equal$handle() {
        return rmw_time_equal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rmw_time_equal(const rmw_time_t left, const rmw_time_t right)
     * }
     */
    public static boolean rmw_time_equal(MemorySegment left, MemorySegment right) {
        var mh$ = rmw_time_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_time_equal", left, right);
            }
            return (boolean)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_time_total_nsec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            rmw_time_s.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_time_total_nsec"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_duration_t rmw_time_total_nsec(const rmw_time_t time)
     * }
     */
    public static FunctionDescriptor rmw_time_total_nsec$descriptor() {
        return rmw_time_total_nsec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_duration_t rmw_time_total_nsec(const rmw_time_t time)
     * }
     */
    public static MethodHandle rmw_time_total_nsec$handle() {
        return rmw_time_total_nsec.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_duration_t rmw_time_total_nsec(const rmw_time_t time)
     * }
     */
    public static long rmw_time_total_nsec(MemorySegment time) {
        var mh$ = rmw_time_total_nsec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_time_total_nsec", time);
            }
            return (long)mh$.invokeExact(time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_time_from_nsec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rmw_time_s.layout(),
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_time_from_nsec"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_time_t rmw_time_from_nsec(const rmw_duration_t nanoseconds)
     * }
     */
    public static FunctionDescriptor rmw_time_from_nsec$descriptor() {
        return rmw_time_from_nsec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_time_t rmw_time_from_nsec(const rmw_duration_t nanoseconds)
     * }
     */
    public static MethodHandle rmw_time_from_nsec$handle() {
        return rmw_time_from_nsec.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_time_t rmw_time_from_nsec(const rmw_duration_t nanoseconds)
     * }
     */
    public static MemorySegment rmw_time_from_nsec(SegmentAllocator allocator, long nanoseconds) {
        var mh$ = rmw_time_from_nsec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_time_from_nsec", allocator, nanoseconds);
            }
            return (MemorySegment)mh$.invokeExact(allocator, nanoseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_time_normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rmw_time_s.layout(),
            rmw_time_s.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_time_normalize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_time_t rmw_time_normalize(const rmw_time_t time)
     * }
     */
    public static FunctionDescriptor rmw_time_normalize$descriptor() {
        return rmw_time_normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_time_t rmw_time_normalize(const rmw_time_t time)
     * }
     */
    public static MethodHandle rmw_time_normalize$handle() {
        return rmw_time_normalize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_time_t rmw_time_normalize(const rmw_time_t time)
     * }
     */
    public static MemorySegment rmw_time_normalize(SegmentAllocator allocator, MemorySegment time) {
        var mh$ = rmw_time_normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_time_normalize", allocator, time);
            }
            return (MemorySegment)mh$.invokeExact(allocator, time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RMW_ENDPOINT_INVALID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rmw_endpoint_type_e.RMW_ENDPOINT_INVALID = 0
     * }
     */
    public static int RMW_ENDPOINT_INVALID() {
        return RMW_ENDPOINT_INVALID;
    }
    private static final int RMW_ENDPOINT_PUBLISHER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rmw_endpoint_type_e.RMW_ENDPOINT_PUBLISHER = 1
     * }
     */
    public static int RMW_ENDPOINT_PUBLISHER() {
        return RMW_ENDPOINT_PUBLISHER;
    }
    private static final int RMW_ENDPOINT_SUBSCRIPTION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rmw_endpoint_type_e.RMW_ENDPOINT_SUBSCRIPTION = 2
     * }
     */
    public static int RMW_ENDPOINT_SUBSCRIPTION() {
        return RMW_ENDPOINT_SUBSCRIPTION;
    }
    private static final int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rmw_unique_network_flow_endpoints_requirement_e.RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED = 0
     * }
     */
    public static int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED() {
        return RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED;
    }
    private static final int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rmw_unique_network_flow_endpoints_requirement_e.RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED = 1
     * }
     */
    public static int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED() {
        return RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED;
    }
    private static final int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rmw_unique_network_flow_endpoints_requirement_e.RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED = 2
     * }
     */
    public static int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED() {
        return RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED;
    }
    private static final int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum rmw_unique_network_flow_endpoints_requirement_e.RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT = 3
     * }
     */
    public static int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT() {
        return RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT;
    }
    private static final int RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_reliability_policy_e.RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT = 0
     * }
     */
    public static int RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT() {
        return RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT;
    }
    private static final int RMW_QOS_POLICY_RELIABILITY_RELIABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_reliability_policy_e.RMW_QOS_POLICY_RELIABILITY_RELIABLE = 1
     * }
     */
    public static int RMW_QOS_POLICY_RELIABILITY_RELIABLE() {
        return RMW_QOS_POLICY_RELIABILITY_RELIABLE;
    }
    private static final int RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_reliability_policy_e.RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT = 2
     * }
     */
    public static int RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT() {
        return RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT;
    }
    private static final int RMW_QOS_POLICY_RELIABILITY_UNKNOWN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_reliability_policy_e.RMW_QOS_POLICY_RELIABILITY_UNKNOWN = 3
     * }
     */
    public static int RMW_QOS_POLICY_RELIABILITY_UNKNOWN() {
        return RMW_QOS_POLICY_RELIABILITY_UNKNOWN;
    }
    private static final int RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_history_policy_e.RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT = 0
     * }
     */
    public static int RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT() {
        return RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT;
    }
    private static final int RMW_QOS_POLICY_HISTORY_KEEP_LAST = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_history_policy_e.RMW_QOS_POLICY_HISTORY_KEEP_LAST = 1
     * }
     */
    public static int RMW_QOS_POLICY_HISTORY_KEEP_LAST() {
        return RMW_QOS_POLICY_HISTORY_KEEP_LAST;
    }
    private static final int RMW_QOS_POLICY_HISTORY_KEEP_ALL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_history_policy_e.RMW_QOS_POLICY_HISTORY_KEEP_ALL = 2
     * }
     */
    public static int RMW_QOS_POLICY_HISTORY_KEEP_ALL() {
        return RMW_QOS_POLICY_HISTORY_KEEP_ALL;
    }
    private static final int RMW_QOS_POLICY_HISTORY_UNKNOWN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_history_policy_e.RMW_QOS_POLICY_HISTORY_UNKNOWN = 3
     * }
     */
    public static int RMW_QOS_POLICY_HISTORY_UNKNOWN() {
        return RMW_QOS_POLICY_HISTORY_UNKNOWN;
    }
    private static final int RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_durability_policy_e.RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT = 0
     * }
     */
    public static int RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT() {
        return RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT;
    }
    private static final int RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_durability_policy_e.RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL = 1
     * }
     */
    public static int RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL() {
        return RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL;
    }
    private static final int RMW_QOS_POLICY_DURABILITY_VOLATILE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_durability_policy_e.RMW_QOS_POLICY_DURABILITY_VOLATILE = 2
     * }
     */
    public static int RMW_QOS_POLICY_DURABILITY_VOLATILE() {
        return RMW_QOS_POLICY_DURABILITY_VOLATILE;
    }
    private static final int RMW_QOS_POLICY_DURABILITY_UNKNOWN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_durability_policy_e.RMW_QOS_POLICY_DURABILITY_UNKNOWN = 3
     * }
     */
    public static int RMW_QOS_POLICY_DURABILITY_UNKNOWN() {
        return RMW_QOS_POLICY_DURABILITY_UNKNOWN;
    }
    private static final int RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_liveliness_policy_e.RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT = 0
     * }
     */
    public static int RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT() {
        return RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT;
    }
    private static final int RMW_QOS_POLICY_LIVELINESS_AUTOMATIC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_liveliness_policy_e.RMW_QOS_POLICY_LIVELINESS_AUTOMATIC = 1
     * }
     */
    public static int RMW_QOS_POLICY_LIVELINESS_AUTOMATIC() {
        return RMW_QOS_POLICY_LIVELINESS_AUTOMATIC;
    }
    private static final int RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_liveliness_policy_e.RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE = 2
     * }
     */
    public static int RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE() {
        return RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE;
    }
    private static final int RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_liveliness_policy_e.RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC = 3
     * }
     */
    public static int RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC() {
        return RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC;
    }
    private static final int RMW_QOS_POLICY_LIVELINESS_UNKNOWN = (int)4L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_liveliness_policy_e.RMW_QOS_POLICY_LIVELINESS_UNKNOWN = 4
     * }
     */
    public static int RMW_QOS_POLICY_LIVELINESS_UNKNOWN() {
        return RMW_QOS_POLICY_LIVELINESS_UNKNOWN;
    }

    private static class rmw_get_zero_initialized_message_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rmw_message_info_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_get_zero_initialized_message_info"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_message_info_t rmw_get_zero_initialized_message_info()
     * }
     */
    public static FunctionDescriptor rmw_get_zero_initialized_message_info$descriptor() {
        return rmw_get_zero_initialized_message_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_message_info_t rmw_get_zero_initialized_message_info()
     * }
     */
    public static MethodHandle rmw_get_zero_initialized_message_info$handle() {
        return rmw_get_zero_initialized_message_info.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_message_info_t rmw_get_zero_initialized_message_info()
     * }
     */
    public static MemorySegment rmw_get_zero_initialized_message_info(SegmentAllocator allocator) {
        var mh$ = rmw_get_zero_initialized_message_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_get_zero_initialized_message_info", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT = 0
     * }
     */
    public static int RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT() {
        return RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT;
    }
    private static final int RMW_LOG_SEVERITY_DEBUG = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RMW_LOG_SEVERITY_DEBUG = 10
     * }
     */
    public static int RMW_LOG_SEVERITY_DEBUG() {
        return RMW_LOG_SEVERITY_DEBUG;
    }
    private static final int RMW_LOG_SEVERITY_INFO = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RMW_LOG_SEVERITY_INFO = 20
     * }
     */
    public static int RMW_LOG_SEVERITY_INFO() {
        return RMW_LOG_SEVERITY_INFO;
    }
    private static final int RMW_LOG_SEVERITY_WARN = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RMW_LOG_SEVERITY_WARN = 30
     * }
     */
    public static int RMW_LOG_SEVERITY_WARN() {
        return RMW_LOG_SEVERITY_WARN;
    }
    private static final int RMW_LOG_SEVERITY_ERROR = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RMW_LOG_SEVERITY_ERROR = 40
     * }
     */
    public static int RMW_LOG_SEVERITY_ERROR() {
        return RMW_LOG_SEVERITY_ERROR;
    }
    private static final int RMW_LOG_SEVERITY_FATAL = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RMW_LOG_SEVERITY_FATAL = 50
     * }
     */
    public static int RMW_LOG_SEVERITY_FATAL() {
        return RMW_LOG_SEVERITY_FATAL;
    }
    /**
     * {@snippet lang=c :
     * typedef rmw_ret_t rcl_ret_t
     * }
     */
    public static final OfInt rcl_ret_t = gen_h.C_INT;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * rcl_log_levels_t rcl_get_zero_initialized_log_levels()
     * }
     */
    public static class rcl_get_zero_initialized_log_levels {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                rcl_log_levels_s.layout()        );
        private static final MemorySegment ADDR = gen_h.findOrThrow("rcl_get_zero_initialized_log_levels");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private rcl_get_zero_initialized_log_levels(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * rcl_log_levels_t rcl_get_zero_initialized_log_levels()
         * }
         */
        public static rcl_get_zero_initialized_log_levels makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new rcl_get_zero_initialized_log_levels(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("rcl_get_zero_initialized_log_levels", allocator, x0);
                }
                return (MemorySegment)spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class rcl_log_levels_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_log_levels_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_init(rcl_log_levels_t *log_levels, const rcl_allocator_t *allocator, size_t logger_count)
     * }
     */
    public static FunctionDescriptor rcl_log_levels_init$descriptor() {
        return rcl_log_levels_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_init(rcl_log_levels_t *log_levels, const rcl_allocator_t *allocator, size_t logger_count)
     * }
     */
    public static MethodHandle rcl_log_levels_init$handle() {
        return rcl_log_levels_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_init(rcl_log_levels_t *log_levels, const rcl_allocator_t *allocator, size_t logger_count)
     * }
     */
    public static int rcl_log_levels_init(MemorySegment log_levels, MemorySegment allocator, long logger_count) {
        var mh$ = rcl_log_levels_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_log_levels_init", log_levels, allocator, logger_count);
            }
            return (int)mh$.invokeExact(log_levels, allocator, logger_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_log_levels_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_log_levels_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_copy(const rcl_log_levels_t *src, rcl_log_levels_t *dst)
     * }
     */
    public static FunctionDescriptor rcl_log_levels_copy$descriptor() {
        return rcl_log_levels_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_copy(const rcl_log_levels_t *src, rcl_log_levels_t *dst)
     * }
     */
    public static MethodHandle rcl_log_levels_copy$handle() {
        return rcl_log_levels_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_copy(const rcl_log_levels_t *src, rcl_log_levels_t *dst)
     * }
     */
    public static int rcl_log_levels_copy(MemorySegment src, MemorySegment dst) {
        var mh$ = rcl_log_levels_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_log_levels_copy", src, dst);
            }
            return (int)mh$.invokeExact(src, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_log_levels_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_log_levels_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_fini(rcl_log_levels_t *log_levels)
     * }
     */
    public static FunctionDescriptor rcl_log_levels_fini$descriptor() {
        return rcl_log_levels_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_fini(rcl_log_levels_t *log_levels)
     * }
     */
    public static MethodHandle rcl_log_levels_fini$handle() {
        return rcl_log_levels_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_fini(rcl_log_levels_t *log_levels)
     * }
     */
    public static int rcl_log_levels_fini(MemorySegment log_levels) {
        var mh$ = rcl_log_levels_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_log_levels_fini", log_levels);
            }
            return (int)mh$.invokeExact(log_levels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_log_levels_shrink_to_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_log_levels_shrink_to_size"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_shrink_to_size(rcl_log_levels_t *log_levels)
     * }
     */
    public static FunctionDescriptor rcl_log_levels_shrink_to_size$descriptor() {
        return rcl_log_levels_shrink_to_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_shrink_to_size(rcl_log_levels_t *log_levels)
     * }
     */
    public static MethodHandle rcl_log_levels_shrink_to_size$handle() {
        return rcl_log_levels_shrink_to_size.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_shrink_to_size(rcl_log_levels_t *log_levels)
     * }
     */
    public static int rcl_log_levels_shrink_to_size(MemorySegment log_levels) {
        var mh$ = rcl_log_levels_shrink_to_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_log_levels_shrink_to_size", log_levels);
            }
            return (int)mh$.invokeExact(log_levels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_log_levels_add_logger_setting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_log_levels_add_logger_setting"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_add_logger_setting(rcl_log_levels_t *log_levels, const char *logger_name, rcl_log_severity_t log_level)
     * }
     */
    public static FunctionDescriptor rcl_log_levels_add_logger_setting$descriptor() {
        return rcl_log_levels_add_logger_setting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_add_logger_setting(rcl_log_levels_t *log_levels, const char *logger_name, rcl_log_severity_t log_level)
     * }
     */
    public static MethodHandle rcl_log_levels_add_logger_setting$handle() {
        return rcl_log_levels_add_logger_setting.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_log_levels_add_logger_setting(rcl_log_levels_t *log_levels, const char *logger_name, rcl_log_severity_t log_level)
     * }
     */
    public static int rcl_log_levels_add_logger_setting(MemorySegment log_levels, MemorySegment logger_name, int log_level) {
        var mh$ = rcl_log_levels_add_logger_setting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_log_levels_add_logger_setting", log_levels, logger_name, log_level);
            }
            return (int)mh$.invokeExact(log_levels, logger_name, log_level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_get_zero_initialized_arguments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_arguments_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_zero_initialized_arguments"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_arguments_t rcl_get_zero_initialized_arguments()
     * }
     */
    public static FunctionDescriptor rcl_get_zero_initialized_arguments$descriptor() {
        return rcl_get_zero_initialized_arguments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_arguments_t rcl_get_zero_initialized_arguments()
     * }
     */
    public static MethodHandle rcl_get_zero_initialized_arguments$handle() {
        return rcl_get_zero_initialized_arguments.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_arguments_t rcl_get_zero_initialized_arguments()
     * }
     */
    public static MemorySegment rcl_get_zero_initialized_arguments(SegmentAllocator allocator) {
        var mh$ = rcl_get_zero_initialized_arguments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_zero_initialized_arguments", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_parse_arguments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER,
            rcutils_allocator_s.layout(),
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_parse_arguments"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_parse_arguments(int argc, const char *const *argv, rcl_allocator_t allocator, rcl_arguments_t *args_output)
     * }
     */
    public static FunctionDescriptor rcl_parse_arguments$descriptor() {
        return rcl_parse_arguments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_parse_arguments(int argc, const char *const *argv, rcl_allocator_t allocator, rcl_arguments_t *args_output)
     * }
     */
    public static MethodHandle rcl_parse_arguments$handle() {
        return rcl_parse_arguments.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_parse_arguments(int argc, const char *const *argv, rcl_allocator_t allocator, rcl_arguments_t *args_output)
     * }
     */
    public static int rcl_parse_arguments(int argc, MemorySegment argv, MemorySegment allocator, MemorySegment args_output) {
        var mh$ = rcl_parse_arguments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_parse_arguments", argc, argv, allocator, args_output);
            }
            return (int)mh$.invokeExact(argc, argv, allocator, args_output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_arguments_get_count_unparsed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_arguments_get_count_unparsed"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcl_arguments_get_count_unparsed(const rcl_arguments_t *args)
     * }
     */
    public static FunctionDescriptor rcl_arguments_get_count_unparsed$descriptor() {
        return rcl_arguments_get_count_unparsed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcl_arguments_get_count_unparsed(const rcl_arguments_t *args)
     * }
     */
    public static MethodHandle rcl_arguments_get_count_unparsed$handle() {
        return rcl_arguments_get_count_unparsed.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int rcl_arguments_get_count_unparsed(const rcl_arguments_t *args)
     * }
     */
    public static int rcl_arguments_get_count_unparsed(MemorySegment args) {
        var mh$ = rcl_arguments_get_count_unparsed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_arguments_get_count_unparsed", args);
            }
            return (int)mh$.invokeExact(args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_arguments_get_unparsed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            rcutils_allocator_s.layout(),
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_arguments_get_unparsed"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_unparsed(const rcl_arguments_t *args, rcl_allocator_t allocator, int **output_unparsed_indices)
     * }
     */
    public static FunctionDescriptor rcl_arguments_get_unparsed$descriptor() {
        return rcl_arguments_get_unparsed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_unparsed(const rcl_arguments_t *args, rcl_allocator_t allocator, int **output_unparsed_indices)
     * }
     */
    public static MethodHandle rcl_arguments_get_unparsed$handle() {
        return rcl_arguments_get_unparsed.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_unparsed(const rcl_arguments_t *args, rcl_allocator_t allocator, int **output_unparsed_indices)
     * }
     */
    public static int rcl_arguments_get_unparsed(MemorySegment args, MemorySegment allocator, MemorySegment output_unparsed_indices) {
        var mh$ = rcl_arguments_get_unparsed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_arguments_get_unparsed", args, allocator, output_unparsed_indices);
            }
            return (int)mh$.invokeExact(args, allocator, output_unparsed_indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_arguments_get_count_unparsed_ros {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_arguments_get_count_unparsed_ros"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcl_arguments_get_count_unparsed_ros(const rcl_arguments_t *args)
     * }
     */
    public static FunctionDescriptor rcl_arguments_get_count_unparsed_ros$descriptor() {
        return rcl_arguments_get_count_unparsed_ros.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcl_arguments_get_count_unparsed_ros(const rcl_arguments_t *args)
     * }
     */
    public static MethodHandle rcl_arguments_get_count_unparsed_ros$handle() {
        return rcl_arguments_get_count_unparsed_ros.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int rcl_arguments_get_count_unparsed_ros(const rcl_arguments_t *args)
     * }
     */
    public static int rcl_arguments_get_count_unparsed_ros(MemorySegment args) {
        var mh$ = rcl_arguments_get_count_unparsed_ros.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_arguments_get_count_unparsed_ros", args);
            }
            return (int)mh$.invokeExact(args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_arguments_get_unparsed_ros {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            rcutils_allocator_s.layout(),
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_arguments_get_unparsed_ros"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_unparsed_ros(const rcl_arguments_t *args, rcl_allocator_t allocator, int **output_unparsed_ros_indices)
     * }
     */
    public static FunctionDescriptor rcl_arguments_get_unparsed_ros$descriptor() {
        return rcl_arguments_get_unparsed_ros.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_unparsed_ros(const rcl_arguments_t *args, rcl_allocator_t allocator, int **output_unparsed_ros_indices)
     * }
     */
    public static MethodHandle rcl_arguments_get_unparsed_ros$handle() {
        return rcl_arguments_get_unparsed_ros.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_unparsed_ros(const rcl_arguments_t *args, rcl_allocator_t allocator, int **output_unparsed_ros_indices)
     * }
     */
    public static int rcl_arguments_get_unparsed_ros(MemorySegment args, MemorySegment allocator, MemorySegment output_unparsed_ros_indices) {
        var mh$ = rcl_arguments_get_unparsed_ros.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_arguments_get_unparsed_ros", args, allocator, output_unparsed_ros_indices);
            }
            return (int)mh$.invokeExact(args, allocator, output_unparsed_ros_indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_arguments_get_param_files_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_arguments_get_param_files_count"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcl_arguments_get_param_files_count(const rcl_arguments_t *args)
     * }
     */
    public static FunctionDescriptor rcl_arguments_get_param_files_count$descriptor() {
        return rcl_arguments_get_param_files_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcl_arguments_get_param_files_count(const rcl_arguments_t *args)
     * }
     */
    public static MethodHandle rcl_arguments_get_param_files_count$handle() {
        return rcl_arguments_get_param_files_count.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int rcl_arguments_get_param_files_count(const rcl_arguments_t *args)
     * }
     */
    public static int rcl_arguments_get_param_files_count(MemorySegment args) {
        var mh$ = rcl_arguments_get_param_files_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_arguments_get_param_files_count", args);
            }
            return (int)mh$.invokeExact(args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_arguments_get_param_files {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            rcutils_allocator_s.layout(),
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_arguments_get_param_files"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_param_files(const rcl_arguments_t *arguments, rcl_allocator_t allocator, char ***parameter_files)
     * }
     */
    public static FunctionDescriptor rcl_arguments_get_param_files$descriptor() {
        return rcl_arguments_get_param_files.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_param_files(const rcl_arguments_t *arguments, rcl_allocator_t allocator, char ***parameter_files)
     * }
     */
    public static MethodHandle rcl_arguments_get_param_files$handle() {
        return rcl_arguments_get_param_files.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_param_files(const rcl_arguments_t *arguments, rcl_allocator_t allocator, char ***parameter_files)
     * }
     */
    public static int rcl_arguments_get_param_files(MemorySegment arguments, MemorySegment allocator, MemorySegment parameter_files) {
        var mh$ = rcl_arguments_get_param_files.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_arguments_get_param_files", arguments, allocator, parameter_files);
            }
            return (int)mh$.invokeExact(arguments, allocator, parameter_files);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_arguments_get_param_overrides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_arguments_get_param_overrides"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_param_overrides(const rcl_arguments_t *arguments, rcl_params_t **parameter_overrides)
     * }
     */
    public static FunctionDescriptor rcl_arguments_get_param_overrides$descriptor() {
        return rcl_arguments_get_param_overrides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_param_overrides(const rcl_arguments_t *arguments, rcl_params_t **parameter_overrides)
     * }
     */
    public static MethodHandle rcl_arguments_get_param_overrides$handle() {
        return rcl_arguments_get_param_overrides.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_param_overrides(const rcl_arguments_t *arguments, rcl_params_t **parameter_overrides)
     * }
     */
    public static int rcl_arguments_get_param_overrides(MemorySegment arguments, MemorySegment parameter_overrides) {
        var mh$ = rcl_arguments_get_param_overrides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_arguments_get_param_overrides", arguments, parameter_overrides);
            }
            return (int)mh$.invokeExact(arguments, parameter_overrides);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_remove_ros_arguments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            rcutils_allocator_s.layout(),
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_remove_ros_arguments"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_remove_ros_arguments(const char *const *argv, const rcl_arguments_t *args, rcl_allocator_t allocator, int *nonros_argc, const char ***nonros_argv)
     * }
     */
    public static FunctionDescriptor rcl_remove_ros_arguments$descriptor() {
        return rcl_remove_ros_arguments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_remove_ros_arguments(const char *const *argv, const rcl_arguments_t *args, rcl_allocator_t allocator, int *nonros_argc, const char ***nonros_argv)
     * }
     */
    public static MethodHandle rcl_remove_ros_arguments$handle() {
        return rcl_remove_ros_arguments.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_remove_ros_arguments(const char *const *argv, const rcl_arguments_t *args, rcl_allocator_t allocator, int *nonros_argc, const char ***nonros_argv)
     * }
     */
    public static int rcl_remove_ros_arguments(MemorySegment argv, MemorySegment args, MemorySegment allocator, MemorySegment nonros_argc, MemorySegment nonros_argv) {
        var mh$ = rcl_remove_ros_arguments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_remove_ros_arguments", argv, args, allocator, nonros_argc, nonros_argv);
            }
            return (int)mh$.invokeExact(argv, args, allocator, nonros_argc, nonros_argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_arguments_get_log_levels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_arguments_get_log_levels"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_log_levels(const rcl_arguments_t *arguments, rcl_log_levels_t *log_levels)
     * }
     */
    public static FunctionDescriptor rcl_arguments_get_log_levels$descriptor() {
        return rcl_arguments_get_log_levels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_log_levels(const rcl_arguments_t *arguments, rcl_log_levels_t *log_levels)
     * }
     */
    public static MethodHandle rcl_arguments_get_log_levels$handle() {
        return rcl_arguments_get_log_levels.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_get_log_levels(const rcl_arguments_t *arguments, rcl_log_levels_t *log_levels)
     * }
     */
    public static int rcl_arguments_get_log_levels(MemorySegment arguments, MemorySegment log_levels) {
        var mh$ = rcl_arguments_get_log_levels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_arguments_get_log_levels", arguments, log_levels);
            }
            return (int)mh$.invokeExact(arguments, log_levels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_arguments_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_arguments_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_copy(const rcl_arguments_t *args, rcl_arguments_t *args_out)
     * }
     */
    public static FunctionDescriptor rcl_arguments_copy$descriptor() {
        return rcl_arguments_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_copy(const rcl_arguments_t *args, rcl_arguments_t *args_out)
     * }
     */
    public static MethodHandle rcl_arguments_copy$handle() {
        return rcl_arguments_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_copy(const rcl_arguments_t *args, rcl_arguments_t *args_out)
     * }
     */
    public static int rcl_arguments_copy(MemorySegment args, MemorySegment args_out) {
        var mh$ = rcl_arguments_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_arguments_copy", args, args_out);
            }
            return (int)mh$.invokeExact(args, args_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_arguments_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_arguments_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_fini(rcl_arguments_t *args)
     * }
     */
    public static FunctionDescriptor rcl_arguments_fini$descriptor() {
        return rcl_arguments_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_fini(rcl_arguments_t *args)
     * }
     */
    public static MethodHandle rcl_arguments_fini$handle() {
        return rcl_arguments_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_arguments_fini(rcl_arguments_t *args)
     * }
     */
    public static int rcl_arguments_fini(MemorySegment args) {
        var mh$ = rcl_arguments_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_arguments_fini", args);
            }
            return (int)mh$.invokeExact(args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_get_zero_initialized_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_init_options_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_zero_initialized_init_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_init_options_t rcl_get_zero_initialized_init_options()
     * }
     */
    public static FunctionDescriptor rcl_get_zero_initialized_init_options$descriptor() {
        return rcl_get_zero_initialized_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_init_options_t rcl_get_zero_initialized_init_options()
     * }
     */
    public static MethodHandle rcl_get_zero_initialized_init_options$handle() {
        return rcl_get_zero_initialized_init_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_init_options_t rcl_get_zero_initialized_init_options()
     * }
     */
    public static MemorySegment rcl_get_zero_initialized_init_options(SegmentAllocator allocator) {
        var mh$ = rcl_get_zero_initialized_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_zero_initialized_init_options", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_init_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            rcutils_allocator_s.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_init_options_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_init(rcl_init_options_t *init_options, rcl_allocator_t allocator)
     * }
     */
    public static FunctionDescriptor rcl_init_options_init$descriptor() {
        return rcl_init_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_init(rcl_init_options_t *init_options, rcl_allocator_t allocator)
     * }
     */
    public static MethodHandle rcl_init_options_init$handle() {
        return rcl_init_options_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_init(rcl_init_options_t *init_options, rcl_allocator_t allocator)
     * }
     */
    public static int rcl_init_options_init(MemorySegment init_options, MemorySegment allocator) {
        var mh$ = rcl_init_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_init_options_init", init_options, allocator);
            }
            return (int)mh$.invokeExact(init_options, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_init_options_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_init_options_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_copy(const rcl_init_options_t *src, rcl_init_options_t *dst)
     * }
     */
    public static FunctionDescriptor rcl_init_options_copy$descriptor() {
        return rcl_init_options_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_copy(const rcl_init_options_t *src, rcl_init_options_t *dst)
     * }
     */
    public static MethodHandle rcl_init_options_copy$handle() {
        return rcl_init_options_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_copy(const rcl_init_options_t *src, rcl_init_options_t *dst)
     * }
     */
    public static int rcl_init_options_copy(MemorySegment src, MemorySegment dst) {
        var mh$ = rcl_init_options_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_init_options_copy", src, dst);
            }
            return (int)mh$.invokeExact(src, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_init_options_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_init_options_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_fini(rcl_init_options_t *init_options)
     * }
     */
    public static FunctionDescriptor rcl_init_options_fini$descriptor() {
        return rcl_init_options_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_fini(rcl_init_options_t *init_options)
     * }
     */
    public static MethodHandle rcl_init_options_fini$handle() {
        return rcl_init_options_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_fini(rcl_init_options_t *init_options)
     * }
     */
    public static int rcl_init_options_fini(MemorySegment init_options) {
        var mh$ = rcl_init_options_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_init_options_fini", init_options);
            }
            return (int)mh$.invokeExact(init_options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_init_options_get_domain_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_init_options_get_domain_id"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_get_domain_id(const rcl_init_options_t *init_options, size_t *domain_id)
     * }
     */
    public static FunctionDescriptor rcl_init_options_get_domain_id$descriptor() {
        return rcl_init_options_get_domain_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_get_domain_id(const rcl_init_options_t *init_options, size_t *domain_id)
     * }
     */
    public static MethodHandle rcl_init_options_get_domain_id$handle() {
        return rcl_init_options_get_domain_id.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_get_domain_id(const rcl_init_options_t *init_options, size_t *domain_id)
     * }
     */
    public static int rcl_init_options_get_domain_id(MemorySegment init_options, MemorySegment domain_id) {
        var mh$ = rcl_init_options_get_domain_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_init_options_get_domain_id", init_options, domain_id);
            }
            return (int)mh$.invokeExact(init_options, domain_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_init_options_set_domain_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_init_options_set_domain_id"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_set_domain_id(rcl_init_options_t *init_options, size_t domain_id)
     * }
     */
    public static FunctionDescriptor rcl_init_options_set_domain_id$descriptor() {
        return rcl_init_options_set_domain_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_set_domain_id(rcl_init_options_t *init_options, size_t domain_id)
     * }
     */
    public static MethodHandle rcl_init_options_set_domain_id$handle() {
        return rcl_init_options_set_domain_id.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_init_options_set_domain_id(rcl_init_options_t *init_options, size_t domain_id)
     * }
     */
    public static int rcl_init_options_set_domain_id(MemorySegment init_options, long domain_id) {
        var mh$ = rcl_init_options_set_domain_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_init_options_set_domain_id", init_options, domain_id);
            }
            return (int)mh$.invokeExact(init_options, domain_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_init_options_get_rmw_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_init_options_get_rmw_init_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_init_options_t *rcl_init_options_get_rmw_init_options(rcl_init_options_t *init_options)
     * }
     */
    public static FunctionDescriptor rcl_init_options_get_rmw_init_options$descriptor() {
        return rcl_init_options_get_rmw_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_init_options_t *rcl_init_options_get_rmw_init_options(rcl_init_options_t *init_options)
     * }
     */
    public static MethodHandle rcl_init_options_get_rmw_init_options$handle() {
        return rcl_init_options_get_rmw_init_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_init_options_t *rcl_init_options_get_rmw_init_options(rcl_init_options_t *init_options)
     * }
     */
    public static MemorySegment rcl_init_options_get_rmw_init_options(MemorySegment init_options) {
        var mh$ = rcl_init_options_get_rmw_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_init_options_get_rmw_init_options", init_options);
            }
            return (MemorySegment)mh$.invokeExact(init_options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_init_options_get_allocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_init_options_get_allocator"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rcl_allocator_t *rcl_init_options_get_allocator(const rcl_init_options_t *init_options)
     * }
     */
    public static FunctionDescriptor rcl_init_options_get_allocator$descriptor() {
        return rcl_init_options_get_allocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rcl_allocator_t *rcl_init_options_get_allocator(const rcl_init_options_t *init_options)
     * }
     */
    public static MethodHandle rcl_init_options_get_allocator$handle() {
        return rcl_init_options_get_allocator.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rcl_allocator_t *rcl_init_options_get_allocator(const rcl_init_options_t *init_options)
     * }
     */
    public static MemorySegment rcl_init_options_get_allocator(MemorySegment init_options) {
        var mh$ = rcl_init_options_get_allocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_init_options_get_allocator", init_options);
            }
            return (MemorySegment)mh$.invokeExact(init_options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint64_t rcl_context_instance_id_t
     * }
     */
    public static final OfLong rcl_context_instance_id_t = gen_h.C_LONG;

    private static class rcl_get_zero_initialized_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_context_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_zero_initialized_context"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_context_t rcl_get_zero_initialized_context()
     * }
     */
    public static FunctionDescriptor rcl_get_zero_initialized_context$descriptor() {
        return rcl_get_zero_initialized_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_context_t rcl_get_zero_initialized_context()
     * }
     */
    public static MethodHandle rcl_get_zero_initialized_context$handle() {
        return rcl_get_zero_initialized_context.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_context_t rcl_get_zero_initialized_context()
     * }
     */
    public static MemorySegment rcl_get_zero_initialized_context(SegmentAllocator allocator) {
        var mh$ = rcl_get_zero_initialized_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_zero_initialized_context", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_context_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_context_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_context_fini(rcl_context_t *context)
     * }
     */
    public static FunctionDescriptor rcl_context_fini$descriptor() {
        return rcl_context_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_context_fini(rcl_context_t *context)
     * }
     */
    public static MethodHandle rcl_context_fini$handle() {
        return rcl_context_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_context_fini(rcl_context_t *context)
     * }
     */
    public static int rcl_context_fini(MemorySegment context) {
        var mh$ = rcl_context_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_context_fini", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_context_get_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_context_get_init_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rcl_init_options_t *rcl_context_get_init_options(const rcl_context_t *context)
     * }
     */
    public static FunctionDescriptor rcl_context_get_init_options$descriptor() {
        return rcl_context_get_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rcl_init_options_t *rcl_context_get_init_options(const rcl_context_t *context)
     * }
     */
    public static MethodHandle rcl_context_get_init_options$handle() {
        return rcl_context_get_init_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rcl_init_options_t *rcl_context_get_init_options(const rcl_context_t *context)
     * }
     */
    public static MemorySegment rcl_context_get_init_options(MemorySegment context) {
        var mh$ = rcl_context_get_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_context_get_init_options", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_context_get_instance_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_context_get_instance_id"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_context_instance_id_t rcl_context_get_instance_id(const rcl_context_t *context)
     * }
     */
    public static FunctionDescriptor rcl_context_get_instance_id$descriptor() {
        return rcl_context_get_instance_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_context_instance_id_t rcl_context_get_instance_id(const rcl_context_t *context)
     * }
     */
    public static MethodHandle rcl_context_get_instance_id$handle() {
        return rcl_context_get_instance_id.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_context_instance_id_t rcl_context_get_instance_id(const rcl_context_t *context)
     * }
     */
    public static long rcl_context_get_instance_id(MemorySegment context) {
        var mh$ = rcl_context_get_instance_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_context_get_instance_id", context);
            }
            return (long)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_context_get_domain_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_context_get_domain_id"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_context_get_domain_id(rcl_context_t *context, size_t *domain_id)
     * }
     */
    public static FunctionDescriptor rcl_context_get_domain_id$descriptor() {
        return rcl_context_get_domain_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_context_get_domain_id(rcl_context_t *context, size_t *domain_id)
     * }
     */
    public static MethodHandle rcl_context_get_domain_id$handle() {
        return rcl_context_get_domain_id.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_context_get_domain_id(rcl_context_t *context, size_t *domain_id)
     * }
     */
    public static int rcl_context_get_domain_id(MemorySegment context, MemorySegment domain_id) {
        var mh$ = rcl_context_get_domain_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_context_get_domain_id", context, domain_id);
            }
            return (int)mh$.invokeExact(context, domain_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_context_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_context_is_valid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_context_is_valid(const rcl_context_t *context)
     * }
     */
    public static FunctionDescriptor rcl_context_is_valid$descriptor() {
        return rcl_context_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_context_is_valid(const rcl_context_t *context)
     * }
     */
    public static MethodHandle rcl_context_is_valid$handle() {
        return rcl_context_is_valid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_context_is_valid(const rcl_context_t *context)
     * }
     */
    public static boolean rcl_context_is_valid(MemorySegment context) {
        var mh$ = rcl_context_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_context_is_valid", context);
            }
            return (boolean)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_context_get_rmw_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_context_get_rmw_context"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_context_t *rcl_context_get_rmw_context(rcl_context_t *context)
     * }
     */
    public static FunctionDescriptor rcl_context_get_rmw_context$descriptor() {
        return rcl_context_get_rmw_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_context_t *rcl_context_get_rmw_context(rcl_context_t *context)
     * }
     */
    public static MethodHandle rcl_context_get_rmw_context$handle() {
        return rcl_context_get_rmw_context.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_context_t *rcl_context_get_rmw_context(rcl_context_t *context)
     * }
     */
    public static MemorySegment rcl_context_get_rmw_context(MemorySegment context) {
        var mh$ = rcl_context_get_rmw_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_context_get_rmw_context", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init(int argc, const char *const *argv, const rcl_init_options_t *options, rcl_context_t *context)
     * }
     */
    public static FunctionDescriptor rcl_init$descriptor() {
        return rcl_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_init(int argc, const char *const *argv, const rcl_init_options_t *options, rcl_context_t *context)
     * }
     */
    public static MethodHandle rcl_init$handle() {
        return rcl_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_init(int argc, const char *const *argv, const rcl_init_options_t *options, rcl_context_t *context)
     * }
     */
    public static int rcl_init(int argc, MemorySegment argv, MemorySegment options, MemorySegment context) {
        var mh$ = rcl_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_init", argc, argv, options, context);
            }
            return (int)mh$.invokeExact(argc, argv, options, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_shutdown"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_shutdown(rcl_context_t *context)
     * }
     */
    public static FunctionDescriptor rcl_shutdown$descriptor() {
        return rcl_shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_shutdown(rcl_context_t *context)
     * }
     */
    public static MethodHandle rcl_shutdown$handle() {
        return rcl_shutdown.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_shutdown(rcl_context_t *context)
     * }
     */
    public static int rcl_shutdown(MemorySegment context) {
        var mh$ = rcl_shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_shutdown", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_get_zero_initialized_guard_condition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_guard_condition_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_zero_initialized_guard_condition"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_guard_condition_t rcl_get_zero_initialized_guard_condition()
     * }
     */
    public static FunctionDescriptor rcl_get_zero_initialized_guard_condition$descriptor() {
        return rcl_get_zero_initialized_guard_condition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_guard_condition_t rcl_get_zero_initialized_guard_condition()
     * }
     */
    public static MethodHandle rcl_get_zero_initialized_guard_condition$handle() {
        return rcl_get_zero_initialized_guard_condition.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_guard_condition_t rcl_get_zero_initialized_guard_condition()
     * }
     */
    public static MemorySegment rcl_get_zero_initialized_guard_condition(SegmentAllocator allocator) {
        var mh$ = rcl_get_zero_initialized_guard_condition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_zero_initialized_guard_condition", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_guard_condition_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            rcl_guard_condition_options_s.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_guard_condition_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_guard_condition_init(rcl_guard_condition_t *guard_condition, rcl_context_t *context, const rcl_guard_condition_options_t options)
     * }
     */
    public static FunctionDescriptor rcl_guard_condition_init$descriptor() {
        return rcl_guard_condition_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_guard_condition_init(rcl_guard_condition_t *guard_condition, rcl_context_t *context, const rcl_guard_condition_options_t options)
     * }
     */
    public static MethodHandle rcl_guard_condition_init$handle() {
        return rcl_guard_condition_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_guard_condition_init(rcl_guard_condition_t *guard_condition, rcl_context_t *context, const rcl_guard_condition_options_t options)
     * }
     */
    public static int rcl_guard_condition_init(MemorySegment guard_condition, MemorySegment context, MemorySegment options) {
        var mh$ = rcl_guard_condition_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_guard_condition_init", guard_condition, context, options);
            }
            return (int)mh$.invokeExact(guard_condition, context, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_guard_condition_init_from_rmw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            rcl_guard_condition_options_s.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_guard_condition_init_from_rmw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_guard_condition_init_from_rmw(rcl_guard_condition_t *guard_condition, const rmw_guard_condition_t *rmw_guard_condition, rcl_context_t *context, const rcl_guard_condition_options_t options)
     * }
     */
    public static FunctionDescriptor rcl_guard_condition_init_from_rmw$descriptor() {
        return rcl_guard_condition_init_from_rmw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_guard_condition_init_from_rmw(rcl_guard_condition_t *guard_condition, const rmw_guard_condition_t *rmw_guard_condition, rcl_context_t *context, const rcl_guard_condition_options_t options)
     * }
     */
    public static MethodHandle rcl_guard_condition_init_from_rmw$handle() {
        return rcl_guard_condition_init_from_rmw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_guard_condition_init_from_rmw(rcl_guard_condition_t *guard_condition, const rmw_guard_condition_t *rmw_guard_condition, rcl_context_t *context, const rcl_guard_condition_options_t options)
     * }
     */
    public static int rcl_guard_condition_init_from_rmw(MemorySegment guard_condition, MemorySegment rmw_guard_condition, MemorySegment context, MemorySegment options) {
        var mh$ = rcl_guard_condition_init_from_rmw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_guard_condition_init_from_rmw", guard_condition, rmw_guard_condition, context, options);
            }
            return (int)mh$.invokeExact(guard_condition, rmw_guard_condition, context, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_guard_condition_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_guard_condition_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_guard_condition_fini(rcl_guard_condition_t *guard_condition)
     * }
     */
    public static FunctionDescriptor rcl_guard_condition_fini$descriptor() {
        return rcl_guard_condition_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_guard_condition_fini(rcl_guard_condition_t *guard_condition)
     * }
     */
    public static MethodHandle rcl_guard_condition_fini$handle() {
        return rcl_guard_condition_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_guard_condition_fini(rcl_guard_condition_t *guard_condition)
     * }
     */
    public static int rcl_guard_condition_fini(MemorySegment guard_condition) {
        var mh$ = rcl_guard_condition_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_guard_condition_fini", guard_condition);
            }
            return (int)mh$.invokeExact(guard_condition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_guard_condition_get_default_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_guard_condition_options_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_guard_condition_get_default_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_guard_condition_options_t rcl_guard_condition_get_default_options()
     * }
     */
    public static FunctionDescriptor rcl_guard_condition_get_default_options$descriptor() {
        return rcl_guard_condition_get_default_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_guard_condition_options_t rcl_guard_condition_get_default_options()
     * }
     */
    public static MethodHandle rcl_guard_condition_get_default_options$handle() {
        return rcl_guard_condition_get_default_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_guard_condition_options_t rcl_guard_condition_get_default_options()
     * }
     */
    public static MemorySegment rcl_guard_condition_get_default_options(SegmentAllocator allocator) {
        var mh$ = rcl_guard_condition_get_default_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_guard_condition_get_default_options", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_trigger_guard_condition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_trigger_guard_condition"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_trigger_guard_condition(rcl_guard_condition_t *guard_condition)
     * }
     */
    public static FunctionDescriptor rcl_trigger_guard_condition$descriptor() {
        return rcl_trigger_guard_condition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_trigger_guard_condition(rcl_guard_condition_t *guard_condition)
     * }
     */
    public static MethodHandle rcl_trigger_guard_condition$handle() {
        return rcl_trigger_guard_condition.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_trigger_guard_condition(rcl_guard_condition_t *guard_condition)
     * }
     */
    public static int rcl_trigger_guard_condition(MemorySegment guard_condition) {
        var mh$ = rcl_trigger_guard_condition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_trigger_guard_condition", guard_condition);
            }
            return (int)mh$.invokeExact(guard_condition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_guard_condition_get_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_guard_condition_get_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rcl_guard_condition_options_t *rcl_guard_condition_get_options(const rcl_guard_condition_t *guard_condition)
     * }
     */
    public static FunctionDescriptor rcl_guard_condition_get_options$descriptor() {
        return rcl_guard_condition_get_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rcl_guard_condition_options_t *rcl_guard_condition_get_options(const rcl_guard_condition_t *guard_condition)
     * }
     */
    public static MethodHandle rcl_guard_condition_get_options$handle() {
        return rcl_guard_condition_get_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rcl_guard_condition_options_t *rcl_guard_condition_get_options(const rcl_guard_condition_t *guard_condition)
     * }
     */
    public static MemorySegment rcl_guard_condition_get_options(MemorySegment guard_condition) {
        var mh$ = rcl_guard_condition_get_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_guard_condition_get_options", guard_condition);
            }
            return (MemorySegment)mh$.invokeExact(guard_condition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_guard_condition_get_rmw_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_guard_condition_get_rmw_handle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_guard_condition_t *rcl_guard_condition_get_rmw_handle(const rcl_guard_condition_t *guard_condition)
     * }
     */
    public static FunctionDescriptor rcl_guard_condition_get_rmw_handle$descriptor() {
        return rcl_guard_condition_get_rmw_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_guard_condition_t *rcl_guard_condition_get_rmw_handle(const rcl_guard_condition_t *guard_condition)
     * }
     */
    public static MethodHandle rcl_guard_condition_get_rmw_handle$handle() {
        return rcl_guard_condition_get_rmw_handle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_guard_condition_t *rcl_guard_condition_get_rmw_handle(const rcl_guard_condition_t *guard_condition)
     * }
     */
    public static MemorySegment rcl_guard_condition_get_rmw_handle(MemorySegment guard_condition) {
        var mh$ = rcl_guard_condition_get_rmw_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_guard_condition_get_rmw_handle", guard_condition);
            }
            return (MemorySegment)mh$.invokeExact(guard_condition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RCL_DOMAIN_ID_ENV_VAR$constants {
        public static final AddressLayout LAYOUT = gen_h.C_POINTER;
        public static final MemorySegment SEGMENT = gen_h.findOrThrow("RCL_DOMAIN_ID_ENV_VAR").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const RCL_DOMAIN_ID_ENV_VAR
     * }
     */
    public static AddressLayout RCL_DOMAIN_ID_ENV_VAR$layout() {
        return RCL_DOMAIN_ID_ENV_VAR$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *const RCL_DOMAIN_ID_ENV_VAR
     * }
     */
    public static MemorySegment RCL_DOMAIN_ID_ENV_VAR$segment() {
        return RCL_DOMAIN_ID_ENV_VAR$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const RCL_DOMAIN_ID_ENV_VAR
     * }
     */
    public static MemorySegment RCL_DOMAIN_ID_ENV_VAR() {
        return RCL_DOMAIN_ID_ENV_VAR$constants.SEGMENT.get(RCL_DOMAIN_ID_ENV_VAR$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const RCL_DOMAIN_ID_ENV_VAR
     * }
     */
    public static void RCL_DOMAIN_ID_ENV_VAR(MemorySegment varValue) {
        RCL_DOMAIN_ID_ENV_VAR$constants.SEGMENT.set(RCL_DOMAIN_ID_ENV_VAR$constants.LAYOUT, 0L, varValue);
    }

    private static class rcl_get_default_domain_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_default_domain_id"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_get_default_domain_id(size_t *domain_id)
     * }
     */
    public static FunctionDescriptor rcl_get_default_domain_id$descriptor() {
        return rcl_get_default_domain_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_get_default_domain_id(size_t *domain_id)
     * }
     */
    public static MethodHandle rcl_get_default_domain_id$handle() {
        return rcl_get_default_domain_id.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_get_default_domain_id(size_t *domain_id)
     * }
     */
    public static int rcl_get_default_domain_id(MemorySegment domain_id) {
        var mh$ = rcl_get_default_domain_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_default_domain_id", domain_id);
            }
            return (int)mh$.invokeExact(domain_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_get_default_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_node_options_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_get_default_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_node_options_t rcl_node_get_default_options()
     * }
     */
    public static FunctionDescriptor rcl_node_get_default_options$descriptor() {
        return rcl_node_get_default_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_node_options_t rcl_node_get_default_options()
     * }
     */
    public static MethodHandle rcl_node_get_default_options$handle() {
        return rcl_node_get_default_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_node_options_t rcl_node_get_default_options()
     * }
     */
    public static MemorySegment rcl_node_get_default_options(SegmentAllocator allocator) {
        var mh$ = rcl_node_get_default_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_get_default_options", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_options_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_options_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_options_copy(const rcl_node_options_t *options, rcl_node_options_t *options_out)
     * }
     */
    public static FunctionDescriptor rcl_node_options_copy$descriptor() {
        return rcl_node_options_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_options_copy(const rcl_node_options_t *options, rcl_node_options_t *options_out)
     * }
     */
    public static MethodHandle rcl_node_options_copy$handle() {
        return rcl_node_options_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_options_copy(const rcl_node_options_t *options, rcl_node_options_t *options_out)
     * }
     */
    public static int rcl_node_options_copy(MemorySegment options, MemorySegment options_out) {
        var mh$ = rcl_node_options_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_options_copy", options, options_out);
            }
            return (int)mh$.invokeExact(options, options_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_options_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_options_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_options_fini(rcl_node_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_node_options_fini$descriptor() {
        return rcl_node_options_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_options_fini(rcl_node_options_t *options)
     * }
     */
    public static MethodHandle rcl_node_options_fini$handle() {
        return rcl_node_options_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_options_fini(rcl_node_options_t *options)
     * }
     */
    public static int rcl_node_options_fini(MemorySegment options) {
        var mh$ = rcl_node_options_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_options_fini", options);
            }
            return (int)mh$.invokeExact(options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RCL_DISABLE_LOANED_MESSAGES_ENV_VAR$constants {
        public static final AddressLayout LAYOUT = gen_h.C_POINTER;
        public static final MemorySegment SEGMENT = gen_h.findOrThrow("RCL_DISABLE_LOANED_MESSAGES_ENV_VAR").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const RCL_DISABLE_LOANED_MESSAGES_ENV_VAR
     * }
     */
    public static AddressLayout RCL_DISABLE_LOANED_MESSAGES_ENV_VAR$layout() {
        return RCL_DISABLE_LOANED_MESSAGES_ENV_VAR$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *const RCL_DISABLE_LOANED_MESSAGES_ENV_VAR
     * }
     */
    public static MemorySegment RCL_DISABLE_LOANED_MESSAGES_ENV_VAR$segment() {
        return RCL_DISABLE_LOANED_MESSAGES_ENV_VAR$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const RCL_DISABLE_LOANED_MESSAGES_ENV_VAR
     * }
     */
    public static MemorySegment RCL_DISABLE_LOANED_MESSAGES_ENV_VAR() {
        return RCL_DISABLE_LOANED_MESSAGES_ENV_VAR$constants.SEGMENT.get(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const RCL_DISABLE_LOANED_MESSAGES_ENV_VAR
     * }
     */
    public static void RCL_DISABLE_LOANED_MESSAGES_ENV_VAR(MemorySegment varValue) {
        RCL_DISABLE_LOANED_MESSAGES_ENV_VAR$constants.SEGMENT.set(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR$constants.LAYOUT, 0L, varValue);
    }

    private static class rcl_get_zero_initialized_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_node_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_zero_initialized_node"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_node_t rcl_get_zero_initialized_node()
     * }
     */
    public static FunctionDescriptor rcl_get_zero_initialized_node$descriptor() {
        return rcl_get_zero_initialized_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_node_t rcl_get_zero_initialized_node()
     * }
     */
    public static MethodHandle rcl_get_zero_initialized_node$handle() {
        return rcl_get_zero_initialized_node.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_node_t rcl_get_zero_initialized_node()
     * }
     */
    public static MemorySegment rcl_get_zero_initialized_node(SegmentAllocator allocator) {
        var mh$ = rcl_get_zero_initialized_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_zero_initialized_node", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_init(rcl_node_t *node, const char *name, const char *namespace_, rcl_context_t *context, const rcl_node_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_node_init$descriptor() {
        return rcl_node_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_init(rcl_node_t *node, const char *name, const char *namespace_, rcl_context_t *context, const rcl_node_options_t *options)
     * }
     */
    public static MethodHandle rcl_node_init$handle() {
        return rcl_node_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_init(rcl_node_t *node, const char *name, const char *namespace_, rcl_context_t *context, const rcl_node_options_t *options)
     * }
     */
    public static int rcl_node_init(MemorySegment node, MemorySegment name, MemorySegment namespace_, MemorySegment context, MemorySegment options) {
        var mh$ = rcl_node_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_init", node, name, namespace_, context, options);
            }
            return (int)mh$.invokeExact(node, name, namespace_, context, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_fini(rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_node_fini$descriptor() {
        return rcl_node_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_fini(rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_node_fini$handle() {
        return rcl_node_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_fini(rcl_node_t *node)
     * }
     */
    public static int rcl_node_fini(MemorySegment node) {
        var mh$ = rcl_node_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_fini", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_is_valid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_node_is_valid(const rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_node_is_valid$descriptor() {
        return rcl_node_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_node_is_valid(const rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_node_is_valid$handle() {
        return rcl_node_is_valid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_node_is_valid(const rcl_node_t *node)
     * }
     */
    public static boolean rcl_node_is_valid(MemorySegment node) {
        var mh$ = rcl_node_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_is_valid", node);
            }
            return (boolean)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_is_valid_except_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_is_valid_except_context"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_node_is_valid_except_context(const rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_node_is_valid_except_context$descriptor() {
        return rcl_node_is_valid_except_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_node_is_valid_except_context(const rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_node_is_valid_except_context$handle() {
        return rcl_node_is_valid_except_context.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_node_is_valid_except_context(const rcl_node_t *node)
     * }
     */
    public static boolean rcl_node_is_valid_except_context(MemorySegment node) {
        var mh$ = rcl_node_is_valid_except_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_is_valid_except_context", node);
            }
            return (boolean)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_get_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rcl_node_get_name(const rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_node_get_name$descriptor() {
        return rcl_node_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rcl_node_get_name(const rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_node_get_name$handle() {
        return rcl_node_get_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rcl_node_get_name(const rcl_node_t *node)
     * }
     */
    public static MemorySegment rcl_node_get_name(MemorySegment node) {
        var mh$ = rcl_node_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_get_name", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_get_namespace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_get_namespace"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rcl_node_get_namespace(const rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_node_get_namespace$descriptor() {
        return rcl_node_get_namespace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rcl_node_get_namespace(const rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_node_get_namespace$handle() {
        return rcl_node_get_namespace.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rcl_node_get_namespace(const rcl_node_t *node)
     * }
     */
    public static MemorySegment rcl_node_get_namespace(MemorySegment node) {
        var mh$ = rcl_node_get_namespace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_get_namespace", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_get_fully_qualified_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_get_fully_qualified_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rcl_node_get_fully_qualified_name(const rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_node_get_fully_qualified_name$descriptor() {
        return rcl_node_get_fully_qualified_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rcl_node_get_fully_qualified_name(const rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_node_get_fully_qualified_name$handle() {
        return rcl_node_get_fully_qualified_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rcl_node_get_fully_qualified_name(const rcl_node_t *node)
     * }
     */
    public static MemorySegment rcl_node_get_fully_qualified_name(MemorySegment node) {
        var mh$ = rcl_node_get_fully_qualified_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_get_fully_qualified_name", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_get_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_get_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rcl_node_options_t *rcl_node_get_options(const rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_node_get_options$descriptor() {
        return rcl_node_get_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rcl_node_options_t *rcl_node_get_options(const rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_node_get_options$handle() {
        return rcl_node_get_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rcl_node_options_t *rcl_node_get_options(const rcl_node_t *node)
     * }
     */
    public static MemorySegment rcl_node_get_options(MemorySegment node) {
        var mh$ = rcl_node_get_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_get_options", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_get_domain_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_get_domain_id"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_get_domain_id(const rcl_node_t *node, size_t *domain_id)
     * }
     */
    public static FunctionDescriptor rcl_node_get_domain_id$descriptor() {
        return rcl_node_get_domain_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_get_domain_id(const rcl_node_t *node, size_t *domain_id)
     * }
     */
    public static MethodHandle rcl_node_get_domain_id$handle() {
        return rcl_node_get_domain_id.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_get_domain_id(const rcl_node_t *node, size_t *domain_id)
     * }
     */
    public static int rcl_node_get_domain_id(MemorySegment node, MemorySegment domain_id) {
        var mh$ = rcl_node_get_domain_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_get_domain_id", node, domain_id);
            }
            return (int)mh$.invokeExact(node, domain_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_get_rmw_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_get_rmw_handle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_node_t *rcl_node_get_rmw_handle(const rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_node_get_rmw_handle$descriptor() {
        return rcl_node_get_rmw_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_node_t *rcl_node_get_rmw_handle(const rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_node_get_rmw_handle$handle() {
        return rcl_node_get_rmw_handle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_node_t *rcl_node_get_rmw_handle(const rcl_node_t *node)
     * }
     */
    public static MemorySegment rcl_node_get_rmw_handle(MemorySegment node) {
        var mh$ = rcl_node_get_rmw_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_get_rmw_handle", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_get_rcl_instance_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_get_rcl_instance_id"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t rcl_node_get_rcl_instance_id(const rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_node_get_rcl_instance_id$descriptor() {
        return rcl_node_get_rcl_instance_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t rcl_node_get_rcl_instance_id(const rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_node_get_rcl_instance_id$handle() {
        return rcl_node_get_rcl_instance_id.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * uint64_t rcl_node_get_rcl_instance_id(const rcl_node_t *node)
     * }
     */
    public static long rcl_node_get_rcl_instance_id(MemorySegment node) {
        var mh$ = rcl_node_get_rcl_instance_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_get_rcl_instance_id", node);
            }
            return (long)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_get_graph_guard_condition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_get_graph_guard_condition"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rcl_guard_condition_t *rcl_node_get_graph_guard_condition(const rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_node_get_graph_guard_condition$descriptor() {
        return rcl_node_get_graph_guard_condition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rcl_guard_condition_t *rcl_node_get_graph_guard_condition(const rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_node_get_graph_guard_condition$handle() {
        return rcl_node_get_graph_guard_condition.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rcl_guard_condition_t *rcl_node_get_graph_guard_condition(const rcl_node_t *node)
     * }
     */
    public static MemorySegment rcl_node_get_graph_guard_condition(MemorySegment node) {
        var mh$ = rcl_node_get_graph_guard_condition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_get_graph_guard_condition", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_get_logger_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_get_logger_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rcl_node_get_logger_name(const rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_node_get_logger_name$descriptor() {
        return rcl_node_get_logger_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rcl_node_get_logger_name(const rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_node_get_logger_name$handle() {
        return rcl_node_get_logger_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rcl_node_get_logger_name(const rcl_node_t *node)
     * }
     */
    public static MemorySegment rcl_node_get_logger_name(MemorySegment node) {
        var mh$ = rcl_node_get_logger_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_get_logger_name", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_node_resolve_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            rcutils_allocator_s.layout(),
            gen_h.C_BOOL,
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_node_resolve_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_resolve_name(const rcl_node_t *node, const char *input_name, rcl_allocator_t allocator, bool is_service, bool only_expand, char **output_name)
     * }
     */
    public static FunctionDescriptor rcl_node_resolve_name$descriptor() {
        return rcl_node_resolve_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_resolve_name(const rcl_node_t *node, const char *input_name, rcl_allocator_t allocator, bool is_service, bool only_expand, char **output_name)
     * }
     */
    public static MethodHandle rcl_node_resolve_name$handle() {
        return rcl_node_resolve_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_node_resolve_name(const rcl_node_t *node, const char *input_name, rcl_allocator_t allocator, bool is_service, bool only_expand, char **output_name)
     * }
     */
    public static int rcl_node_resolve_name(MemorySegment node, MemorySegment input_name, MemorySegment allocator, boolean is_service, boolean only_expand, MemorySegment output_name) {
        var mh$ = rcl_node_resolve_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_node_resolve_name", node, input_name, allocator, is_service, only_expand, output_name);
            }
            return (int)mh$.invokeExact(node, input_name, allocator, is_service, only_expand, output_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_get_disable_loaned_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_disable_loaned_message"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_get_disable_loaned_message(bool *disable_loaned_message)
     * }
     */
    public static FunctionDescriptor rcl_get_disable_loaned_message$descriptor() {
        return rcl_get_disable_loaned_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_get_disable_loaned_message(bool *disable_loaned_message)
     * }
     */
    public static MethodHandle rcl_get_disable_loaned_message$handle() {
        return rcl_get_disable_loaned_message.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_get_disable_loaned_message(bool *disable_loaned_message)
     * }
     */
    public static int rcl_get_disable_loaned_message(MemorySegment disable_loaned_message) {
        var mh$ = rcl_get_disable_loaned_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_disable_loaned_message", disable_loaned_message);
            }
            return (int)mh$.invokeExact(disable_loaned_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_message_typesupport_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("get_message_typesupport_handle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rosidl_message_type_support_t *get_message_typesupport_handle(const rosidl_message_type_support_t *handle, const char *identifier)
     * }
     */
    public static FunctionDescriptor get_message_typesupport_handle$descriptor() {
        return get_message_typesupport_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rosidl_message_type_support_t *get_message_typesupport_handle(const rosidl_message_type_support_t *handle, const char *identifier)
     * }
     */
    public static MethodHandle get_message_typesupport_handle$handle() {
        return get_message_typesupport_handle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rosidl_message_type_support_t *get_message_typesupport_handle(const rosidl_message_type_support_t *handle, const char *identifier)
     * }
     */
    public static MemorySegment get_message_typesupport_handle(MemorySegment handle, MemorySegment identifier) {
        var mh$ = get_message_typesupport_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_message_typesupport_handle", handle, identifier);
            }
            return (MemorySegment)mh$.invokeExact(handle, identifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_message_typesupport_handle_function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("get_message_typesupport_handle_function"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rosidl_message_type_support_t *get_message_typesupport_handle_function(const rosidl_message_type_support_t *handle, const char *identifier)
     * }
     */
    public static FunctionDescriptor get_message_typesupport_handle_function$descriptor() {
        return get_message_typesupport_handle_function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rosidl_message_type_support_t *get_message_typesupport_handle_function(const rosidl_message_type_support_t *handle, const char *identifier)
     * }
     */
    public static MethodHandle get_message_typesupport_handle_function$handle() {
        return get_message_typesupport_handle_function.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rosidl_message_type_support_t *get_message_typesupport_handle_function(const rosidl_message_type_support_t *handle, const char *identifier)
     * }
     */
    public static MemorySegment get_message_typesupport_handle_function(MemorySegment handle, MemorySegment identifier) {
        var mh$ = get_message_typesupport_handle_function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_message_typesupport_handle_function", handle, identifier);
            }
            return (MemorySegment)mh$.invokeExact(handle, identifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef rcutils_time_point_value_t rcl_time_point_value_t
     * }
     */
    public static final OfLong rcl_time_point_value_t = gen_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef rcutils_duration_value_t rcl_duration_value_t
     * }
     */
    public static final OfLong rcl_duration_value_t = gen_h.C_LONG;
    private static final int RCL_CLOCK_UNINITIALIZED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rcl_clock_type_e.RCL_CLOCK_UNINITIALIZED = 0
     * }
     */
    public static int RCL_CLOCK_UNINITIALIZED() {
        return RCL_CLOCK_UNINITIALIZED;
    }
    private static final int RCL_ROS_TIME = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rcl_clock_type_e.RCL_ROS_TIME = 1
     * }
     */
    public static int RCL_ROS_TIME() {
        return RCL_ROS_TIME;
    }
    private static final int RCL_SYSTEM_TIME = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rcl_clock_type_e.RCL_SYSTEM_TIME = 2
     * }
     */
    public static int RCL_SYSTEM_TIME() {
        return RCL_SYSTEM_TIME;
    }
    private static final int RCL_STEADY_TIME = (int)3L;
    /**
     * {@snippet lang=c :
     * enum rcl_clock_type_e.RCL_STEADY_TIME = 3
     * }
     */
    public static int RCL_STEADY_TIME() {
        return RCL_STEADY_TIME;
    }
    private static final int RCL_ROS_TIME_NO_CHANGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rcl_clock_change_e.RCL_ROS_TIME_NO_CHANGE = 1
     * }
     */
    public static int RCL_ROS_TIME_NO_CHANGE() {
        return RCL_ROS_TIME_NO_CHANGE;
    }
    private static final int RCL_ROS_TIME_ACTIVATED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rcl_clock_change_e.RCL_ROS_TIME_ACTIVATED = 2
     * }
     */
    public static int RCL_ROS_TIME_ACTIVATED() {
        return RCL_ROS_TIME_ACTIVATED;
    }
    private static final int RCL_ROS_TIME_DEACTIVATED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum rcl_clock_change_e.RCL_ROS_TIME_DEACTIVATED = 3
     * }
     */
    public static int RCL_ROS_TIME_DEACTIVATED() {
        return RCL_ROS_TIME_DEACTIVATED;
    }
    private static final int RCL_SYSTEM_TIME_NO_CHANGE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum rcl_clock_change_e.RCL_SYSTEM_TIME_NO_CHANGE = 4
     * }
     */
    public static int RCL_SYSTEM_TIME_NO_CHANGE() {
        return RCL_SYSTEM_TIME_NO_CHANGE;
    }

    private static class rcl_clock_time_started {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_clock_time_started"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_clock_time_started(rcl_clock_t *clock)
     * }
     */
    public static FunctionDescriptor rcl_clock_time_started$descriptor() {
        return rcl_clock_time_started.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_clock_time_started(rcl_clock_t *clock)
     * }
     */
    public static MethodHandle rcl_clock_time_started$handle() {
        return rcl_clock_time_started.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_clock_time_started(rcl_clock_t *clock)
     * }
     */
    public static boolean rcl_clock_time_started(MemorySegment clock) {
        var mh$ = rcl_clock_time_started.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_clock_time_started", clock);
            }
            return (boolean)mh$.invokeExact(clock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_clock_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_clock_valid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_clock_valid(rcl_clock_t *clock)
     * }
     */
    public static FunctionDescriptor rcl_clock_valid$descriptor() {
        return rcl_clock_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_clock_valid(rcl_clock_t *clock)
     * }
     */
    public static MethodHandle rcl_clock_valid$handle() {
        return rcl_clock_valid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_clock_valid(rcl_clock_t *clock)
     * }
     */
    public static boolean rcl_clock_valid(MemorySegment clock) {
        var mh$ = rcl_clock_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_clock_valid", clock);
            }
            return (boolean)mh$.invokeExact(clock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_clock_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_clock_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_init(rcl_clock_type_t clock_type, rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rcl_clock_init$descriptor() {
        return rcl_clock_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_init(rcl_clock_type_t clock_type, rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static MethodHandle rcl_clock_init$handle() {
        return rcl_clock_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_init(rcl_clock_type_t clock_type, rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static int rcl_clock_init(int clock_type, MemorySegment clock, MemorySegment allocator) {
        var mh$ = rcl_clock_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_clock_init", clock_type, clock, allocator);
            }
            return (int)mh$.invokeExact(clock_type, clock, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_clock_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_clock_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static FunctionDescriptor rcl_clock_fini$descriptor() {
        return rcl_clock_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static MethodHandle rcl_clock_fini$handle() {
        return rcl_clock_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static int rcl_clock_fini(MemorySegment clock) {
        var mh$ = rcl_clock_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_clock_fini", clock);
            }
            return (int)mh$.invokeExact(clock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_ros_clock_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_ros_clock_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_ros_clock_init(rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rcl_ros_clock_init$descriptor() {
        return rcl_ros_clock_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_ros_clock_init(rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static MethodHandle rcl_ros_clock_init$handle() {
        return rcl_ros_clock_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_ros_clock_init(rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static int rcl_ros_clock_init(MemorySegment clock, MemorySegment allocator) {
        var mh$ = rcl_ros_clock_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_ros_clock_init", clock, allocator);
            }
            return (int)mh$.invokeExact(clock, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_ros_clock_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_ros_clock_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_ros_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static FunctionDescriptor rcl_ros_clock_fini$descriptor() {
        return rcl_ros_clock_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_ros_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static MethodHandle rcl_ros_clock_fini$handle() {
        return rcl_ros_clock_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_ros_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static int rcl_ros_clock_fini(MemorySegment clock) {
        var mh$ = rcl_ros_clock_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_ros_clock_fini", clock);
            }
            return (int)mh$.invokeExact(clock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_steady_clock_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_steady_clock_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_steady_clock_init(rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rcl_steady_clock_init$descriptor() {
        return rcl_steady_clock_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_steady_clock_init(rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static MethodHandle rcl_steady_clock_init$handle() {
        return rcl_steady_clock_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_steady_clock_init(rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static int rcl_steady_clock_init(MemorySegment clock, MemorySegment allocator) {
        var mh$ = rcl_steady_clock_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_steady_clock_init", clock, allocator);
            }
            return (int)mh$.invokeExact(clock, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_steady_clock_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_steady_clock_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_steady_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static FunctionDescriptor rcl_steady_clock_fini$descriptor() {
        return rcl_steady_clock_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_steady_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static MethodHandle rcl_steady_clock_fini$handle() {
        return rcl_steady_clock_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_steady_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static int rcl_steady_clock_fini(MemorySegment clock) {
        var mh$ = rcl_steady_clock_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_steady_clock_fini", clock);
            }
            return (int)mh$.invokeExact(clock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_system_clock_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_system_clock_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_system_clock_init(rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rcl_system_clock_init$descriptor() {
        return rcl_system_clock_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_system_clock_init(rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static MethodHandle rcl_system_clock_init$handle() {
        return rcl_system_clock_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_system_clock_init(rcl_clock_t *clock, rcl_allocator_t *allocator)
     * }
     */
    public static int rcl_system_clock_init(MemorySegment clock, MemorySegment allocator) {
        var mh$ = rcl_system_clock_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_system_clock_init", clock, allocator);
            }
            return (int)mh$.invokeExact(clock, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_system_clock_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_system_clock_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_system_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static FunctionDescriptor rcl_system_clock_fini$descriptor() {
        return rcl_system_clock_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_system_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static MethodHandle rcl_system_clock_fini$handle() {
        return rcl_system_clock_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_system_clock_fini(rcl_clock_t *clock)
     * }
     */
    public static int rcl_system_clock_fini(MemorySegment clock) {
        var mh$ = rcl_system_clock_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_system_clock_fini", clock);
            }
            return (int)mh$.invokeExact(clock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_difference_times {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_difference_times"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_difference_times(const rcl_time_point_t *start, const rcl_time_point_t *finish, rcl_duration_t *delta)
     * }
     */
    public static FunctionDescriptor rcl_difference_times$descriptor() {
        return rcl_difference_times.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_difference_times(const rcl_time_point_t *start, const rcl_time_point_t *finish, rcl_duration_t *delta)
     * }
     */
    public static MethodHandle rcl_difference_times$handle() {
        return rcl_difference_times.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_difference_times(const rcl_time_point_t *start, const rcl_time_point_t *finish, rcl_duration_t *delta)
     * }
     */
    public static int rcl_difference_times(MemorySegment start, MemorySegment finish, MemorySegment delta) {
        var mh$ = rcl_difference_times.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_difference_times", start, finish, delta);
            }
            return (int)mh$.invokeExact(start, finish, delta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_clock_get_now {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_clock_get_now"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_get_now(rcl_clock_t *clock, rcl_time_point_value_t *time_point_value)
     * }
     */
    public static FunctionDescriptor rcl_clock_get_now$descriptor() {
        return rcl_clock_get_now.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_get_now(rcl_clock_t *clock, rcl_time_point_value_t *time_point_value)
     * }
     */
    public static MethodHandle rcl_clock_get_now$handle() {
        return rcl_clock_get_now.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_get_now(rcl_clock_t *clock, rcl_time_point_value_t *time_point_value)
     * }
     */
    public static int rcl_clock_get_now(MemorySegment clock, MemorySegment time_point_value) {
        var mh$ = rcl_clock_get_now.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_clock_get_now", clock, time_point_value);
            }
            return (int)mh$.invokeExact(clock, time_point_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_enable_ros_time_override {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_enable_ros_time_override"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_enable_ros_time_override(rcl_clock_t *clock)
     * }
     */
    public static FunctionDescriptor rcl_enable_ros_time_override$descriptor() {
        return rcl_enable_ros_time_override.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_enable_ros_time_override(rcl_clock_t *clock)
     * }
     */
    public static MethodHandle rcl_enable_ros_time_override$handle() {
        return rcl_enable_ros_time_override.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_enable_ros_time_override(rcl_clock_t *clock)
     * }
     */
    public static int rcl_enable_ros_time_override(MemorySegment clock) {
        var mh$ = rcl_enable_ros_time_override.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_enable_ros_time_override", clock);
            }
            return (int)mh$.invokeExact(clock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_disable_ros_time_override {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_disable_ros_time_override"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_disable_ros_time_override(rcl_clock_t *clock)
     * }
     */
    public static FunctionDescriptor rcl_disable_ros_time_override$descriptor() {
        return rcl_disable_ros_time_override.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_disable_ros_time_override(rcl_clock_t *clock)
     * }
     */
    public static MethodHandle rcl_disable_ros_time_override$handle() {
        return rcl_disable_ros_time_override.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_disable_ros_time_override(rcl_clock_t *clock)
     * }
     */
    public static int rcl_disable_ros_time_override(MemorySegment clock) {
        var mh$ = rcl_disable_ros_time_override.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_disable_ros_time_override", clock);
            }
            return (int)mh$.invokeExact(clock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_is_enabled_ros_time_override {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_is_enabled_ros_time_override"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_is_enabled_ros_time_override(rcl_clock_t *clock, bool *is_enabled)
     * }
     */
    public static FunctionDescriptor rcl_is_enabled_ros_time_override$descriptor() {
        return rcl_is_enabled_ros_time_override.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_is_enabled_ros_time_override(rcl_clock_t *clock, bool *is_enabled)
     * }
     */
    public static MethodHandle rcl_is_enabled_ros_time_override$handle() {
        return rcl_is_enabled_ros_time_override.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_is_enabled_ros_time_override(rcl_clock_t *clock, bool *is_enabled)
     * }
     */
    public static int rcl_is_enabled_ros_time_override(MemorySegment clock, MemorySegment is_enabled) {
        var mh$ = rcl_is_enabled_ros_time_override.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_is_enabled_ros_time_override", clock, is_enabled);
            }
            return (int)mh$.invokeExact(clock, is_enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_set_ros_time_override {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_set_ros_time_override"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_set_ros_time_override(rcl_clock_t *clock, rcl_time_point_value_t time_value)
     * }
     */
    public static FunctionDescriptor rcl_set_ros_time_override$descriptor() {
        return rcl_set_ros_time_override.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_set_ros_time_override(rcl_clock_t *clock, rcl_time_point_value_t time_value)
     * }
     */
    public static MethodHandle rcl_set_ros_time_override$handle() {
        return rcl_set_ros_time_override.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_set_ros_time_override(rcl_clock_t *clock, rcl_time_point_value_t time_value)
     * }
     */
    public static int rcl_set_ros_time_override(MemorySegment clock, long time_value) {
        var mh$ = rcl_set_ros_time_override.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_set_ros_time_override", clock, time_value);
            }
            return (int)mh$.invokeExact(clock, time_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_clock_add_jump_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            rcl_jump_threshold_s.layout(),
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_clock_add_jump_callback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_add_jump_callback(rcl_clock_t *clock, rcl_jump_threshold_t threshold, rcl_jump_callback_t callback, void *user_data)
     * }
     */
    public static FunctionDescriptor rcl_clock_add_jump_callback$descriptor() {
        return rcl_clock_add_jump_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_add_jump_callback(rcl_clock_t *clock, rcl_jump_threshold_t threshold, rcl_jump_callback_t callback, void *user_data)
     * }
     */
    public static MethodHandle rcl_clock_add_jump_callback$handle() {
        return rcl_clock_add_jump_callback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_add_jump_callback(rcl_clock_t *clock, rcl_jump_threshold_t threshold, rcl_jump_callback_t callback, void *user_data)
     * }
     */
    public static int rcl_clock_add_jump_callback(MemorySegment clock, MemorySegment threshold, MemorySegment callback, MemorySegment user_data) {
        var mh$ = rcl_clock_add_jump_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_clock_add_jump_callback", clock, threshold, callback, user_data);
            }
            return (int)mh$.invokeExact(clock, threshold, callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_clock_remove_jump_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_clock_remove_jump_callback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_remove_jump_callback(rcl_clock_t *clock, rcl_jump_callback_t callback, void *user_data)
     * }
     */
    public static FunctionDescriptor rcl_clock_remove_jump_callback$descriptor() {
        return rcl_clock_remove_jump_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_remove_jump_callback(rcl_clock_t *clock, rcl_jump_callback_t callback, void *user_data)
     * }
     */
    public static MethodHandle rcl_clock_remove_jump_callback$handle() {
        return rcl_clock_remove_jump_callback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_clock_remove_jump_callback(rcl_clock_t *clock, rcl_jump_callback_t callback, void *user_data)
     * }
     */
    public static int rcl_clock_remove_jump_callback(MemorySegment clock, MemorySegment callback, MemorySegment user_data) {
        var mh$ = rcl_clock_remove_jump_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_clock_remove_jump_callback", clock, callback, user_data);
            }
            return (int)mh$.invokeExact(clock, callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_get_zero_initialized_publisher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_publisher_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_zero_initialized_publisher"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_publisher_t rcl_get_zero_initialized_publisher()
     * }
     */
    public static FunctionDescriptor rcl_get_zero_initialized_publisher$descriptor() {
        return rcl_get_zero_initialized_publisher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_publisher_t rcl_get_zero_initialized_publisher()
     * }
     */
    public static MethodHandle rcl_get_zero_initialized_publisher$handle() {
        return rcl_get_zero_initialized_publisher.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_publisher_t rcl_get_zero_initialized_publisher()
     * }
     */
    public static MemorySegment rcl_get_zero_initialized_publisher(SegmentAllocator allocator) {
        var mh$ = rcl_get_zero_initialized_publisher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_zero_initialized_publisher", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_init(rcl_publisher_t *publisher, const rcl_node_t *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const rcl_publisher_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_publisher_init$descriptor() {
        return rcl_publisher_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_init(rcl_publisher_t *publisher, const rcl_node_t *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const rcl_publisher_options_t *options)
     * }
     */
    public static MethodHandle rcl_publisher_init$handle() {
        return rcl_publisher_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_init(rcl_publisher_t *publisher, const rcl_node_t *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const rcl_publisher_options_t *options)
     * }
     */
    public static int rcl_publisher_init(MemorySegment publisher, MemorySegment node, MemorySegment type_support, MemorySegment topic_name, MemorySegment options) {
        var mh$ = rcl_publisher_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_init", publisher, node, type_support, topic_name, options);
            }
            return (int)mh$.invokeExact(publisher, node, type_support, topic_name, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_fini(rcl_publisher_t *publisher, rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_publisher_fini$descriptor() {
        return rcl_publisher_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_fini(rcl_publisher_t *publisher, rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_publisher_fini$handle() {
        return rcl_publisher_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_fini(rcl_publisher_t *publisher, rcl_node_t *node)
     * }
     */
    public static int rcl_publisher_fini(MemorySegment publisher, MemorySegment node) {
        var mh$ = rcl_publisher_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_fini", publisher, node);
            }
            return (int)mh$.invokeExact(publisher, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_get_default_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_publisher_options_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_get_default_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_publisher_options_t rcl_publisher_get_default_options()
     * }
     */
    public static FunctionDescriptor rcl_publisher_get_default_options$descriptor() {
        return rcl_publisher_get_default_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_publisher_options_t rcl_publisher_get_default_options()
     * }
     */
    public static MethodHandle rcl_publisher_get_default_options$handle() {
        return rcl_publisher_get_default_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_publisher_options_t rcl_publisher_get_default_options()
     * }
     */
    public static MemorySegment rcl_publisher_get_default_options(SegmentAllocator allocator) {
        var mh$ = rcl_publisher_get_default_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_get_default_options", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_borrow_loaned_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_borrow_loaned_message"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_borrow_loaned_message(const rcl_publisher_t *publisher, const rosidl_message_type_support_t *type_support, void **ros_message)
     * }
     */
    public static FunctionDescriptor rcl_borrow_loaned_message$descriptor() {
        return rcl_borrow_loaned_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_borrow_loaned_message(const rcl_publisher_t *publisher, const rosidl_message_type_support_t *type_support, void **ros_message)
     * }
     */
    public static MethodHandle rcl_borrow_loaned_message$handle() {
        return rcl_borrow_loaned_message.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_borrow_loaned_message(const rcl_publisher_t *publisher, const rosidl_message_type_support_t *type_support, void **ros_message)
     * }
     */
    public static int rcl_borrow_loaned_message(MemorySegment publisher, MemorySegment type_support, MemorySegment ros_message) {
        var mh$ = rcl_borrow_loaned_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_borrow_loaned_message", publisher, type_support, ros_message);
            }
            return (int)mh$.invokeExact(publisher, type_support, ros_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_return_loaned_message_from_publisher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_return_loaned_message_from_publisher"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_return_loaned_message_from_publisher(const rcl_publisher_t *publisher, void *loaned_message)
     * }
     */
    public static FunctionDescriptor rcl_return_loaned_message_from_publisher$descriptor() {
        return rcl_return_loaned_message_from_publisher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_return_loaned_message_from_publisher(const rcl_publisher_t *publisher, void *loaned_message)
     * }
     */
    public static MethodHandle rcl_return_loaned_message_from_publisher$handle() {
        return rcl_return_loaned_message_from_publisher.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_return_loaned_message_from_publisher(const rcl_publisher_t *publisher, void *loaned_message)
     * }
     */
    public static int rcl_return_loaned_message_from_publisher(MemorySegment publisher, MemorySegment loaned_message) {
        var mh$ = rcl_return_loaned_message_from_publisher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_return_loaned_message_from_publisher", publisher, loaned_message);
            }
            return (int)mh$.invokeExact(publisher, loaned_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publish"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publish(const rcl_publisher_t *publisher, const void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rcl_publish$descriptor() {
        return rcl_publish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publish(const rcl_publisher_t *publisher, const void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static MethodHandle rcl_publish$handle() {
        return rcl_publish.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_publish(const rcl_publisher_t *publisher, const void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static int rcl_publish(MemorySegment publisher, MemorySegment ros_message, MemorySegment allocation) {
        var mh$ = rcl_publish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publish", publisher, ros_message, allocation);
            }
            return (int)mh$.invokeExact(publisher, ros_message, allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publish_serialized_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publish_serialized_message"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publish_serialized_message(const rcl_publisher_t *publisher, const rcl_serialized_message_t *serialized_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rcl_publish_serialized_message$descriptor() {
        return rcl_publish_serialized_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publish_serialized_message(const rcl_publisher_t *publisher, const rcl_serialized_message_t *serialized_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static MethodHandle rcl_publish_serialized_message$handle() {
        return rcl_publish_serialized_message.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_publish_serialized_message(const rcl_publisher_t *publisher, const rcl_serialized_message_t *serialized_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static int rcl_publish_serialized_message(MemorySegment publisher, MemorySegment serialized_message, MemorySegment allocation) {
        var mh$ = rcl_publish_serialized_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publish_serialized_message", publisher, serialized_message, allocation);
            }
            return (int)mh$.invokeExact(publisher, serialized_message, allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publish_loaned_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publish_loaned_message"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publish_loaned_message(const rcl_publisher_t *publisher, void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rcl_publish_loaned_message$descriptor() {
        return rcl_publish_loaned_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publish_loaned_message(const rcl_publisher_t *publisher, void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static MethodHandle rcl_publish_loaned_message$handle() {
        return rcl_publish_loaned_message.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_publish_loaned_message(const rcl_publisher_t *publisher, void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static int rcl_publish_loaned_message(MemorySegment publisher, MemorySegment ros_message, MemorySegment allocation) {
        var mh$ = rcl_publish_loaned_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publish_loaned_message", publisher, ros_message, allocation);
            }
            return (int)mh$.invokeExact(publisher, ros_message, allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_assert_liveliness {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_assert_liveliness"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_assert_liveliness(const rcl_publisher_t *publisher)
     * }
     */
    public static FunctionDescriptor rcl_publisher_assert_liveliness$descriptor() {
        return rcl_publisher_assert_liveliness.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_assert_liveliness(const rcl_publisher_t *publisher)
     * }
     */
    public static MethodHandle rcl_publisher_assert_liveliness$handle() {
        return rcl_publisher_assert_liveliness.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_assert_liveliness(const rcl_publisher_t *publisher)
     * }
     */
    public static int rcl_publisher_assert_liveliness(MemorySegment publisher) {
        var mh$ = rcl_publisher_assert_liveliness.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_assert_liveliness", publisher);
            }
            return (int)mh$.invokeExact(publisher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_wait_for_all_acked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_wait_for_all_acked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_wait_for_all_acked(const rcl_publisher_t *publisher, rcl_duration_value_t timeout)
     * }
     */
    public static FunctionDescriptor rcl_publisher_wait_for_all_acked$descriptor() {
        return rcl_publisher_wait_for_all_acked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_wait_for_all_acked(const rcl_publisher_t *publisher, rcl_duration_value_t timeout)
     * }
     */
    public static MethodHandle rcl_publisher_wait_for_all_acked$handle() {
        return rcl_publisher_wait_for_all_acked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_wait_for_all_acked(const rcl_publisher_t *publisher, rcl_duration_value_t timeout)
     * }
     */
    public static int rcl_publisher_wait_for_all_acked(MemorySegment publisher, long timeout) {
        var mh$ = rcl_publisher_wait_for_all_acked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_wait_for_all_acked", publisher, timeout);
            }
            return (int)mh$.invokeExact(publisher, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_get_topic_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_get_topic_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rcl_publisher_get_topic_name(const rcl_publisher_t *publisher)
     * }
     */
    public static FunctionDescriptor rcl_publisher_get_topic_name$descriptor() {
        return rcl_publisher_get_topic_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rcl_publisher_get_topic_name(const rcl_publisher_t *publisher)
     * }
     */
    public static MethodHandle rcl_publisher_get_topic_name$handle() {
        return rcl_publisher_get_topic_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rcl_publisher_get_topic_name(const rcl_publisher_t *publisher)
     * }
     */
    public static MemorySegment rcl_publisher_get_topic_name(MemorySegment publisher) {
        var mh$ = rcl_publisher_get_topic_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_get_topic_name", publisher);
            }
            return (MemorySegment)mh$.invokeExact(publisher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_get_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_get_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rcl_publisher_options_t *rcl_publisher_get_options(const rcl_publisher_t *publisher)
     * }
     */
    public static FunctionDescriptor rcl_publisher_get_options$descriptor() {
        return rcl_publisher_get_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rcl_publisher_options_t *rcl_publisher_get_options(const rcl_publisher_t *publisher)
     * }
     */
    public static MethodHandle rcl_publisher_get_options$handle() {
        return rcl_publisher_get_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rcl_publisher_options_t *rcl_publisher_get_options(const rcl_publisher_t *publisher)
     * }
     */
    public static MemorySegment rcl_publisher_get_options(MemorySegment publisher) {
        var mh$ = rcl_publisher_get_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_get_options", publisher);
            }
            return (MemorySegment)mh$.invokeExact(publisher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_get_rmw_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_get_rmw_handle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_publisher_t *rcl_publisher_get_rmw_handle(const rcl_publisher_t *publisher)
     * }
     */
    public static FunctionDescriptor rcl_publisher_get_rmw_handle$descriptor() {
        return rcl_publisher_get_rmw_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_publisher_t *rcl_publisher_get_rmw_handle(const rcl_publisher_t *publisher)
     * }
     */
    public static MethodHandle rcl_publisher_get_rmw_handle$handle() {
        return rcl_publisher_get_rmw_handle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_publisher_t *rcl_publisher_get_rmw_handle(const rcl_publisher_t *publisher)
     * }
     */
    public static MemorySegment rcl_publisher_get_rmw_handle(MemorySegment publisher) {
        var mh$ = rcl_publisher_get_rmw_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_get_rmw_handle", publisher);
            }
            return (MemorySegment)mh$.invokeExact(publisher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_get_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_get_context"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_context_t *rcl_publisher_get_context(const rcl_publisher_t *publisher)
     * }
     */
    public static FunctionDescriptor rcl_publisher_get_context$descriptor() {
        return rcl_publisher_get_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_context_t *rcl_publisher_get_context(const rcl_publisher_t *publisher)
     * }
     */
    public static MethodHandle rcl_publisher_get_context$handle() {
        return rcl_publisher_get_context.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_context_t *rcl_publisher_get_context(const rcl_publisher_t *publisher)
     * }
     */
    public static MemorySegment rcl_publisher_get_context(MemorySegment publisher) {
        var mh$ = rcl_publisher_get_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_get_context", publisher);
            }
            return (MemorySegment)mh$.invokeExact(publisher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_is_valid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_publisher_is_valid(const rcl_publisher_t *publisher)
     * }
     */
    public static FunctionDescriptor rcl_publisher_is_valid$descriptor() {
        return rcl_publisher_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_publisher_is_valid(const rcl_publisher_t *publisher)
     * }
     */
    public static MethodHandle rcl_publisher_is_valid$handle() {
        return rcl_publisher_is_valid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_publisher_is_valid(const rcl_publisher_t *publisher)
     * }
     */
    public static boolean rcl_publisher_is_valid(MemorySegment publisher) {
        var mh$ = rcl_publisher_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_is_valid", publisher);
            }
            return (boolean)mh$.invokeExact(publisher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_is_valid_except_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_is_valid_except_context"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_publisher_is_valid_except_context(const rcl_publisher_t *publisher)
     * }
     */
    public static FunctionDescriptor rcl_publisher_is_valid_except_context$descriptor() {
        return rcl_publisher_is_valid_except_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_publisher_is_valid_except_context(const rcl_publisher_t *publisher)
     * }
     */
    public static MethodHandle rcl_publisher_is_valid_except_context$handle() {
        return rcl_publisher_is_valid_except_context.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_publisher_is_valid_except_context(const rcl_publisher_t *publisher)
     * }
     */
    public static boolean rcl_publisher_is_valid_except_context(MemorySegment publisher) {
        var mh$ = rcl_publisher_is_valid_except_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_is_valid_except_context", publisher);
            }
            return (boolean)mh$.invokeExact(publisher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_get_subscription_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_get_subscription_count"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_get_subscription_count(const rcl_publisher_t *publisher, size_t *subscription_count)
     * }
     */
    public static FunctionDescriptor rcl_publisher_get_subscription_count$descriptor() {
        return rcl_publisher_get_subscription_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_get_subscription_count(const rcl_publisher_t *publisher, size_t *subscription_count)
     * }
     */
    public static MethodHandle rcl_publisher_get_subscription_count$handle() {
        return rcl_publisher_get_subscription_count.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_publisher_get_subscription_count(const rcl_publisher_t *publisher, size_t *subscription_count)
     * }
     */
    public static int rcl_publisher_get_subscription_count(MemorySegment publisher, MemorySegment subscription_count) {
        var mh$ = rcl_publisher_get_subscription_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_get_subscription_count", publisher, subscription_count);
            }
            return (int)mh$.invokeExact(publisher, subscription_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_get_actual_qos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_get_actual_qos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_publisher_get_actual_qos(const rcl_publisher_t *publisher)
     * }
     */
    public static FunctionDescriptor rcl_publisher_get_actual_qos$descriptor() {
        return rcl_publisher_get_actual_qos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_publisher_get_actual_qos(const rcl_publisher_t *publisher)
     * }
     */
    public static MethodHandle rcl_publisher_get_actual_qos$handle() {
        return rcl_publisher_get_actual_qos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_publisher_get_actual_qos(const rcl_publisher_t *publisher)
     * }
     */
    public static MemorySegment rcl_publisher_get_actual_qos(MemorySegment publisher) {
        var mh$ = rcl_publisher_get_actual_qos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_get_actual_qos", publisher);
            }
            return (MemorySegment)mh$.invokeExact(publisher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_publisher_can_loan_messages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_publisher_can_loan_messages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_publisher_can_loan_messages(const rcl_publisher_t *publisher)
     * }
     */
    public static FunctionDescriptor rcl_publisher_can_loan_messages$descriptor() {
        return rcl_publisher_can_loan_messages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_publisher_can_loan_messages(const rcl_publisher_t *publisher)
     * }
     */
    public static MethodHandle rcl_publisher_can_loan_messages$handle() {
        return rcl_publisher_can_loan_messages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_publisher_can_loan_messages(const rcl_publisher_t *publisher)
     * }
     */
    public static boolean rcl_publisher_can_loan_messages(MemorySegment publisher) {
        var mh$ = rcl_publisher_can_loan_messages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_publisher_can_loan_messages", publisher);
            }
            return (boolean)mh$.invokeExact(publisher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_get_zero_initialized_message_sequence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rmw_message_sequence_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_get_zero_initialized_message_sequence"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_message_sequence_t rmw_get_zero_initialized_message_sequence()
     * }
     */
    public static FunctionDescriptor rmw_get_zero_initialized_message_sequence$descriptor() {
        return rmw_get_zero_initialized_message_sequence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_message_sequence_t rmw_get_zero_initialized_message_sequence()
     * }
     */
    public static MethodHandle rmw_get_zero_initialized_message_sequence$handle() {
        return rmw_get_zero_initialized_message_sequence.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_message_sequence_t rmw_get_zero_initialized_message_sequence()
     * }
     */
    public static MemorySegment rmw_get_zero_initialized_message_sequence(SegmentAllocator allocator) {
        var mh$ = rmw_get_zero_initialized_message_sequence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_get_zero_initialized_message_sequence", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_message_sequence_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_message_sequence_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_sequence_init(rmw_message_sequence_t *sequence, size_t size, rcutils_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rmw_message_sequence_init$descriptor() {
        return rmw_message_sequence_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_sequence_init(rmw_message_sequence_t *sequence, size_t size, rcutils_allocator_t *allocator)
     * }
     */
    public static MethodHandle rmw_message_sequence_init$handle() {
        return rmw_message_sequence_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_sequence_init(rmw_message_sequence_t *sequence, size_t size, rcutils_allocator_t *allocator)
     * }
     */
    public static int rmw_message_sequence_init(MemorySegment sequence, long size, MemorySegment allocator) {
        var mh$ = rmw_message_sequence_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_message_sequence_init", sequence, size, allocator);
            }
            return (int)mh$.invokeExact(sequence, size, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_message_sequence_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_message_sequence_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_sequence_fini(rmw_message_sequence_t *sequence)
     * }
     */
    public static FunctionDescriptor rmw_message_sequence_fini$descriptor() {
        return rmw_message_sequence_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_sequence_fini(rmw_message_sequence_t *sequence)
     * }
     */
    public static MethodHandle rmw_message_sequence_fini$handle() {
        return rmw_message_sequence_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_sequence_fini(rmw_message_sequence_t *sequence)
     * }
     */
    public static int rmw_message_sequence_fini(MemorySegment sequence) {
        var mh$ = rmw_message_sequence_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_message_sequence_fini", sequence);
            }
            return (int)mh$.invokeExact(sequence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_get_zero_initialized_message_info_sequence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rmw_message_info_sequence_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_get_zero_initialized_message_info_sequence"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_message_info_sequence_t rmw_get_zero_initialized_message_info_sequence()
     * }
     */
    public static FunctionDescriptor rmw_get_zero_initialized_message_info_sequence$descriptor() {
        return rmw_get_zero_initialized_message_info_sequence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_message_info_sequence_t rmw_get_zero_initialized_message_info_sequence()
     * }
     */
    public static MethodHandle rmw_get_zero_initialized_message_info_sequence$handle() {
        return rmw_get_zero_initialized_message_info_sequence.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_message_info_sequence_t rmw_get_zero_initialized_message_info_sequence()
     * }
     */
    public static MemorySegment rmw_get_zero_initialized_message_info_sequence(SegmentAllocator allocator) {
        var mh$ = rmw_get_zero_initialized_message_info_sequence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_get_zero_initialized_message_info_sequence", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_message_info_sequence_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_message_info_sequence_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_info_sequence_init(rmw_message_info_sequence_t *sequence, size_t size, rcutils_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor rmw_message_info_sequence_init$descriptor() {
        return rmw_message_info_sequence_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_info_sequence_init(rmw_message_info_sequence_t *sequence, size_t size, rcutils_allocator_t *allocator)
     * }
     */
    public static MethodHandle rmw_message_info_sequence_init$handle() {
        return rmw_message_info_sequence_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_info_sequence_init(rmw_message_info_sequence_t *sequence, size_t size, rcutils_allocator_t *allocator)
     * }
     */
    public static int rmw_message_info_sequence_init(MemorySegment sequence, long size, MemorySegment allocator) {
        var mh$ = rmw_message_info_sequence_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_message_info_sequence_init", sequence, size, allocator);
            }
            return (int)mh$.invokeExact(sequence, size, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_message_info_sequence_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_message_info_sequence_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_info_sequence_fini(rmw_message_info_sequence_t *sequence)
     * }
     */
    public static FunctionDescriptor rmw_message_info_sequence_fini$descriptor() {
        return rmw_message_info_sequence_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_info_sequence_fini(rmw_message_info_sequence_t *sequence)
     * }
     */
    public static MethodHandle rmw_message_info_sequence_fini$handle() {
        return rmw_message_info_sequence_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_message_info_sequence_fini(rmw_message_info_sequence_t *sequence)
     * }
     */
    public static int rmw_message_info_sequence_fini(MemorySegment sequence) {
        var mh$ = rmw_message_info_sequence_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_message_info_sequence_fini", sequence);
            }
            return (int)mh$.invokeExact(sequence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_get_zero_initialized_subscription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_subscription_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_zero_initialized_subscription"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_subscription_t rcl_get_zero_initialized_subscription()
     * }
     */
    public static FunctionDescriptor rcl_get_zero_initialized_subscription$descriptor() {
        return rcl_get_zero_initialized_subscription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_subscription_t rcl_get_zero_initialized_subscription()
     * }
     */
    public static MethodHandle rcl_get_zero_initialized_subscription$handle() {
        return rcl_get_zero_initialized_subscription.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_subscription_t rcl_get_zero_initialized_subscription()
     * }
     */
    public static MemorySegment rcl_get_zero_initialized_subscription(SegmentAllocator allocator) {
        var mh$ = rcl_get_zero_initialized_subscription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_zero_initialized_subscription", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_init(rcl_subscription_t *subscription, const rcl_node_t *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const rcl_subscription_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_subscription_init$descriptor() {
        return rcl_subscription_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_init(rcl_subscription_t *subscription, const rcl_node_t *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const rcl_subscription_options_t *options)
     * }
     */
    public static MethodHandle rcl_subscription_init$handle() {
        return rcl_subscription_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_init(rcl_subscription_t *subscription, const rcl_node_t *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const rcl_subscription_options_t *options)
     * }
     */
    public static int rcl_subscription_init(MemorySegment subscription, MemorySegment node, MemorySegment type_support, MemorySegment topic_name, MemorySegment options) {
        var mh$ = rcl_subscription_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_init", subscription, node, type_support, topic_name, options);
            }
            return (int)mh$.invokeExact(subscription, node, type_support, topic_name, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_fini(rcl_subscription_t *subscription, rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_subscription_fini$descriptor() {
        return rcl_subscription_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_fini(rcl_subscription_t *subscription, rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_subscription_fini$handle() {
        return rcl_subscription_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_fini(rcl_subscription_t *subscription, rcl_node_t *node)
     * }
     */
    public static int rcl_subscription_fini(MemorySegment subscription, MemorySegment node) {
        var mh$ = rcl_subscription_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_fini", subscription, node);
            }
            return (int)mh$.invokeExact(subscription, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_get_default_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_subscription_options_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_get_default_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_subscription_options_t rcl_subscription_get_default_options()
     * }
     */
    public static FunctionDescriptor rcl_subscription_get_default_options$descriptor() {
        return rcl_subscription_get_default_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_subscription_options_t rcl_subscription_get_default_options()
     * }
     */
    public static MethodHandle rcl_subscription_get_default_options$handle() {
        return rcl_subscription_get_default_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_subscription_options_t rcl_subscription_get_default_options()
     * }
     */
    public static MemorySegment rcl_subscription_get_default_options(SegmentAllocator allocator) {
        var mh$ = rcl_subscription_get_default_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_get_default_options", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_options_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_options_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_options_fini(rcl_subscription_options_t *option)
     * }
     */
    public static FunctionDescriptor rcl_subscription_options_fini$descriptor() {
        return rcl_subscription_options_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_options_fini(rcl_subscription_options_t *option)
     * }
     */
    public static MethodHandle rcl_subscription_options_fini$handle() {
        return rcl_subscription_options_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_options_fini(rcl_subscription_options_t *option)
     * }
     */
    public static int rcl_subscription_options_fini(MemorySegment option) {
        var mh$ = rcl_subscription_options_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_options_fini", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_options_set_content_filter_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_options_set_content_filter_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_options_set_content_filter_options(const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], rcl_subscription_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_subscription_options_set_content_filter_options$descriptor() {
        return rcl_subscription_options_set_content_filter_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_options_set_content_filter_options(const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], rcl_subscription_options_t *options)
     * }
     */
    public static MethodHandle rcl_subscription_options_set_content_filter_options$handle() {
        return rcl_subscription_options_set_content_filter_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_options_set_content_filter_options(const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], rcl_subscription_options_t *options)
     * }
     */
    public static int rcl_subscription_options_set_content_filter_options(MemorySegment filter_expression, long expression_parameters_argc, MemorySegment expression_parameter_argv, MemorySegment options) {
        var mh$ = rcl_subscription_options_set_content_filter_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_options_set_content_filter_options", filter_expression, expression_parameters_argc, expression_parameter_argv, options);
            }
            return (int)mh$.invokeExact(filter_expression, expression_parameters_argc, expression_parameter_argv, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_get_zero_initialized_subscription_content_filter_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_subscription_content_filter_options_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_zero_initialized_subscription_content_filter_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_subscription_content_filter_options_t rcl_get_zero_initialized_subscription_content_filter_options()
     * }
     */
    public static FunctionDescriptor rcl_get_zero_initialized_subscription_content_filter_options$descriptor() {
        return rcl_get_zero_initialized_subscription_content_filter_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_subscription_content_filter_options_t rcl_get_zero_initialized_subscription_content_filter_options()
     * }
     */
    public static MethodHandle rcl_get_zero_initialized_subscription_content_filter_options$handle() {
        return rcl_get_zero_initialized_subscription_content_filter_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_subscription_content_filter_options_t rcl_get_zero_initialized_subscription_content_filter_options()
     * }
     */
    public static MemorySegment rcl_get_zero_initialized_subscription_content_filter_options(SegmentAllocator allocator) {
        var mh$ = rcl_get_zero_initialized_subscription_content_filter_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_zero_initialized_subscription_content_filter_options", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_content_filter_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_content_filter_options_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_content_filter_options_init(const rcl_subscription_t *subscription, const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_subscription_content_filter_options_init$descriptor() {
        return rcl_subscription_content_filter_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_content_filter_options_init(const rcl_subscription_t *subscription, const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static MethodHandle rcl_subscription_content_filter_options_init$handle() {
        return rcl_subscription_content_filter_options_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_content_filter_options_init(const rcl_subscription_t *subscription, const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static int rcl_subscription_content_filter_options_init(MemorySegment subscription, MemorySegment filter_expression, long expression_parameters_argc, MemorySegment expression_parameter_argv, MemorySegment options) {
        var mh$ = rcl_subscription_content_filter_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_content_filter_options_init", subscription, filter_expression, expression_parameters_argc, expression_parameter_argv, options);
            }
            return (int)mh$.invokeExact(subscription, filter_expression, expression_parameters_argc, expression_parameter_argv, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_content_filter_options_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_content_filter_options_set"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_content_filter_options_set(const rcl_subscription_t *subscription, const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_subscription_content_filter_options_set$descriptor() {
        return rcl_subscription_content_filter_options_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_content_filter_options_set(const rcl_subscription_t *subscription, const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static MethodHandle rcl_subscription_content_filter_options_set$handle() {
        return rcl_subscription_content_filter_options_set.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_content_filter_options_set(const rcl_subscription_t *subscription, const char *filter_expression, size_t expression_parameters_argc, const char *expression_parameter_argv[], rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static int rcl_subscription_content_filter_options_set(MemorySegment subscription, MemorySegment filter_expression, long expression_parameters_argc, MemorySegment expression_parameter_argv, MemorySegment options) {
        var mh$ = rcl_subscription_content_filter_options_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_content_filter_options_set", subscription, filter_expression, expression_parameters_argc, expression_parameter_argv, options);
            }
            return (int)mh$.invokeExact(subscription, filter_expression, expression_parameters_argc, expression_parameter_argv, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_content_filter_options_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_content_filter_options_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_content_filter_options_fini(const rcl_subscription_t *subscription, rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_subscription_content_filter_options_fini$descriptor() {
        return rcl_subscription_content_filter_options_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_content_filter_options_fini(const rcl_subscription_t *subscription, rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static MethodHandle rcl_subscription_content_filter_options_fini$handle() {
        return rcl_subscription_content_filter_options_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_content_filter_options_fini(const rcl_subscription_t *subscription, rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static int rcl_subscription_content_filter_options_fini(MemorySegment subscription, MemorySegment options) {
        var mh$ = rcl_subscription_content_filter_options_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_content_filter_options_fini", subscription, options);
            }
            return (int)mh$.invokeExact(subscription, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_is_cft_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_is_cft_enabled"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_subscription_is_cft_enabled(const rcl_subscription_t *subscription)
     * }
     */
    public static FunctionDescriptor rcl_subscription_is_cft_enabled$descriptor() {
        return rcl_subscription_is_cft_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_subscription_is_cft_enabled(const rcl_subscription_t *subscription)
     * }
     */
    public static MethodHandle rcl_subscription_is_cft_enabled$handle() {
        return rcl_subscription_is_cft_enabled.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_subscription_is_cft_enabled(const rcl_subscription_t *subscription)
     * }
     */
    public static boolean rcl_subscription_is_cft_enabled(MemorySegment subscription) {
        var mh$ = rcl_subscription_is_cft_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_is_cft_enabled", subscription);
            }
            return (boolean)mh$.invokeExact(subscription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_set_content_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_set_content_filter"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_set_content_filter(const rcl_subscription_t *subscription, const rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_subscription_set_content_filter$descriptor() {
        return rcl_subscription_set_content_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_set_content_filter(const rcl_subscription_t *subscription, const rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static MethodHandle rcl_subscription_set_content_filter$handle() {
        return rcl_subscription_set_content_filter.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_set_content_filter(const rcl_subscription_t *subscription, const rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static int rcl_subscription_set_content_filter(MemorySegment subscription, MemorySegment options) {
        var mh$ = rcl_subscription_set_content_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_set_content_filter", subscription, options);
            }
            return (int)mh$.invokeExact(subscription, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_get_content_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_get_content_filter"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_get_content_filter(const rcl_subscription_t *subscription, rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_subscription_get_content_filter$descriptor() {
        return rcl_subscription_get_content_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_get_content_filter(const rcl_subscription_t *subscription, rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static MethodHandle rcl_subscription_get_content_filter$handle() {
        return rcl_subscription_get_content_filter.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_get_content_filter(const rcl_subscription_t *subscription, rcl_subscription_content_filter_options_t *options)
     * }
     */
    public static int rcl_subscription_get_content_filter(MemorySegment subscription, MemorySegment options) {
        var mh$ = rcl_subscription_get_content_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_get_content_filter", subscription, options);
            }
            return (int)mh$.invokeExact(subscription, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_take {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_take"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take(const rcl_subscription_t *subscription, void *ros_message, rmw_message_info_t *message_info, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rcl_take$descriptor() {
        return rcl_take.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take(const rcl_subscription_t *subscription, void *ros_message, rmw_message_info_t *message_info, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static MethodHandle rcl_take$handle() {
        return rcl_take.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_take(const rcl_subscription_t *subscription, void *ros_message, rmw_message_info_t *message_info, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static int rcl_take(MemorySegment subscription, MemorySegment ros_message, MemorySegment message_info, MemorySegment allocation) {
        var mh$ = rcl_take.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_take", subscription, ros_message, message_info, allocation);
            }
            return (int)mh$.invokeExact(subscription, ros_message, message_info, allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_take_sequence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_LONG,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_take_sequence"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_sequence(const rcl_subscription_t *subscription, size_t count, rmw_message_sequence_t *message_sequence, rmw_message_info_sequence_t *message_info_sequence, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rcl_take_sequence$descriptor() {
        return rcl_take_sequence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_sequence(const rcl_subscription_t *subscription, size_t count, rmw_message_sequence_t *message_sequence, rmw_message_info_sequence_t *message_info_sequence, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static MethodHandle rcl_take_sequence$handle() {
        return rcl_take_sequence.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_sequence(const rcl_subscription_t *subscription, size_t count, rmw_message_sequence_t *message_sequence, rmw_message_info_sequence_t *message_info_sequence, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static int rcl_take_sequence(MemorySegment subscription, long count, MemorySegment message_sequence, MemorySegment message_info_sequence, MemorySegment allocation) {
        var mh$ = rcl_take_sequence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_take_sequence", subscription, count, message_sequence, message_info_sequence, allocation);
            }
            return (int)mh$.invokeExact(subscription, count, message_sequence, message_info_sequence, allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_take_serialized_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_take_serialized_message"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_serialized_message(const rcl_subscription_t *subscription, rcl_serialized_message_t *serialized_message, rmw_message_info_t *message_info, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rcl_take_serialized_message$descriptor() {
        return rcl_take_serialized_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_serialized_message(const rcl_subscription_t *subscription, rcl_serialized_message_t *serialized_message, rmw_message_info_t *message_info, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static MethodHandle rcl_take_serialized_message$handle() {
        return rcl_take_serialized_message.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_serialized_message(const rcl_subscription_t *subscription, rcl_serialized_message_t *serialized_message, rmw_message_info_t *message_info, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static int rcl_take_serialized_message(MemorySegment subscription, MemorySegment serialized_message, MemorySegment message_info, MemorySegment allocation) {
        var mh$ = rcl_take_serialized_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_take_serialized_message", subscription, serialized_message, message_info, allocation);
            }
            return (int)mh$.invokeExact(subscription, serialized_message, message_info, allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_take_loaned_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_take_loaned_message"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_loaned_message(const rcl_subscription_t *subscription, void **loaned_message, rmw_message_info_t *message_info, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rcl_take_loaned_message$descriptor() {
        return rcl_take_loaned_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_loaned_message(const rcl_subscription_t *subscription, void **loaned_message, rmw_message_info_t *message_info, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static MethodHandle rcl_take_loaned_message$handle() {
        return rcl_take_loaned_message.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_loaned_message(const rcl_subscription_t *subscription, void **loaned_message, rmw_message_info_t *message_info, rmw_subscription_allocation_t *allocation)
     * }
     */
    public static int rcl_take_loaned_message(MemorySegment subscription, MemorySegment loaned_message, MemorySegment message_info, MemorySegment allocation) {
        var mh$ = rcl_take_loaned_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_take_loaned_message", subscription, loaned_message, message_info, allocation);
            }
            return (int)mh$.invokeExact(subscription, loaned_message, message_info, allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_return_loaned_message_from_subscription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_return_loaned_message_from_subscription"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_return_loaned_message_from_subscription(const rcl_subscription_t *subscription, void *loaned_message)
     * }
     */
    public static FunctionDescriptor rcl_return_loaned_message_from_subscription$descriptor() {
        return rcl_return_loaned_message_from_subscription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_return_loaned_message_from_subscription(const rcl_subscription_t *subscription, void *loaned_message)
     * }
     */
    public static MethodHandle rcl_return_loaned_message_from_subscription$handle() {
        return rcl_return_loaned_message_from_subscription.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_return_loaned_message_from_subscription(const rcl_subscription_t *subscription, void *loaned_message)
     * }
     */
    public static int rcl_return_loaned_message_from_subscription(MemorySegment subscription, MemorySegment loaned_message) {
        var mh$ = rcl_return_loaned_message_from_subscription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_return_loaned_message_from_subscription", subscription, loaned_message);
            }
            return (int)mh$.invokeExact(subscription, loaned_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_get_topic_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_get_topic_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rcl_subscription_get_topic_name(const rcl_subscription_t *subscription)
     * }
     */
    public static FunctionDescriptor rcl_subscription_get_topic_name$descriptor() {
        return rcl_subscription_get_topic_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rcl_subscription_get_topic_name(const rcl_subscription_t *subscription)
     * }
     */
    public static MethodHandle rcl_subscription_get_topic_name$handle() {
        return rcl_subscription_get_topic_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rcl_subscription_get_topic_name(const rcl_subscription_t *subscription)
     * }
     */
    public static MemorySegment rcl_subscription_get_topic_name(MemorySegment subscription) {
        var mh$ = rcl_subscription_get_topic_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_get_topic_name", subscription);
            }
            return (MemorySegment)mh$.invokeExact(subscription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_get_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_get_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rcl_subscription_options_t *rcl_subscription_get_options(const rcl_subscription_t *subscription)
     * }
     */
    public static FunctionDescriptor rcl_subscription_get_options$descriptor() {
        return rcl_subscription_get_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rcl_subscription_options_t *rcl_subscription_get_options(const rcl_subscription_t *subscription)
     * }
     */
    public static MethodHandle rcl_subscription_get_options$handle() {
        return rcl_subscription_get_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rcl_subscription_options_t *rcl_subscription_get_options(const rcl_subscription_t *subscription)
     * }
     */
    public static MemorySegment rcl_subscription_get_options(MemorySegment subscription) {
        var mh$ = rcl_subscription_get_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_get_options", subscription);
            }
            return (MemorySegment)mh$.invokeExact(subscription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_get_rmw_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_get_rmw_handle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_subscription_t *rcl_subscription_get_rmw_handle(const rcl_subscription_t *subscription)
     * }
     */
    public static FunctionDescriptor rcl_subscription_get_rmw_handle$descriptor() {
        return rcl_subscription_get_rmw_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_subscription_t *rcl_subscription_get_rmw_handle(const rcl_subscription_t *subscription)
     * }
     */
    public static MethodHandle rcl_subscription_get_rmw_handle$handle() {
        return rcl_subscription_get_rmw_handle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_subscription_t *rcl_subscription_get_rmw_handle(const rcl_subscription_t *subscription)
     * }
     */
    public static MemorySegment rcl_subscription_get_rmw_handle(MemorySegment subscription) {
        var mh$ = rcl_subscription_get_rmw_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_get_rmw_handle", subscription);
            }
            return (MemorySegment)mh$.invokeExact(subscription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_is_valid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_subscription_is_valid(const rcl_subscription_t *subscription)
     * }
     */
    public static FunctionDescriptor rcl_subscription_is_valid$descriptor() {
        return rcl_subscription_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_subscription_is_valid(const rcl_subscription_t *subscription)
     * }
     */
    public static MethodHandle rcl_subscription_is_valid$handle() {
        return rcl_subscription_is_valid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_subscription_is_valid(const rcl_subscription_t *subscription)
     * }
     */
    public static boolean rcl_subscription_is_valid(MemorySegment subscription) {
        var mh$ = rcl_subscription_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_is_valid", subscription);
            }
            return (boolean)mh$.invokeExact(subscription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_get_publisher_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_get_publisher_count"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rcl_subscription_get_publisher_count(const rcl_subscription_t *subscription, size_t *publisher_count)
     * }
     */
    public static FunctionDescriptor rcl_subscription_get_publisher_count$descriptor() {
        return rcl_subscription_get_publisher_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rcl_subscription_get_publisher_count(const rcl_subscription_t *subscription, size_t *publisher_count)
     * }
     */
    public static MethodHandle rcl_subscription_get_publisher_count$handle() {
        return rcl_subscription_get_publisher_count.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rcl_subscription_get_publisher_count(const rcl_subscription_t *subscription, size_t *publisher_count)
     * }
     */
    public static int rcl_subscription_get_publisher_count(MemorySegment subscription, MemorySegment publisher_count) {
        var mh$ = rcl_subscription_get_publisher_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_get_publisher_count", subscription, publisher_count);
            }
            return (int)mh$.invokeExact(subscription, publisher_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_get_actual_qos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_get_actual_qos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_subscription_get_actual_qos(const rcl_subscription_t *subscription)
     * }
     */
    public static FunctionDescriptor rcl_subscription_get_actual_qos$descriptor() {
        return rcl_subscription_get_actual_qos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_subscription_get_actual_qos(const rcl_subscription_t *subscription)
     * }
     */
    public static MethodHandle rcl_subscription_get_actual_qos$handle() {
        return rcl_subscription_get_actual_qos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_subscription_get_actual_qos(const rcl_subscription_t *subscription)
     * }
     */
    public static MemorySegment rcl_subscription_get_actual_qos(MemorySegment subscription) {
        var mh$ = rcl_subscription_get_actual_qos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_get_actual_qos", subscription);
            }
            return (MemorySegment)mh$.invokeExact(subscription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_can_loan_messages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_can_loan_messages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_subscription_can_loan_messages(const rcl_subscription_t *subscription)
     * }
     */
    public static FunctionDescriptor rcl_subscription_can_loan_messages$descriptor() {
        return rcl_subscription_can_loan_messages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_subscription_can_loan_messages(const rcl_subscription_t *subscription)
     * }
     */
    public static MethodHandle rcl_subscription_can_loan_messages$handle() {
        return rcl_subscription_can_loan_messages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_subscription_can_loan_messages(const rcl_subscription_t *subscription)
     * }
     */
    public static boolean rcl_subscription_can_loan_messages(MemorySegment subscription) {
        var mh$ = rcl_subscription_can_loan_messages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_can_loan_messages", subscription);
            }
            return (boolean)mh$.invokeExact(subscription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_subscription_set_on_new_message_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_subscription_set_on_new_message_callback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_set_on_new_message_callback(const rcl_subscription_t *subscription, rcl_event_callback_t callback, const void *user_data)
     * }
     */
    public static FunctionDescriptor rcl_subscription_set_on_new_message_callback$descriptor() {
        return rcl_subscription_set_on_new_message_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_set_on_new_message_callback(const rcl_subscription_t *subscription, rcl_event_callback_t callback, const void *user_data)
     * }
     */
    public static MethodHandle rcl_subscription_set_on_new_message_callback$handle() {
        return rcl_subscription_set_on_new_message_callback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_subscription_set_on_new_message_callback(const rcl_subscription_t *subscription, rcl_event_callback_t callback, const void *user_data)
     * }
     */
    public static int rcl_subscription_set_on_new_message_callback(MemorySegment subscription, MemorySegment callback, MemorySegment user_data) {
        var mh$ = rcl_subscription_set_on_new_message_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_subscription_set_on_new_message_callback", subscription, callback, user_data);
            }
            return (int)mh$.invokeExact(subscription, callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_service_typesupport_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("get_service_typesupport_handle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rosidl_service_type_support_t *get_service_typesupport_handle(const rosidl_service_type_support_t *handle, const char *identifier)
     * }
     */
    public static FunctionDescriptor get_service_typesupport_handle$descriptor() {
        return get_service_typesupport_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rosidl_service_type_support_t *get_service_typesupport_handle(const rosidl_service_type_support_t *handle, const char *identifier)
     * }
     */
    public static MethodHandle get_service_typesupport_handle$handle() {
        return get_service_typesupport_handle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rosidl_service_type_support_t *get_service_typesupport_handle(const rosidl_service_type_support_t *handle, const char *identifier)
     * }
     */
    public static MemorySegment get_service_typesupport_handle(MemorySegment handle, MemorySegment identifier) {
        var mh$ = get_service_typesupport_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_service_typesupport_handle", handle, identifier);
            }
            return (MemorySegment)mh$.invokeExact(handle, identifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_service_typesupport_handle_function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("get_service_typesupport_handle_function"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rosidl_service_type_support_t *get_service_typesupport_handle_function(const rosidl_service_type_support_t *handle, const char *identifier)
     * }
     */
    public static FunctionDescriptor get_service_typesupport_handle_function$descriptor() {
        return get_service_typesupport_handle_function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rosidl_service_type_support_t *get_service_typesupport_handle_function(const rosidl_service_type_support_t *handle, const char *identifier)
     * }
     */
    public static MethodHandle get_service_typesupport_handle_function$handle() {
        return get_service_typesupport_handle_function.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rosidl_service_type_support_t *get_service_typesupport_handle_function(const rosidl_service_type_support_t *handle, const char *identifier)
     * }
     */
    public static MemorySegment get_service_typesupport_handle_function(MemorySegment handle, MemorySegment identifier) {
        var mh$ = get_service_typesupport_handle_function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_service_typesupport_handle_function", handle, identifier);
            }
            return (MemorySegment)mh$.invokeExact(handle, identifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_get_zero_initialized_client {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_client_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_zero_initialized_client"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_client_t rcl_get_zero_initialized_client()
     * }
     */
    public static FunctionDescriptor rcl_get_zero_initialized_client$descriptor() {
        return rcl_get_zero_initialized_client.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_client_t rcl_get_zero_initialized_client()
     * }
     */
    public static MethodHandle rcl_get_zero_initialized_client$handle() {
        return rcl_get_zero_initialized_client.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_client_t rcl_get_zero_initialized_client()
     * }
     */
    public static MemorySegment rcl_get_zero_initialized_client(SegmentAllocator allocator) {
        var mh$ = rcl_get_zero_initialized_client.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_zero_initialized_client", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_client_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_client_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_client_init(rcl_client_t *client, const rcl_node_t *node, const rosidl_service_type_support_t *type_support, const char *service_name, const rcl_client_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_client_init$descriptor() {
        return rcl_client_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_client_init(rcl_client_t *client, const rcl_node_t *node, const rosidl_service_type_support_t *type_support, const char *service_name, const rcl_client_options_t *options)
     * }
     */
    public static MethodHandle rcl_client_init$handle() {
        return rcl_client_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_client_init(rcl_client_t *client, const rcl_node_t *node, const rosidl_service_type_support_t *type_support, const char *service_name, const rcl_client_options_t *options)
     * }
     */
    public static int rcl_client_init(MemorySegment client, MemorySegment node, MemorySegment type_support, MemorySegment service_name, MemorySegment options) {
        var mh$ = rcl_client_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_client_init", client, node, type_support, service_name, options);
            }
            return (int)mh$.invokeExact(client, node, type_support, service_name, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_client_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_client_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_client_fini(rcl_client_t *client, rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_client_fini$descriptor() {
        return rcl_client_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_client_fini(rcl_client_t *client, rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_client_fini$handle() {
        return rcl_client_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_client_fini(rcl_client_t *client, rcl_node_t *node)
     * }
     */
    public static int rcl_client_fini(MemorySegment client, MemorySegment node) {
        var mh$ = rcl_client_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_client_fini", client, node);
            }
            return (int)mh$.invokeExact(client, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_client_get_default_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_client_options_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_client_get_default_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_client_options_t rcl_client_get_default_options()
     * }
     */
    public static FunctionDescriptor rcl_client_get_default_options$descriptor() {
        return rcl_client_get_default_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_client_options_t rcl_client_get_default_options()
     * }
     */
    public static MethodHandle rcl_client_get_default_options$handle() {
        return rcl_client_get_default_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_client_options_t rcl_client_get_default_options()
     * }
     */
    public static MemorySegment rcl_client_get_default_options(SegmentAllocator allocator) {
        var mh$ = rcl_client_get_default_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_client_get_default_options", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_send_request {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_send_request"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_send_request(const rcl_client_t *client, const void *ros_request, int64_t *sequence_number)
     * }
     */
    public static FunctionDescriptor rcl_send_request$descriptor() {
        return rcl_send_request.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_send_request(const rcl_client_t *client, const void *ros_request, int64_t *sequence_number)
     * }
     */
    public static MethodHandle rcl_send_request$handle() {
        return rcl_send_request.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_send_request(const rcl_client_t *client, const void *ros_request, int64_t *sequence_number)
     * }
     */
    public static int rcl_send_request(MemorySegment client, MemorySegment ros_request, MemorySegment sequence_number) {
        var mh$ = rcl_send_request.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_send_request", client, ros_request, sequence_number);
            }
            return (int)mh$.invokeExact(client, ros_request, sequence_number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_take_response_with_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_take_response_with_info"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_response_with_info(const rcl_client_t *client, rmw_service_info_t *request_header, void *ros_response)
     * }
     */
    public static FunctionDescriptor rcl_take_response_with_info$descriptor() {
        return rcl_take_response_with_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_response_with_info(const rcl_client_t *client, rmw_service_info_t *request_header, void *ros_response)
     * }
     */
    public static MethodHandle rcl_take_response_with_info$handle() {
        return rcl_take_response_with_info.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_response_with_info(const rcl_client_t *client, rmw_service_info_t *request_header, void *ros_response)
     * }
     */
    public static int rcl_take_response_with_info(MemorySegment client, MemorySegment request_header, MemorySegment ros_response) {
        var mh$ = rcl_take_response_with_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_take_response_with_info", client, request_header, ros_response);
            }
            return (int)mh$.invokeExact(client, request_header, ros_response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_take_response {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_take_response"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_response(const rcl_client_t *client, rmw_request_id_t *request_header, void *ros_response)
     * }
     */
    public static FunctionDescriptor rcl_take_response$descriptor() {
        return rcl_take_response.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_response(const rcl_client_t *client, rmw_request_id_t *request_header, void *ros_response)
     * }
     */
    public static MethodHandle rcl_take_response$handle() {
        return rcl_take_response.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_response(const rcl_client_t *client, rmw_request_id_t *request_header, void *ros_response)
     * }
     */
    public static int rcl_take_response(MemorySegment client, MemorySegment request_header, MemorySegment ros_response) {
        var mh$ = rcl_take_response.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_take_response", client, request_header, ros_response);
            }
            return (int)mh$.invokeExact(client, request_header, ros_response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_client_get_service_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_client_get_service_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rcl_client_get_service_name(const rcl_client_t *client)
     * }
     */
    public static FunctionDescriptor rcl_client_get_service_name$descriptor() {
        return rcl_client_get_service_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rcl_client_get_service_name(const rcl_client_t *client)
     * }
     */
    public static MethodHandle rcl_client_get_service_name$handle() {
        return rcl_client_get_service_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rcl_client_get_service_name(const rcl_client_t *client)
     * }
     */
    public static MemorySegment rcl_client_get_service_name(MemorySegment client) {
        var mh$ = rcl_client_get_service_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_client_get_service_name", client);
            }
            return (MemorySegment)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_client_get_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_client_get_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rcl_client_options_t *rcl_client_get_options(const rcl_client_t *client)
     * }
     */
    public static FunctionDescriptor rcl_client_get_options$descriptor() {
        return rcl_client_get_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rcl_client_options_t *rcl_client_get_options(const rcl_client_t *client)
     * }
     */
    public static MethodHandle rcl_client_get_options$handle() {
        return rcl_client_get_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rcl_client_options_t *rcl_client_get_options(const rcl_client_t *client)
     * }
     */
    public static MemorySegment rcl_client_get_options(MemorySegment client) {
        var mh$ = rcl_client_get_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_client_get_options", client);
            }
            return (MemorySegment)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_client_get_rmw_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_client_get_rmw_handle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_client_t *rcl_client_get_rmw_handle(const rcl_client_t *client)
     * }
     */
    public static FunctionDescriptor rcl_client_get_rmw_handle$descriptor() {
        return rcl_client_get_rmw_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_client_t *rcl_client_get_rmw_handle(const rcl_client_t *client)
     * }
     */
    public static MethodHandle rcl_client_get_rmw_handle$handle() {
        return rcl_client_get_rmw_handle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_client_t *rcl_client_get_rmw_handle(const rcl_client_t *client)
     * }
     */
    public static MemorySegment rcl_client_get_rmw_handle(MemorySegment client) {
        var mh$ = rcl_client_get_rmw_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_client_get_rmw_handle", client);
            }
            return (MemorySegment)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_client_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_client_is_valid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_client_is_valid(const rcl_client_t *client)
     * }
     */
    public static FunctionDescriptor rcl_client_is_valid$descriptor() {
        return rcl_client_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_client_is_valid(const rcl_client_t *client)
     * }
     */
    public static MethodHandle rcl_client_is_valid$handle() {
        return rcl_client_is_valid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_client_is_valid(const rcl_client_t *client)
     * }
     */
    public static boolean rcl_client_is_valid(MemorySegment client) {
        var mh$ = rcl_client_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_client_is_valid", client);
            }
            return (boolean)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_client_request_publisher_get_actual_qos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_client_request_publisher_get_actual_qos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_client_request_publisher_get_actual_qos(const rcl_client_t *client)
     * }
     */
    public static FunctionDescriptor rcl_client_request_publisher_get_actual_qos$descriptor() {
        return rcl_client_request_publisher_get_actual_qos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_client_request_publisher_get_actual_qos(const rcl_client_t *client)
     * }
     */
    public static MethodHandle rcl_client_request_publisher_get_actual_qos$handle() {
        return rcl_client_request_publisher_get_actual_qos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_client_request_publisher_get_actual_qos(const rcl_client_t *client)
     * }
     */
    public static MemorySegment rcl_client_request_publisher_get_actual_qos(MemorySegment client) {
        var mh$ = rcl_client_request_publisher_get_actual_qos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_client_request_publisher_get_actual_qos", client);
            }
            return (MemorySegment)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_client_response_subscription_get_actual_qos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_client_response_subscription_get_actual_qos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_client_response_subscription_get_actual_qos(const rcl_client_t *client)
     * }
     */
    public static FunctionDescriptor rcl_client_response_subscription_get_actual_qos$descriptor() {
        return rcl_client_response_subscription_get_actual_qos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_client_response_subscription_get_actual_qos(const rcl_client_t *client)
     * }
     */
    public static MethodHandle rcl_client_response_subscription_get_actual_qos$handle() {
        return rcl_client_response_subscription_get_actual_qos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_client_response_subscription_get_actual_qos(const rcl_client_t *client)
     * }
     */
    public static MemorySegment rcl_client_response_subscription_get_actual_qos(MemorySegment client) {
        var mh$ = rcl_client_response_subscription_get_actual_qos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_client_response_subscription_get_actual_qos", client);
            }
            return (MemorySegment)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_client_set_on_new_response_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_client_set_on_new_response_callback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_client_set_on_new_response_callback(const rcl_client_t *client, rcl_event_callback_t callback, const void *user_data)
     * }
     */
    public static FunctionDescriptor rcl_client_set_on_new_response_callback$descriptor() {
        return rcl_client_set_on_new_response_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_client_set_on_new_response_callback(const rcl_client_t *client, rcl_event_callback_t callback, const void *user_data)
     * }
     */
    public static MethodHandle rcl_client_set_on_new_response_callback$handle() {
        return rcl_client_set_on_new_response_callback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_client_set_on_new_response_callback(const rcl_client_t *client, rcl_event_callback_t callback, const void *user_data)
     * }
     */
    public static int rcl_client_set_on_new_response_callback(MemorySegment client, MemorySegment callback, MemorySegment user_data) {
        var mh$ = rcl_client_set_on_new_response_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_client_set_on_new_response_callback", client, callback, user_data);
            }
            return (int)mh$.invokeExact(client, callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_get_zero_initialized_service {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_service_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_get_zero_initialized_service"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_service_t rcl_get_zero_initialized_service()
     * }
     */
    public static FunctionDescriptor rcl_get_zero_initialized_service$descriptor() {
        return rcl_get_zero_initialized_service.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_service_t rcl_get_zero_initialized_service()
     * }
     */
    public static MethodHandle rcl_get_zero_initialized_service$handle() {
        return rcl_get_zero_initialized_service.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_service_t rcl_get_zero_initialized_service()
     * }
     */
    public static MemorySegment rcl_get_zero_initialized_service(SegmentAllocator allocator) {
        var mh$ = rcl_get_zero_initialized_service.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_get_zero_initialized_service", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_service_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_service_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_service_init(rcl_service_t *service, const rcl_node_t *node, const rosidl_service_type_support_t *type_support, const char *service_name, const rcl_service_options_t *options)
     * }
     */
    public static FunctionDescriptor rcl_service_init$descriptor() {
        return rcl_service_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_service_init(rcl_service_t *service, const rcl_node_t *node, const rosidl_service_type_support_t *type_support, const char *service_name, const rcl_service_options_t *options)
     * }
     */
    public static MethodHandle rcl_service_init$handle() {
        return rcl_service_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_service_init(rcl_service_t *service, const rcl_node_t *node, const rosidl_service_type_support_t *type_support, const char *service_name, const rcl_service_options_t *options)
     * }
     */
    public static int rcl_service_init(MemorySegment service, MemorySegment node, MemorySegment type_support, MemorySegment service_name, MemorySegment options) {
        var mh$ = rcl_service_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_service_init", service, node, type_support, service_name, options);
            }
            return (int)mh$.invokeExact(service, node, type_support, service_name, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_service_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_service_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_service_fini(rcl_service_t *service, rcl_node_t *node)
     * }
     */
    public static FunctionDescriptor rcl_service_fini$descriptor() {
        return rcl_service_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_service_fini(rcl_service_t *service, rcl_node_t *node)
     * }
     */
    public static MethodHandle rcl_service_fini$handle() {
        return rcl_service_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_service_fini(rcl_service_t *service, rcl_node_t *node)
     * }
     */
    public static int rcl_service_fini(MemorySegment service, MemorySegment node) {
        var mh$ = rcl_service_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_service_fini", service, node);
            }
            return (int)mh$.invokeExact(service, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_service_get_default_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rcl_service_options_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_service_get_default_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_service_options_t rcl_service_get_default_options()
     * }
     */
    public static FunctionDescriptor rcl_service_get_default_options$descriptor() {
        return rcl_service_get_default_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_service_options_t rcl_service_get_default_options()
     * }
     */
    public static MethodHandle rcl_service_get_default_options$handle() {
        return rcl_service_get_default_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_service_options_t rcl_service_get_default_options()
     * }
     */
    public static MemorySegment rcl_service_get_default_options(SegmentAllocator allocator) {
        var mh$ = rcl_service_get_default_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_service_get_default_options", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_take_request_with_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_take_request_with_info"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_request_with_info(const rcl_service_t *service, rmw_service_info_t *request_header, void *ros_request)
     * }
     */
    public static FunctionDescriptor rcl_take_request_with_info$descriptor() {
        return rcl_take_request_with_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_request_with_info(const rcl_service_t *service, rmw_service_info_t *request_header, void *ros_request)
     * }
     */
    public static MethodHandle rcl_take_request_with_info$handle() {
        return rcl_take_request_with_info.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_request_with_info(const rcl_service_t *service, rmw_service_info_t *request_header, void *ros_request)
     * }
     */
    public static int rcl_take_request_with_info(MemorySegment service, MemorySegment request_header, MemorySegment ros_request) {
        var mh$ = rcl_take_request_with_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_take_request_with_info", service, request_header, ros_request);
            }
            return (int)mh$.invokeExact(service, request_header, ros_request);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_take_request {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_take_request"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_request(const rcl_service_t *service, rmw_request_id_t *request_header, void *ros_request)
     * }
     */
    public static FunctionDescriptor rcl_take_request$descriptor() {
        return rcl_take_request.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_request(const rcl_service_t *service, rmw_request_id_t *request_header, void *ros_request)
     * }
     */
    public static MethodHandle rcl_take_request$handle() {
        return rcl_take_request.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_take_request(const rcl_service_t *service, rmw_request_id_t *request_header, void *ros_request)
     * }
     */
    public static int rcl_take_request(MemorySegment service, MemorySegment request_header, MemorySegment ros_request) {
        var mh$ = rcl_take_request.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_take_request", service, request_header, ros_request);
            }
            return (int)mh$.invokeExact(service, request_header, ros_request);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_send_response {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_send_response"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_send_response(const rcl_service_t *service, rmw_request_id_t *response_header, void *ros_response)
     * }
     */
    public static FunctionDescriptor rcl_send_response$descriptor() {
        return rcl_send_response.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_send_response(const rcl_service_t *service, rmw_request_id_t *response_header, void *ros_response)
     * }
     */
    public static MethodHandle rcl_send_response$handle() {
        return rcl_send_response.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_send_response(const rcl_service_t *service, rmw_request_id_t *response_header, void *ros_response)
     * }
     */
    public static int rcl_send_response(MemorySegment service, MemorySegment response_header, MemorySegment ros_response) {
        var mh$ = rcl_send_response.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_send_response", service, response_header, ros_response);
            }
            return (int)mh$.invokeExact(service, response_header, ros_response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_service_get_service_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_service_get_service_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rcl_service_get_service_name(const rcl_service_t *service)
     * }
     */
    public static FunctionDescriptor rcl_service_get_service_name$descriptor() {
        return rcl_service_get_service_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rcl_service_get_service_name(const rcl_service_t *service)
     * }
     */
    public static MethodHandle rcl_service_get_service_name$handle() {
        return rcl_service_get_service_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rcl_service_get_service_name(const rcl_service_t *service)
     * }
     */
    public static MemorySegment rcl_service_get_service_name(MemorySegment service) {
        var mh$ = rcl_service_get_service_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_service_get_service_name", service);
            }
            return (MemorySegment)mh$.invokeExact(service);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_service_get_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_service_get_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rcl_service_options_t *rcl_service_get_options(const rcl_service_t *service)
     * }
     */
    public static FunctionDescriptor rcl_service_get_options$descriptor() {
        return rcl_service_get_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rcl_service_options_t *rcl_service_get_options(const rcl_service_t *service)
     * }
     */
    public static MethodHandle rcl_service_get_options$handle() {
        return rcl_service_get_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rcl_service_options_t *rcl_service_get_options(const rcl_service_t *service)
     * }
     */
    public static MemorySegment rcl_service_get_options(MemorySegment service) {
        var mh$ = rcl_service_get_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_service_get_options", service);
            }
            return (MemorySegment)mh$.invokeExact(service);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_service_get_rmw_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_service_get_rmw_handle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_service_t *rcl_service_get_rmw_handle(const rcl_service_t *service)
     * }
     */
    public static FunctionDescriptor rcl_service_get_rmw_handle$descriptor() {
        return rcl_service_get_rmw_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_service_t *rcl_service_get_rmw_handle(const rcl_service_t *service)
     * }
     */
    public static MethodHandle rcl_service_get_rmw_handle$handle() {
        return rcl_service_get_rmw_handle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_service_t *rcl_service_get_rmw_handle(const rcl_service_t *service)
     * }
     */
    public static MemorySegment rcl_service_get_rmw_handle(MemorySegment service) {
        var mh$ = rcl_service_get_rmw_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_service_get_rmw_handle", service);
            }
            return (MemorySegment)mh$.invokeExact(service);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_service_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_BOOL,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_service_is_valid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rcl_service_is_valid(const rcl_service_t *service)
     * }
     */
    public static FunctionDescriptor rcl_service_is_valid$descriptor() {
        return rcl_service_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rcl_service_is_valid(const rcl_service_t *service)
     * }
     */
    public static MethodHandle rcl_service_is_valid$handle() {
        return rcl_service_is_valid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * bool rcl_service_is_valid(const rcl_service_t *service)
     * }
     */
    public static boolean rcl_service_is_valid(MemorySegment service) {
        var mh$ = rcl_service_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_service_is_valid", service);
            }
            return (boolean)mh$.invokeExact(service);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_service_request_subscription_get_actual_qos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_service_request_subscription_get_actual_qos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_service_request_subscription_get_actual_qos(const rcl_service_t *service)
     * }
     */
    public static FunctionDescriptor rcl_service_request_subscription_get_actual_qos$descriptor() {
        return rcl_service_request_subscription_get_actual_qos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_service_request_subscription_get_actual_qos(const rcl_service_t *service)
     * }
     */
    public static MethodHandle rcl_service_request_subscription_get_actual_qos$handle() {
        return rcl_service_request_subscription_get_actual_qos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_service_request_subscription_get_actual_qos(const rcl_service_t *service)
     * }
     */
    public static MemorySegment rcl_service_request_subscription_get_actual_qos(MemorySegment service) {
        var mh$ = rcl_service_request_subscription_get_actual_qos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_service_request_subscription_get_actual_qos", service);
            }
            return (MemorySegment)mh$.invokeExact(service);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_service_response_publisher_get_actual_qos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_service_response_publisher_get_actual_qos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_service_response_publisher_get_actual_qos(const rcl_service_t *service)
     * }
     */
    public static FunctionDescriptor rcl_service_response_publisher_get_actual_qos$descriptor() {
        return rcl_service_response_publisher_get_actual_qos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_service_response_publisher_get_actual_qos(const rcl_service_t *service)
     * }
     */
    public static MethodHandle rcl_service_response_publisher_get_actual_qos$handle() {
        return rcl_service_response_publisher_get_actual_qos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rmw_qos_profile_t *rcl_service_response_publisher_get_actual_qos(const rcl_service_t *service)
     * }
     */
    public static MemorySegment rcl_service_response_publisher_get_actual_qos(MemorySegment service) {
        var mh$ = rcl_service_response_publisher_get_actual_qos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_service_response_publisher_get_actual_qos", service);
            }
            return (MemorySegment)mh$.invokeExact(service);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcl_service_set_on_new_request_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rcl_service_set_on_new_request_callback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_service_set_on_new_request_callback(const rcl_service_t *service, rcl_event_callback_t callback, const void *user_data)
     * }
     */
    public static FunctionDescriptor rcl_service_set_on_new_request_callback$descriptor() {
        return rcl_service_set_on_new_request_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rcl_ret_t rcl_service_set_on_new_request_callback(const rcl_service_t *service, rcl_event_callback_t callback, const void *user_data)
     * }
     */
    public static MethodHandle rcl_service_set_on_new_request_callback$handle() {
        return rcl_service_set_on_new_request_callback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rcl_ret_t rcl_service_set_on_new_request_callback(const rcl_service_t *service, rcl_event_callback_t callback, const void *user_data)
     * }
     */
    public static int rcl_service_set_on_new_request_callback(MemorySegment service, MemorySegment callback, MemorySegment user_data) {
        var mh$ = rcl_service_set_on_new_request_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcl_service_set_on_new_request_callback", service, callback, user_data);
            }
            return (int)mh$.invokeExact(service, callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_sequence_bound_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("get_sequence_bound_handle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rosidl_runtime_c__Sequence__bound *get_sequence_bound_handle(const rosidl_runtime_c__Sequence__bound *handle, const char *identifier)
     * }
     */
    public static FunctionDescriptor get_sequence_bound_handle$descriptor() {
        return get_sequence_bound_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rosidl_runtime_c__Sequence__bound *get_sequence_bound_handle(const rosidl_runtime_c__Sequence__bound *handle, const char *identifier)
     * }
     */
    public static MethodHandle get_sequence_bound_handle$handle() {
        return get_sequence_bound_handle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rosidl_runtime_c__Sequence__bound *get_sequence_bound_handle(const rosidl_runtime_c__Sequence__bound *handle, const char *identifier)
     * }
     */
    public static MemorySegment get_sequence_bound_handle(MemorySegment handle, MemorySegment identifier) {
        var mh$ = get_sequence_bound_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_sequence_bound_handle", handle, identifier);
            }
            return (MemorySegment)mh$.invokeExact(handle, identifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_sequence_bound_handle_function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("get_sequence_bound_handle_function"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rosidl_runtime_c__Sequence__bound *get_sequence_bound_handle_function(const rosidl_runtime_c__Sequence__bound *handle, const char *identifier)
     * }
     */
    public static FunctionDescriptor get_sequence_bound_handle_function$descriptor() {
        return get_sequence_bound_handle_function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rosidl_runtime_c__Sequence__bound *get_sequence_bound_handle_function(const rosidl_runtime_c__Sequence__bound *handle, const char *identifier)
     * }
     */
    public static MethodHandle get_sequence_bound_handle_function$handle() {
        return get_sequence_bound_handle_function.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rosidl_runtime_c__Sequence__bound *get_sequence_bound_handle_function(const rosidl_runtime_c__Sequence__bound *handle, const char *identifier)
     * }
     */
    public static MemorySegment get_sequence_bound_handle_function(MemorySegment handle, MemorySegment identifier) {
        var mh$ = get_sequence_bound_handle_function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_sequence_bound_handle_function", handle, identifier);
            }
            return (MemorySegment)mh$.invokeExact(handle, identifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RMW_EVENT_LIVELINESS_CHANGED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rmw_event_type_e.RMW_EVENT_LIVELINESS_CHANGED = 0
     * }
     */
    public static int RMW_EVENT_LIVELINESS_CHANGED() {
        return RMW_EVENT_LIVELINESS_CHANGED;
    }
    private static final int RMW_EVENT_REQUESTED_DEADLINE_MISSED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rmw_event_type_e.RMW_EVENT_REQUESTED_DEADLINE_MISSED = 1
     * }
     */
    public static int RMW_EVENT_REQUESTED_DEADLINE_MISSED() {
        return RMW_EVENT_REQUESTED_DEADLINE_MISSED;
    }
    private static final int RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rmw_event_type_e.RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE = 2
     * }
     */
    public static int RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE() {
        return RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE;
    }
    private static final int RMW_EVENT_MESSAGE_LOST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum rmw_event_type_e.RMW_EVENT_MESSAGE_LOST = 3
     * }
     */
    public static int RMW_EVENT_MESSAGE_LOST() {
        return RMW_EVENT_MESSAGE_LOST;
    }
    private static final int RMW_EVENT_LIVELINESS_LOST = (int)4L;
    /**
     * {@snippet lang=c :
     * enum rmw_event_type_e.RMW_EVENT_LIVELINESS_LOST = 4
     * }
     */
    public static int RMW_EVENT_LIVELINESS_LOST() {
        return RMW_EVENT_LIVELINESS_LOST;
    }
    private static final int RMW_EVENT_OFFERED_DEADLINE_MISSED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum rmw_event_type_e.RMW_EVENT_OFFERED_DEADLINE_MISSED = 5
     * }
     */
    public static int RMW_EVENT_OFFERED_DEADLINE_MISSED() {
        return RMW_EVENT_OFFERED_DEADLINE_MISSED;
    }
    private static final int RMW_EVENT_OFFERED_QOS_INCOMPATIBLE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum rmw_event_type_e.RMW_EVENT_OFFERED_QOS_INCOMPATIBLE = 6
     * }
     */
    public static int RMW_EVENT_OFFERED_QOS_INCOMPATIBLE() {
        return RMW_EVENT_OFFERED_QOS_INCOMPATIBLE;
    }
    private static final int RMW_EVENT_INVALID = (int)7L;
    /**
     * {@snippet lang=c :
     * enum rmw_event_type_e.RMW_EVENT_INVALID = 7
     * }
     */
    public static int RMW_EVENT_INVALID() {
        return RMW_EVENT_INVALID;
    }

    private static class rmw_get_zero_initialized_event {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rmw_event_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_get_zero_initialized_event"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_event_t rmw_get_zero_initialized_event()
     * }
     */
    public static FunctionDescriptor rmw_get_zero_initialized_event$descriptor() {
        return rmw_get_zero_initialized_event.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_event_t rmw_get_zero_initialized_event()
     * }
     */
    public static MethodHandle rmw_get_zero_initialized_event$handle() {
        return rmw_get_zero_initialized_event.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_event_t rmw_get_zero_initialized_event()
     * }
     */
    public static MemorySegment rmw_get_zero_initialized_event(SegmentAllocator allocator) {
        var mh$ = rmw_get_zero_initialized_event.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_get_zero_initialized_event", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_publisher_event_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_publisher_event_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_event_init(rmw_event_t *rmw_event, const rmw_publisher_t *publisher, rmw_event_type_t event_type)
     * }
     */
    public static FunctionDescriptor rmw_publisher_event_init$descriptor() {
        return rmw_publisher_event_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_event_init(rmw_event_t *rmw_event, const rmw_publisher_t *publisher, rmw_event_type_t event_type)
     * }
     */
    public static MethodHandle rmw_publisher_event_init$handle() {
        return rmw_publisher_event_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_event_init(rmw_event_t *rmw_event, const rmw_publisher_t *publisher, rmw_event_type_t event_type)
     * }
     */
    public static int rmw_publisher_event_init(MemorySegment rmw_event, MemorySegment publisher, int event_type) {
        var mh$ = rmw_publisher_event_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_publisher_event_init", rmw_event, publisher, event_type);
            }
            return (int)mh$.invokeExact(rmw_event, publisher, event_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_subscription_event_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_subscription_event_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_event_init(rmw_event_t *rmw_event, const rmw_subscription_t *subscription, rmw_event_type_t event_type)
     * }
     */
    public static FunctionDescriptor rmw_subscription_event_init$descriptor() {
        return rmw_subscription_event_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_event_init(rmw_event_t *rmw_event, const rmw_subscription_t *subscription, rmw_event_type_t event_type)
     * }
     */
    public static MethodHandle rmw_subscription_event_init$handle() {
        return rmw_subscription_event_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_subscription_event_init(rmw_event_t *rmw_event, const rmw_subscription_t *subscription, rmw_event_type_t event_type)
     * }
     */
    public static int rmw_subscription_event_init(MemorySegment rmw_event, MemorySegment subscription, int event_type) {
        var mh$ = rmw_subscription_event_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_subscription_event_init", rmw_event, subscription, event_type);
            }
            return (int)mh$.invokeExact(rmw_event, subscription, event_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_take_event {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_take_event"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_take_event(const rmw_event_t *event_handle, void *event_info, bool *taken)
     * }
     */
    public static FunctionDescriptor rmw_take_event$descriptor() {
        return rmw_take_event.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_take_event(const rmw_event_t *event_handle, void *event_info, bool *taken)
     * }
     */
    public static MethodHandle rmw_take_event$handle() {
        return rmw_take_event.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_take_event(const rmw_event_t *event_handle, void *event_info, bool *taken)
     * }
     */
    public static int rmw_take_event(MemorySegment event_handle, MemorySegment event_info, MemorySegment taken) {
        var mh$ = rmw_take_event.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_take_event", event_handle, event_info, taken);
            }
            return (int)mh$.invokeExact(event_handle, event_info, taken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_event_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_event_fini"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_event_fini(rmw_event_t *event)
     * }
     */
    public static FunctionDescriptor rmw_event_fini$descriptor() {
        return rmw_event_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_event_fini(rmw_event_t *event)
     * }
     */
    public static MethodHandle rmw_event_fini$handle() {
        return rmw_event_fini.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_event_fini(rmw_event_t *event)
     * }
     */
    public static int rmw_event_fini(MemorySegment event) {
        var mh$ = rmw_event_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_event_fini", event);
            }
            return (int)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_get_default_publisher_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rmw_publisher_options_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_get_default_publisher_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_publisher_options_t rmw_get_default_publisher_options()
     * }
     */
    public static FunctionDescriptor rmw_get_default_publisher_options$descriptor() {
        return rmw_get_default_publisher_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_publisher_options_t rmw_get_default_publisher_options()
     * }
     */
    public static MethodHandle rmw_get_default_publisher_options$handle() {
        return rmw_get_default_publisher_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_publisher_options_t rmw_get_default_publisher_options()
     * }
     */
    public static MemorySegment rmw_get_default_publisher_options(SegmentAllocator allocator) {
        var mh$ = rmw_get_default_publisher_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_get_default_publisher_options", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RMW_QOS_COMPATIBILITY_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_compatibility_type_e.RMW_QOS_COMPATIBILITY_OK = 0
     * }
     */
    public static int RMW_QOS_COMPATIBILITY_OK() {
        return RMW_QOS_COMPATIBILITY_OK;
    }
    private static final int RMW_QOS_COMPATIBILITY_WARNING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_compatibility_type_e.RMW_QOS_COMPATIBILITY_WARNING = 1
     * }
     */
    public static int RMW_QOS_COMPATIBILITY_WARNING() {
        return RMW_QOS_COMPATIBILITY_WARNING;
    }
    private static final int RMW_QOS_COMPATIBILITY_ERROR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rmw_qos_compatibility_type_e.RMW_QOS_COMPATIBILITY_ERROR = 2
     * }
     */
    public static int RMW_QOS_COMPATIBILITY_ERROR() {
        return RMW_QOS_COMPATIBILITY_ERROR;
    }

    private static class rmw_qos_profile_check_compatible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            rmw_qos_profile_s.layout(),
            rmw_qos_profile_s.layout(),
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_qos_profile_check_compatible"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_qos_profile_check_compatible(const rmw_qos_profile_t publisher_profile, const rmw_qos_profile_t subscription_profile, rmw_qos_compatibility_type_t *compatibility, char *reason, size_t reason_size)
     * }
     */
    public static FunctionDescriptor rmw_qos_profile_check_compatible$descriptor() {
        return rmw_qos_profile_check_compatible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_qos_profile_check_compatible(const rmw_qos_profile_t publisher_profile, const rmw_qos_profile_t subscription_profile, rmw_qos_compatibility_type_t *compatibility, char *reason, size_t reason_size)
     * }
     */
    public static MethodHandle rmw_qos_profile_check_compatible$handle() {
        return rmw_qos_profile_check_compatible.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_qos_profile_check_compatible(const rmw_qos_profile_t publisher_profile, const rmw_qos_profile_t subscription_profile, rmw_qos_compatibility_type_t *compatibility, char *reason, size_t reason_size)
     * }
     */
    public static int rmw_qos_profile_check_compatible(MemorySegment publisher_profile, MemorySegment subscription_profile, MemorySegment compatibility, MemorySegment reason, long reason_size) {
        var mh$ = rmw_qos_profile_check_compatible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_qos_profile_check_compatible", publisher_profile, subscription_profile, compatibility, reason, reason_size);
            }
            return (int)mh$.invokeExact(publisher_profile, subscription_profile, compatibility, reason, reason_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_get_default_subscription_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rmw_subscription_options_s.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_get_default_subscription_options"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_subscription_options_t rmw_get_default_subscription_options()
     * }
     */
    public static FunctionDescriptor rmw_get_default_subscription_options$descriptor() {
        return rmw_get_default_subscription_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_subscription_options_t rmw_get_default_subscription_options()
     * }
     */
    public static MethodHandle rmw_get_default_subscription_options$handle() {
        return rmw_get_default_subscription_options.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_subscription_options_t rmw_get_default_subscription_options()
     * }
     */
    public static MemorySegment rmw_get_default_subscription_options(SegmentAllocator allocator) {
        var mh$ = rmw_get_default_subscription_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_get_default_subscription_options", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_get_implementation_identifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_get_implementation_identifier"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rmw_get_implementation_identifier()
     * }
     */
    public static FunctionDescriptor rmw_get_implementation_identifier$descriptor() {
        return rmw_get_implementation_identifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rmw_get_implementation_identifier()
     * }
     */
    public static MethodHandle rmw_get_implementation_identifier$handle() {
        return rmw_get_implementation_identifier.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rmw_get_implementation_identifier()
     * }
     */
    public static MemorySegment rmw_get_implementation_identifier() {
        var mh$ = rmw_get_implementation_identifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_get_implementation_identifier");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_get_serialization_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_get_serialization_format"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rmw_get_serialization_format()
     * }
     */
    public static FunctionDescriptor rmw_get_serialization_format$descriptor() {
        return rmw_get_serialization_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rmw_get_serialization_format()
     * }
     */
    public static MethodHandle rmw_get_serialization_format$handle() {
        return rmw_get_serialization_format.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *rmw_get_serialization_format()
     * }
     */
    public static MemorySegment rmw_get_serialization_format() {
        var mh$ = rmw_get_serialization_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_get_serialization_format");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_create_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_create_node"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_node_t *rmw_create_node(rmw_context_t *context, const char *name, const char *namespace_)
     * }
     */
    public static FunctionDescriptor rmw_create_node$descriptor() {
        return rmw_create_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_node_t *rmw_create_node(rmw_context_t *context, const char *name, const char *namespace_)
     * }
     */
    public static MethodHandle rmw_create_node$handle() {
        return rmw_create_node.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_node_t *rmw_create_node(rmw_context_t *context, const char *name, const char *namespace_)
     * }
     */
    public static MemorySegment rmw_create_node(MemorySegment context, MemorySegment name, MemorySegment namespace_) {
        var mh$ = rmw_create_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_create_node", context, name, namespace_);
            }
            return (MemorySegment)mh$.invokeExact(context, name, namespace_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_destroy_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_destroy_node"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_destroy_node(rmw_node_t *node)
     * }
     */
    public static FunctionDescriptor rmw_destroy_node$descriptor() {
        return rmw_destroy_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_destroy_node(rmw_node_t *node)
     * }
     */
    public static MethodHandle rmw_destroy_node$handle() {
        return rmw_destroy_node.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_destroy_node(rmw_node_t *node)
     * }
     */
    public static int rmw_destroy_node(MemorySegment node) {
        var mh$ = rmw_destroy_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_destroy_node", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_node_assert_liveliness {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_node_assert_liveliness"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_node_assert_liveliness(const rmw_node_t *node)
     * }
     */
    public static FunctionDescriptor rmw_node_assert_liveliness$descriptor() {
        return rmw_node_assert_liveliness.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_node_assert_liveliness(const rmw_node_t *node)
     * }
     */
    public static MethodHandle rmw_node_assert_liveliness$handle() {
        return rmw_node_assert_liveliness.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_node_assert_liveliness(const rmw_node_t *node)
     * }
     */
    public static int rmw_node_assert_liveliness(MemorySegment node) {
        var mh$ = rmw_node_assert_liveliness.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_node_assert_liveliness", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_node_get_graph_guard_condition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_node_get_graph_guard_condition"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const rmw_guard_condition_t *rmw_node_get_graph_guard_condition(const rmw_node_t *node)
     * }
     */
    public static FunctionDescriptor rmw_node_get_graph_guard_condition$descriptor() {
        return rmw_node_get_graph_guard_condition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const rmw_guard_condition_t *rmw_node_get_graph_guard_condition(const rmw_node_t *node)
     * }
     */
    public static MethodHandle rmw_node_get_graph_guard_condition$handle() {
        return rmw_node_get_graph_guard_condition.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const rmw_guard_condition_t *rmw_node_get_graph_guard_condition(const rmw_node_t *node)
     * }
     */
    public static MemorySegment rmw_node_get_graph_guard_condition(MemorySegment node) {
        var mh$ = rmw_node_get_graph_guard_condition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_node_get_graph_guard_condition", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_init_publisher_allocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_init_publisher_allocation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_publisher_allocation(const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rmw_init_publisher_allocation$descriptor() {
        return rmw_init_publisher_allocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_publisher_allocation(const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static MethodHandle rmw_init_publisher_allocation$handle() {
        return rmw_init_publisher_allocation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_init_publisher_allocation(const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static int rmw_init_publisher_allocation(MemorySegment type_support, MemorySegment message_bounds, MemorySegment allocation) {
        var mh$ = rmw_init_publisher_allocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_init_publisher_allocation", type_support, message_bounds, allocation);
            }
            return (int)mh$.invokeExact(type_support, message_bounds, allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_fini_publisher_allocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_fini_publisher_allocation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_fini_publisher_allocation(rmw_publisher_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rmw_fini_publisher_allocation$descriptor() {
        return rmw_fini_publisher_allocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_fini_publisher_allocation(rmw_publisher_allocation_t *allocation)
     * }
     */
    public static MethodHandle rmw_fini_publisher_allocation$handle() {
        return rmw_fini_publisher_allocation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_fini_publisher_allocation(rmw_publisher_allocation_t *allocation)
     * }
     */
    public static int rmw_fini_publisher_allocation(MemorySegment allocation) {
        var mh$ = rmw_fini_publisher_allocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_fini_publisher_allocation", allocation);
            }
            return (int)mh$.invokeExact(allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_create_publisher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_create_publisher"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_publisher_t *rmw_create_publisher(const rmw_node_t *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const rmw_qos_profile_t *qos_profile, const rmw_publisher_options_t *publisher_options)
     * }
     */
    public static FunctionDescriptor rmw_create_publisher$descriptor() {
        return rmw_create_publisher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_publisher_t *rmw_create_publisher(const rmw_node_t *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const rmw_qos_profile_t *qos_profile, const rmw_publisher_options_t *publisher_options)
     * }
     */
    public static MethodHandle rmw_create_publisher$handle() {
        return rmw_create_publisher.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_publisher_t *rmw_create_publisher(const rmw_node_t *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const rmw_qos_profile_t *qos_profile, const rmw_publisher_options_t *publisher_options)
     * }
     */
    public static MemorySegment rmw_create_publisher(MemorySegment node, MemorySegment type_support, MemorySegment topic_name, MemorySegment qos_profile, MemorySegment publisher_options) {
        var mh$ = rmw_create_publisher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_create_publisher", node, type_support, topic_name, qos_profile, publisher_options);
            }
            return (MemorySegment)mh$.invokeExact(node, type_support, topic_name, qos_profile, publisher_options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_destroy_publisher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_destroy_publisher"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_destroy_publisher(rmw_node_t *node, rmw_publisher_t *publisher)
     * }
     */
    public static FunctionDescriptor rmw_destroy_publisher$descriptor() {
        return rmw_destroy_publisher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_destroy_publisher(rmw_node_t *node, rmw_publisher_t *publisher)
     * }
     */
    public static MethodHandle rmw_destroy_publisher$handle() {
        return rmw_destroy_publisher.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_destroy_publisher(rmw_node_t *node, rmw_publisher_t *publisher)
     * }
     */
    public static int rmw_destroy_publisher(MemorySegment node, MemorySegment publisher) {
        var mh$ = rmw_destroy_publisher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_destroy_publisher", node, publisher);
            }
            return (int)mh$.invokeExact(node, publisher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_borrow_loaned_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_borrow_loaned_message"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_borrow_loaned_message(const rmw_publisher_t *publisher, const rosidl_message_type_support_t *type_support, void **ros_message)
     * }
     */
    public static FunctionDescriptor rmw_borrow_loaned_message$descriptor() {
        return rmw_borrow_loaned_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_borrow_loaned_message(const rmw_publisher_t *publisher, const rosidl_message_type_support_t *type_support, void **ros_message)
     * }
     */
    public static MethodHandle rmw_borrow_loaned_message$handle() {
        return rmw_borrow_loaned_message.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_borrow_loaned_message(const rmw_publisher_t *publisher, const rosidl_message_type_support_t *type_support, void **ros_message)
     * }
     */
    public static int rmw_borrow_loaned_message(MemorySegment publisher, MemorySegment type_support, MemorySegment ros_message) {
        var mh$ = rmw_borrow_loaned_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_borrow_loaned_message", publisher, type_support, ros_message);
            }
            return (int)mh$.invokeExact(publisher, type_support, ros_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_return_loaned_message_from_publisher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_return_loaned_message_from_publisher"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_return_loaned_message_from_publisher(const rmw_publisher_t *publisher, void *loaned_message)
     * }
     */
    public static FunctionDescriptor rmw_return_loaned_message_from_publisher$descriptor() {
        return rmw_return_loaned_message_from_publisher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_return_loaned_message_from_publisher(const rmw_publisher_t *publisher, void *loaned_message)
     * }
     */
    public static MethodHandle rmw_return_loaned_message_from_publisher$handle() {
        return rmw_return_loaned_message_from_publisher.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_return_loaned_message_from_publisher(const rmw_publisher_t *publisher, void *loaned_message)
     * }
     */
    public static int rmw_return_loaned_message_from_publisher(MemorySegment publisher, MemorySegment loaned_message) {
        var mh$ = rmw_return_loaned_message_from_publisher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_return_loaned_message_from_publisher", publisher, loaned_message);
            }
            return (int)mh$.invokeExact(publisher, loaned_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_publish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_publish"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publish(const rmw_publisher_t *publisher, const void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rmw_publish$descriptor() {
        return rmw_publish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publish(const rmw_publisher_t *publisher, const void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static MethodHandle rmw_publish$handle() {
        return rmw_publish.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_publish(const rmw_publisher_t *publisher, const void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static int rmw_publish(MemorySegment publisher, MemorySegment ros_message, MemorySegment allocation) {
        var mh$ = rmw_publish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_publish", publisher, ros_message, allocation);
            }
            return (int)mh$.invokeExact(publisher, ros_message, allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_publish_loaned_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_publish_loaned_message"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publish_loaned_message(const rmw_publisher_t *publisher, void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rmw_publish_loaned_message$descriptor() {
        return rmw_publish_loaned_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publish_loaned_message(const rmw_publisher_t *publisher, void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static MethodHandle rmw_publish_loaned_message$handle() {
        return rmw_publish_loaned_message.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_publish_loaned_message(const rmw_publisher_t *publisher, void *ros_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static int rmw_publish_loaned_message(MemorySegment publisher, MemorySegment ros_message, MemorySegment allocation) {
        var mh$ = rmw_publish_loaned_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_publish_loaned_message", publisher, ros_message, allocation);
            }
            return (int)mh$.invokeExact(publisher, ros_message, allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_publisher_count_matched_subscriptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_publisher_count_matched_subscriptions"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_count_matched_subscriptions(const rmw_publisher_t *publisher, size_t *subscription_count)
     * }
     */
    public static FunctionDescriptor rmw_publisher_count_matched_subscriptions$descriptor() {
        return rmw_publisher_count_matched_subscriptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_count_matched_subscriptions(const rmw_publisher_t *publisher, size_t *subscription_count)
     * }
     */
    public static MethodHandle rmw_publisher_count_matched_subscriptions$handle() {
        return rmw_publisher_count_matched_subscriptions.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_count_matched_subscriptions(const rmw_publisher_t *publisher, size_t *subscription_count)
     * }
     */
    public static int rmw_publisher_count_matched_subscriptions(MemorySegment publisher, MemorySegment subscription_count) {
        var mh$ = rmw_publisher_count_matched_subscriptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_publisher_count_matched_subscriptions", publisher, subscription_count);
            }
            return (int)mh$.invokeExact(publisher, subscription_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_publisher_get_actual_qos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_publisher_get_actual_qos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_get_actual_qos(const rmw_publisher_t *publisher, rmw_qos_profile_t *qos)
     * }
     */
    public static FunctionDescriptor rmw_publisher_get_actual_qos$descriptor() {
        return rmw_publisher_get_actual_qos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_get_actual_qos(const rmw_publisher_t *publisher, rmw_qos_profile_t *qos)
     * }
     */
    public static MethodHandle rmw_publisher_get_actual_qos$handle() {
        return rmw_publisher_get_actual_qos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_get_actual_qos(const rmw_publisher_t *publisher, rmw_qos_profile_t *qos)
     * }
     */
    public static int rmw_publisher_get_actual_qos(MemorySegment publisher, MemorySegment qos) {
        var mh$ = rmw_publisher_get_actual_qos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_publisher_get_actual_qos", publisher, qos);
            }
            return (int)mh$.invokeExact(publisher, qos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_publish_serialized_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_publish_serialized_message"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publish_serialized_message(const rmw_publisher_t *publisher, const rmw_serialized_message_t *serialized_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static FunctionDescriptor rmw_publish_serialized_message$descriptor() {
        return rmw_publish_serialized_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publish_serialized_message(const rmw_publisher_t *publisher, const rmw_serialized_message_t *serialized_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static MethodHandle rmw_publish_serialized_message$handle() {
        return rmw_publish_serialized_message.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_publish_serialized_message(const rmw_publisher_t *publisher, const rmw_serialized_message_t *serialized_message, rmw_publisher_allocation_t *allocation)
     * }
     */
    public static int rmw_publish_serialized_message(MemorySegment publisher, MemorySegment serialized_message, MemorySegment allocation) {
        var mh$ = rmw_publish_serialized_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_publish_serialized_message", publisher, serialized_message, allocation);
            }
            return (int)mh$.invokeExact(publisher, serialized_message, allocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_get_serialized_message_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_get_serialized_message_size"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_get_serialized_message_size(const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, size_t *size)
     * }
     */
    public static FunctionDescriptor rmw_get_serialized_message_size$descriptor() {
        return rmw_get_serialized_message_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_get_serialized_message_size(const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, size_t *size)
     * }
     */
    public static MethodHandle rmw_get_serialized_message_size$handle() {
        return rmw_get_serialized_message_size.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_get_serialized_message_size(const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, size_t *size)
     * }
     */
    public static int rmw_get_serialized_message_size(MemorySegment type_support, MemorySegment message_bounds, MemorySegment size) {
        var mh$ = rmw_get_serialized_message_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_get_serialized_message_size", type_support, message_bounds, size);
            }
            return (int)mh$.invokeExact(type_support, message_bounds, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_publisher_assert_liveliness {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_publisher_assert_liveliness"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_assert_liveliness(const rmw_publisher_t *publisher)
     * }
     */
    public static FunctionDescriptor rmw_publisher_assert_liveliness$descriptor() {
        return rmw_publisher_assert_liveliness.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_assert_liveliness(const rmw_publisher_t *publisher)
     * }
     */
    public static MethodHandle rmw_publisher_assert_liveliness$handle() {
        return rmw_publisher_assert_liveliness.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_assert_liveliness(const rmw_publisher_t *publisher)
     * }
     */
    public static int rmw_publisher_assert_liveliness(MemorySegment publisher) {
        var mh$ = rmw_publisher_assert_liveliness.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_publisher_assert_liveliness", publisher);
            }
            return (int)mh$.invokeExact(publisher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_publisher_wait_for_all_acked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            rmw_time_s.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_publisher_wait_for_all_acked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_wait_for_all_acked(const rmw_publisher_t *publisher, rmw_time_t wait_timeout)
     * }
     */
    public static FunctionDescriptor rmw_publisher_wait_for_all_acked$descriptor() {
        return rmw_publisher_wait_for_all_acked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_wait_for_all_acked(const rmw_publisher_t *publisher, rmw_time_t wait_timeout)
     * }
     */
    public static MethodHandle rmw_publisher_wait_for_all_acked$handle() {
        return rmw_publisher_wait_for_all_acked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_publisher_wait_for_all_acked(const rmw_publisher_t *publisher, rmw_time_t wait_timeout)
     * }
     */
    public static int rmw_publisher_wait_for_all_acked(MemorySegment publisher, MemorySegment wait_timeout) {
        var mh$ = rmw_publisher_wait_for_all_acked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_publisher_wait_for_all_acked", publisher, wait_timeout);
            }
            return (int)mh$.invokeExact(publisher, wait_timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmw_serialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gen_h.C_INT,
            gen_h.C_POINTER,
            gen_h.C_POINTER,
            gen_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    gen_h.findOrThrow("rmw_serialize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_serialize(const void *ros_message, const rosidl_message_type_support_t *type_support, rmw_serialized_message_t *serialized_message)
     * }
     */
    public static FunctionDescriptor rmw_serialize$descriptor() {
        return rmw_serialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rmw_ret_t rmw_serialize(const void *ros_message, const rosidl_message_type_support_t *type_support, rmw_serialized_message_t *serialized_message)
     * }
     */
    public static MethodHandle rmw_serialize$handle() {
        return rmw_serialize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * rmw_ret_t rmw_serialize(const void *ros_message, const rosidl_message_type_support_t *type_support, rmw_serialized_message_t *serialized_message)
     * }
     */
    public static int rmw_serialize(MemorySegment ros_message, MemorySegment type_support, MemorySegment serialized_message) {
        var mh$ = rmw_serialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmw_serialize", ros_message, type_support, serialized_message);
            }
            return (int)mh$.invokeExact(ros_message, type_support, serialized_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

